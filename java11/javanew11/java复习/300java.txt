1.网络编程:
	编程程序实现不同设备之间的信息的交互;
2.网络通信三要素
	1.ip设备的编号(为了方便找到这台设备)
		ipv4 在2011年就宣告没有了, 从此出现ipv6
	2.端口:程序的编号(为了方便找到这个程序)(0 - 65535) (0-1024) (1024 -- 65535)
		腾讯的QQ 4000:
	3.协议:程序交流的规范(UDP TCP)
		udp: 面向无连接,数据不可靠, 传输效率高
		Tcp: 面向连接, 数据可靠,传输效率低 , (需要三次握手: 为什么? 要确保双方信道都是畅通的)

	我们没办法直接使用,只能通过一个介质来使用,那个介质就是Socket()
Socket


3.InetAddress 是专门用来封装我们的ip;

    127.0.0.1 代表本地ip地址

4.编写程序的时候常见的两个错误
 1.端口号被绑定
 2.找不到主机;
5.今天遇到的阻塞方法
	1.receive(DatagramSocket p)//UDP接收端等待发送端的数据的时候,如果没有数据就一直处于等待
	2. accept();//服务端等待客户端介入,如果没有客户端介入,一直等待
	3.read()//TCP 两端等待对方的数据的时候,如果没有数据过来就处于等待状态;

6.TCP协议需要注意事项
	客户端:
		创建Socket连接服务端

	 


package com.itheima;

public class HelloWorld {
	public static void main(String[] args) {
		System.out.println("我是黑马程序员,我骄傲,我自豪");
	}
}
package com.itheima_02;

/*
 * 内容辅助键：alt+/
 * 		A:main方法
 * 			main,然后alt+/,回车
 * 		B:输出语句
 * 			syso,然后然后alt+/,回车
 * 
 * 快捷键：
 * 		A:注释
 * 			单行	选中内容，ctrl+/,再来一次就是取消
 * 			多行	选择内容，ctrl+shift+/,ctrl+shift+\
 * 		B:格式化
 * 			ctrl+shift+f
 */
public class HelloWorld {
	public static void main(String[] args) {
		System.out.println("HelloWorld1");
		System.out.println("HelloWorld2");
		System.out.println("HelloWorld3");
		System.out.println("HelloWorld4");
		System.out.println("HelloWorld5");
	}
}
package com.itheima_01;

/*
 * 运算符：对常量和变量进行操作的符号
 * 表达式：用运算符连接起来的符合java语法的式子。不同类型的运算符连接起来的式子是不同的表达式。
 * 		举例：定义两个int类型的变量a,b,
 * 			a + b
 * 
 * 运算符分类：
 * 		算术运算符，赋值运算符，关系运算符，逻辑运算符，三元运算符。
 * 
 * 算术运算符：
 * 		+，-，*，/的基本使用
 */
public class OperatorDemo {
	public static void main(String[] args) {
		// 定义两个变量
		int a = 3;
		int b = 4;

		System.out.println(a + b);
		System.out.println(a - b);
		System.out.println(a * b);
		System.out.println(a / b);

		// 整数相除只能得到整数，要想得到小数，就必须有浮点数参与运算
		System.out.println(3 / 4.0);
		System.out.println(3.0 / 4);
	}
}
package com.itheima_01;

/*
 * %：取余运算符。得到的是两个相除数据的余数。
 * /:除法运算符。得到是两个相除数据的商。
 * 
 * %：判断两个数据是否整除。
 */
public class OperatorDemo2 {
	public static void main(String[] args) {
		int a = 5;
		int b = 3;

		System.out.println(a / b);
		System.out.println(a % b);
	}
}
package com.itheima_01;

/*
 * 整数的加法。
 * 字符参与加法操作。拿字符在计算机中底层存储对应的数据值来参与运算的。
 * 		'0'		48
 * 		'a'		97
 * 		'A'		65
 * 字符串参与加法操作。
 * 		这里的+其实不是加法，而是字符串连接符。
 */
public class OperatorDemo3 {
	public static void main(String[] args) {
		// 整数加法
		int a = 10;
		int b = 20;
		System.out.println(a + b);
		System.out.println("------------------");

		// 字符参与加法操作
		char c = '0';
		char c2 = 'a';
		System.out.println(a + c);
		System.out.println(a + c2);
		System.out.println("------------------");

		// 字符串参与加法操作
		System.out.println("hello" + a);
		System.out.println("hello" + a + b); // "hello"+10,然后再和b进行拼接
		System.out.println(a + b + "hello");
	}
}
package com.itheima_01;

/*
 * ++,--运算符：对变量做加1或者减1的操作。
 * ++或者--既可以放在变量的后面，也可以放在变量的前面。
 * 单独使用的时候，++或者--无论是放在变量的前面还是后面，结果是一样的。
 * 参与操作的时候：
 * 		如果++或者--在变量的后面，先拿变量参与操作，后变量做++或者--
 * 		如果++或者--在变量的前面，先变量做++或者--，后拿变量参与操作
 */
public class OperatorDemo4 {
	public static void main(String[] args) {
		int a = 10;
		System.out.println("a:" + a);

		// 单独使用
		// a++;
		// ++a;
		// System.out.println("a:" + a);

		// 参与操作使用
		// int b = a++;
		int b = ++a;
		System.out.println("a:" + a);
		System.out.println("b:" + b);
	}
}
package com.itheima_02;

/*
 * 赋值运算符：
 * 		A:基本	=
 * 		B:扩展	+=,-=,*=,...
 * 
 * +=:
 * 		a+=20;
 * 		相当于
 * 		a = (a的数据类型)(a + 20);
 */
public class OperatorDemo {
	public static void main(String[] args) {
		// 把10赋值给int类型的变量a
		int a = 10;

		// += 把左边和右边的数据进行运算，最后赋值给左边。左边的只能是变量
		a += 10;// 相当于a = a + 10
		System.out.println("a:" + a);
		System.out.println("----------------------");

		short s = 10;
		// s += 20; // 相当于 s = s + 20;
		s = (short) (s + 20);
		System.out.println("s:" + s);
	}
}
package com.itheima_03;

/*
 * 关系运算符：
 * 		==,!=,>,>=,<,<=
 * 		关系运算符的结果是boolean类型。
 * 
 * 注意：
 * 		千万不要把==写成=
 */
public class OperatorDemo {
	public static void main(String[] args) {
		int a = 10;
		int b = 20;
		int c = 10;

		System.out.println(a == b);
		System.out.println(a == c);
		System.out.println("-----------------");
		System.out.println(a != b);
		System.out.println(a != c);
		System.out.println("-----------------");
		System.out.println(a > b);
		System.out.println(a > c);
		System.out.println("-----------------");
		System.out.println(a >= b);
		System.out.println(a >= c);
		System.out.println("-----------------");

		int x = 3;
		int y = 4;
		// System.out.println(x == y);
		// System.out.println(x = y);// 把y赋值给x，把x的值输出
		boolean bb = (x == y);
		// 报错
		// boolean cc = (x = y);
		int cc = (x = y);
	}
}
package com.itheima_04;

/*
 * 逻辑运算符：用于连接关系表达式。
 * &,|,^,!
 * &&,||
 * 
 * 与：&	有false则false
 * 或：|	有true则true
 * 异或：^ 相同则false,不同则true。(男女朋友)
 * 非：!	true则false,false则true
 */
public class OperatorDemo {
	public static void main(String[] args) {
		int a = 10;
		int b = 20;
		int c = 30;

		System.out.println((a > b) & (a > c));// false & false
		System.out.println((a < b) & (a > c)); // true & false
		System.out.println((a > b) & (a < c)); // false & true
		System.out.println((a < b) & (a < c)); // true & true
		System.out.println("---------------");
		System.out.println((a > b) | (a > c));// false | false
		System.out.println((a < b) | (a > c)); // true | false
		System.out.println((a > b) | (a < c)); // false | true
		System.out.println((a < b) | (a < c)); // true | true
		System.out.println("---------------");
		System.out.println((a > b) ^ (a > c));// false ^ false
		System.out.println((a < b) ^ (a > c)); // true ^ false
		System.out.println((a > b) ^ (a < c)); // false ^ true
		System.out.println((a < b) ^ (a < c)); // true ^ true
		System.out.println("---------------");
		System.out.println((a > b)); // false
		System.out.println(!(a > b)); // !false
		System.out.println(!!(a > b)); // !!false
	}
}
package com.itheima_04;

/*
 * &&和&的结果一样
 * ||和|的结果一样
 * 
 * &&和&的区别：
 * 		&&如果左边是false，右边不执行。
 * 		&无论左边是true还是false，右边都会执行。
 */
public class OperatorDemo2 {
	public static void main(String[] args) {
		int a = 10;
		int b = 20;
		int c = 30;

		System.out.println((a > b) && (a > c));// false && false
		System.out.println((a < b) && (a > c)); // true && false
		System.out.println((a > b) && (a < c)); // false && true
		System.out.println((a < b) && (a < c)); // true && true
		System.out.println("---------------");
		System.out.println((a > b) || (a > c));// false || false
		System.out.println((a < b) || (a > c)); // true || false
		System.out.println((a > b) || (a < c)); // false || true
		System.out.println((a < b) || (a < c)); // true || true
		System.out.println("---------------");

		int x = 3;
		int y = 4;
		// System.out.println((x++ > 4) & (y++ > 5)); // false & false
		System.out.println((x++ > 4) && (y++ > 5)); // false && false
		System.out.println("x:" + x);
		System.out.println("y:" + y);
	}
}
package com.itheima_05;

/*
 * 三元运算符：
 * 
 * 格式：
 * 		(关系表达式)?表达式1:表达式2;
 * 执行流程:
 * 		A:计算关系表达式的值，看是true还是false
 * 		B:如果是true,表达式1就是运算结果
 * 		      如果是false,表达式2就是运算结果
 */
public class OperatorDemo {
	public static void main(String[] args) {
		int a = 10;
		int b = 20;

		int c = (a > b) ? a : b;
		System.out.println("c:" + c);
	}
}
package com.itheima_05;

/*
 * 三元运算符的练习
 * 比较两个整数是否相同
 */
public class OperatorTest {
	public static void main(String[] args) {
		// 定义两个int类型的变量
		int a = 10;
		int b = 20;

		boolean flag = (a == b) ? true : false;
		// boolean flag = (a == b);
		System.out.println(flag);
	}
}
package com.itheima_05;

/*
 * 获取三个整数中的最大值
 */
public class OperatorTest2 {
	public static void main(String[] args) {
		// 定义三个int类型的变量
		int a = 10;
		int b = 30;
		int c = 20;

		// 先比较两个整数的大值
		int temp = ((a > b) ? a : b);
		int max = ((temp > c) ? temp : c);
		System.out.println("max:" + max);
	}
}
package com.itheima;
import java.util.Scanner;
/*
 * 为了提高程序的灵活性，我们就把数据改进为键盘录入。
 * 如何实现键盘录入呢?目前我们只能使用JDK提供的类Scanner。
 * 这个使用的步骤，目前大家记住就可以了。
 * 
 * 使用步骤：
 * 		A:导包
 * 			import java.util.Scanner;
 * 			类中的顺序：package > import > class
 * 		B:创建对象
 * 			Scanner sc = new Scanner(System.in);
 * 		C:接收数据
 * 			int i = sc.nextInt();
 */

public class ScannerDemo {
	public static void main(String[] args) {
		//创建键盘录入数据的对象
		Scanner sc = new Scanner(System.in);
		
		//接收数据
		System.out.println("请录入一个整数：");
		int i = sc.nextInt();
		
		//输出数据
		System.out.println("i:"+i);
	}
}
package com.itheima;

import java.util.Scanner;

/*
 * 键盘录入两个数据，并对这两个数据求和，输出其结果
 * 
 * 键盘录入：
 * 		A:导包
 * 		B:创建对象
 * 		C:接收数据
 */
public class ScannerTest {
	public static void main(String[] args) {
		// 创建对象
		Scanner sc = new Scanner(System.in);

		// 接收数据
		System.out.println("请输入第一个数据：");
		int a = sc.nextInt();

		System.out.println("请输入第二个数据：");
		int b = sc.nextInt();

		// 对数据进行求和
		int sum = a + b;
		System.out.println("sum:" + sum);
	}
}
package com.itheima;

import java.util.Scanner;

/*
 * 键盘录入两个数据，比较这两个数据是否相等
 */
public class ScannerTest2 {
	public static void main(String[] args) {
		// 创建对象
		Scanner sc = new Scanner(System.in);

		// 接收数据
		System.out.println("请输入第一个数据：");
		int a = sc.nextInt();

		System.out.println("请输入第二个数据：");
		int b = sc.nextInt();

		// 比较两个数据是否相等
		// boolean flag = ((a == b) ? true : false);
		boolean flag = (a == b);
		System.out.println("flag:" + flag);
	}
}
package com.itheima;

import java.util.Scanner;

/*
 * 键盘录入三个数据，获取这三个数据中的最大值
 */
public class ScannerTest3 {
	public static void main(String[] args) {
		// 创建对象
		Scanner sc = new Scanner(System.in);

		// 接收数据
		System.out.println("请输入第一个数据：");
		int a = sc.nextInt();

		System.out.println("请输入第二个数据：");
		int b = sc.nextInt();

		System.out.println("请输入第三个数据：");
		int c = sc.nextInt();

		// 如何获取三个数据的最大值
		int temp = (a > b ? a : b);
		int max = (temp > c ? temp : c);

		System.out.println("max:" + max);
	}
}
package com.itheima_01;

/*
 * 顺序结构：从上往下，依次执行
 */
public class OrderDemo {
	public static void main(String[] args) {
		System.out.println("开始");
		System.out.println("语句A");
		System.out.println("语句B");
		System.out.println("语句C");
		System.out.println("结束");
	}
}
package com.itheima_02;

/*
 * if语句有三种格式。
 * 
 * if语句格式1：
 * 		if(关系表达式) {
 * 			语句体;
 * 		}
 * 
 * 执行流程：
 * 		A:首先判断关系表达式看其结果是true还是false
 * 		B:如果是true,就执行语句体
 * 		C:如果是false,就不执行语句体
 */
public class IfDemo {
	public static void main(String[] args) {
		System.out.println("开始");
		// 定义两个变量
		int a = 10;
		int b = 20;

		if (a == b) {
			System.out.println("a等于b");
		}

		int c = 10;
		if (a == c) {
			System.out.println("a等于c");
		}

		System.out.println("结束");
	}
}
package com.itheima_02;

/*
 * if语句格式2：
 * 		if(关系表达式) {
 * 			语句体1;
 * 		}else {
 * 			语句体2;
 * 		}
 * 
 * 执行流程：
 * 		A:判断关系表达式的值是true还是false
 * 		B:如果是true，就执行语句体1
 * 		C:如果是false，就执行语句体2
 */
public class IfDemo2 {
	public static void main(String[] args) {
		System.out.println("开始");
		// 判断给定的数据是奇数还是偶数
		// 定义变量
		int a = 100;
		// 给a重新赋值
		a = 99;

		if (a % 2 == 0) {
			System.out.println("a是偶数");
		} else {
			System.out.println("a是奇数");
		}

		System.out.println("结束");
	}
}
package com.itheima_02;

/*
 * if语句格式3：
 * 		if(关系表达式1) {
 * 			语句体1;
 * 		}else if(关系表达式2) {
 * 			语句体2;
 * 		}else if(关系表达式3) {
 * 			语句体3;
 * 		}
 * 		...
 * 		else {
 * 			语句体n+1;
 * 		}
 * 
 * 执行流程：
 * 		A:首先判断关系表达式1看其结果是true还是false
 * 		B:如果是true，就执行语句体1
 * 		     如果是false，就继续进行关系表达式2的判断看其结果是true还是false
 * 		C:如果是true，就执行语句体2
 * 		   如果是false，就继续进行关系表达式...的判断看其结果是true还是false
 * 		...
 * 		D:如果没有一个为true的，就执行语句体n+1
 * 
 * if语句的三种格式：
 * 		第一种格式适合做一种情况的判断
 * 		第二种格式适合做二种情况的判断
 * 		第三种格式适合做多种情况的判断
 */
public class IfDemo3 {
	public static void main(String[] args) {
		// x和y的关系满足如下：
		// x>=3 y = 2x + 1;
		// -1<=x<3 y = 2x;
		// x<=-1 y = 2x – 1;
		// 根据给定的x的值，计算出y的值并输出。

		// 定义变量
		int x = 5;
		
		/*
		int y;
		if (x >= 3) {
			y = 2 * x + 1;
		} else if (x >= -1 && x < 3) {
			y = 2 * x;
		} else if (x <= -1) {
			y = 2 * x - 1;
		}else {
			y = 0;
		}
		*/
		
		int y = 0;
		if (x >= 3) {
			y = 2 * x + 1;
		} else if (x >= -1 && x < 3) {
			y = 2 * x;
		} else if (x <= -1) {
			y = 2 * x - 1;
		}
		
		System.out.println("y的值是："+y);
	}
}
package com.itheima_02;

import java.util.Scanner;

/*
 * 键盘录入两个数据，获取这两个数据的较大值
 * 
 * 分析：
 * 		A:看到键盘录入，我们就应该想到键盘录入的三步骤
 * 			导包，创建对象，接收数据
 * 		B:获取这两个数据的较大值，其实就是判断两个数据谁大，把大的输出就可以了。
 * 
 * 导包：
 * 		A:手动导包
 * 			import java.util.Scanner;
 * 		B:鼠标点击红色叉叉，自动生成
 * 		C:快捷键(推荐)
 * 			ctrl+shift+o
 */
public class IfTest {
	public static void main(String[] args) {
		//创建对象
		Scanner sc = new Scanner(System.in);
		
		//接收数据
		System.out.println("请输入第一个数据：");
		int a = sc.nextInt();
		
		System.out.println("请输入第二个数据：");
		int b = sc.nextInt();
		
		//采用if语句格式2实现
		/*
		if(a>b){
			System.out.println("较大的值是："+a);
		}else {
			System.out.println("较大的值是："+b);
		}
		*/
		
		//拿到较大的值之后，我未必想直接输出，所以我们定义变量接收这个较大的值
		int max;
		if(a>b){
			max = a;
		}else {
			max = b;
		}
		//可能做其他的操作
		//max += 100;
		System.out.println("较大的值是："+max);
	}
}
package com.itheima_02;

import java.util.Scanner;

/*
 * 键盘录入学生考试成绩，请根据成绩判断该学生属于哪个级别
 * 90-100	优秀
 * 80-90	好
 * 70-80	良
 * 60-70	及格
 * 60以下	不及格
 * 
 * 分析：
 * 		A:键盘录入学生考试成绩
 * 			三步骤
 * 		B:通过简单的分析，我们决定采用if语句格式3来实现
 * 
 * 程序一定要考虑周全了。
 * 		安全数据
 * 		边界数据
 * 		错误数据
 */
public class IfTest2 {
	public static void main(String[] args) {
		//创建对象
		Scanner sc = new Scanner(System.in);
		
		//接收数据
		System.out.println("请输入学生的考试成绩：");
		int score = sc.nextInt();
		
		//if语句格式3
		/*
		if(score>=90 && score<=100){
			System.out.println("你的成绩属于优秀");
		}else if(score>=80 && score<90){
			System.out.println("你的成绩属于好");
		}else if(score>=70 && score<80){
			System.out.println("你的成绩属于良");
		}else if(score>=60 && score<70){
			System.out.println("你的成绩属于及格");
		}else {
			System.out.println("你的成绩属于不及格");
		}
		*/
		
		//我们发现程序不够健壮,加入错误数据的判断
		if(score<0 || score>100){
			System.out.println("你的成绩是错误的");
		}else if(score>=90 && score<=100){
			System.out.println("你的成绩属于优秀");
		}else if(score>=80 && score<90){
			System.out.println("你的成绩属于好");
		}else if(score>=70 && score<80){
			System.out.println("你的成绩属于良");
		}else if(score>=60 && score<70){
			System.out.println("你的成绩属于及格");
		}else {
			System.out.println("你的成绩属于不及格");
		}
	}
}
package com.itheima_03;

import java.util.Scanner;

/*
 * switch语句格式：
 * switch(表达式) {
 * 		case 值1:
 * 			语句体1;
 * 			break;
 * 		case 值2:
 * 			语句体2;
 * 			break;
 * 		...
 * 		default:
 * 			语句体n+1;
 * 			break;
 * }
 * 格式解释：
 * 		表达式:byte,short,int,char
 * 			JDK5以后可以是枚举
 * 			JDK7以后可以是字符串
 * 		case:就是要和表达式进行比较的值
 * 		break:表示中断,结束的意思。
 * 		default:表示所有的情况都不匹配的时候，就执行语句体n+1。和if语句的else相似。
 * 执行流程：
 * 		A:计算出表达式的值
 * 		B:拿计算出来的值和case后面的值依次比较，一旦有对应的值，就执行该处的语句，在执行过程中，遇到 break，就结束。
 * 		C:如果所有的case都不匹配，就会执行default控制的语句，然后结束。
 * 需求：
 * 		根据键盘录入的数值1，2，3，…7输出对应的星期一，星期二，星期三…星期日。
 */
public class SwitchDemo {
	public static void main(String[] args) {
		//创建键盘录入对象
		Scanner sc = new Scanner(System.in);
		
		//接收数据
		System.out.println("请输入一个数字(1-7)：");
		int weekday = sc.nextInt();
		
		//switch语句实现选择
		switch(weekday) {
		case 1:
			System.out.println("星期一");
			break;
		case 2:
			System.out.println("星期二");
			break;
		case 3:
			System.out.println("星期三");
			break;
		case 4:
			System.out.println("星期四");
			break;
		case 5:
			System.out.println("星期五");
			break;
		case 6:
			System.out.println("星期六");
			break;
		case 7:
			System.out.println("星期日");
			break;
		default:
			System.out.println("你输入的数字有误");
			break;
		}
		
		
		
		
		
		
		
	}
}
package com.itheima_04;
/*
 * for循环语句格式：
 * 		for(初始化语句;判断条件语句;控制条件语句) {
 * 			循环体语句;
 * 		}
 * 
 * 		执行流程：
 * 			A:执行初始化语句
 * 			B:执行判断条件语句，看结果是true还是false
 * 				如果是true，就继续执行
 * 				如果是false，就结束循环
 * 			C:执行循环体语句
 * 			D:执行控制条件语句
 * 			E:回到B继续
 * 
 * 需求：
 * 		在控制台输出10次”HelloWorld”的案例。
 */
public class ForDemo {
	public static void main(String[] args) {
		//原始写法
		System.out.println("HelloWorld");
		System.out.println("HelloWorld");
		System.out.println("HelloWorld");
		System.out.println("HelloWorld");
		System.out.println("HelloWorld");
		System.out.println("HelloWorld");
		System.out.println("HelloWorld");
		System.out.println("HelloWorld");
		System.out.println("HelloWorld");
		System.out.println("HelloWorld");
		System.out.println("-------------------------");
		
		//用循环改进
		for(int x=1; x<=10; x++) {
			System.out.println("HelloWorld");
		}
	}
}
package com.itheima_04;
/*
 * 需求：获取数据1-5和5-1
 */
public class ForTest {
	public static void main(String[] args) {
		//原始做法
		System.out.println(1);
		System.out.println(2);
		System.out.println(3);
		System.out.println(4);
		System.out.println(5);
		System.out.println("-------------");
		
		//用循环改进
		for(int x=1; x<=5; x++) {
			System.out.println(x);
		}
		System.out.println("-------------");
		
		//1-5的数据我们获取到了，如何获取5-1呢?
		for(int x=5; x>=1; x--){
			System.out.println(x);
		}
	}
}
package com.itheima_04;
/*
 * 需求：求出1-5之间数据之和
 * 
 * 分析：
 * 		A:定义求和变量，初始化值是0
 * 		B:获取1-5之间的数据，用for循环实现
 * 		C:把每一次获取到的数据，累加起来就可以了
 * 		D:输出求和变量即可
 */
public class ForTest2 {
	public static void main(String[] args) {
		//定义求和变量，初始化值是0
		int sum = 0;
		
		//获取1-5之间的数据，用for循环实现
		for(int x=1; x<=5; x++) {
			//把每一次获取到的数据，累加起来就可以了
			//sum = sum + x;
			/*
			 * 第一次：sum = 0 + 1 = 1
			 * 第二次：sum = 1 + 2 = 3
			 * 第三次：sum = 3 + 3 = 6
			 * 第四次：sum = 6 + 4 = 10
			 * 第五次：sum = 10 + 5 = 15
			 */
			sum += x;
		}
		
		//输出求和结果
		System.out.println("sum:"+sum);
	}
}
package com.itheima_04;
/*
 * 需求：求出1-100之间偶数和
 * 
 * 分析：
 * 		A:定义求和变量，初始化值是0
 * 		B:获取1-100之间的数据，用for循环实现
 * 		C:把获取到的数据进行判断，看是否是偶数
 * 			如果是，就累加
 * 		D:输出求和结果
 */
public class ForTest3 {
	public static void main(String[] args) {
		//定义求和变量，初始化值是0
		int sum = 0;
		
		//获取1-100之间的数据，用for循环实现
		for(int x=1; x<=100; x++) {
			//把获取到的数据进行判断，看是否是偶数
			if(x%2 ==0) {
				sum += x;
			}
		}
		
		//输出求和结果
		System.out.println("sum:"+sum);
	}
}
package com.itheima_04;
/*
 * 需求：在控制台输出所有的”水仙花数”
 * 
 * 分析：
 * 		什么是水仙花数呢?
 * 			所谓的水仙花数是指一个三位数，其各位数字的立方和等于该数本身。
 *			举例：153就是一个水仙花数。
 *			153 = 1*1*1 + 5*5*5 + 3*3*3
 *
 *		A:三位数其实就告诉了我们水仙花数的范围
 *			100-999
 *		B:如何获取一个数据的每一个位上的数呢?
 *			举例：我有一个数据153，请问如何获取到个位，十位，百位
 *			个位：153%10 = 3;
 *			十位：153/10%10 = 5;
 *			百位：153/10/10%10 = 1;
 *			千位：...
 *			万位：...
 *		C:让每个位上的立方和相加，并和该数据进行比较，如果相等，就说明该数据是水仙花数，在控制台输出
 */
public class ForTest4 {
	public static void main(String[] args) {
		//通过循环获取到每一个三位数
		for(int x=100; x<1000; x++) {
			//获取个位，十位，百位
			int ge = x%10;
			int shi = x/10%10;
			int bai = x/10/10%10;
			
			//让每个位上的立方和相加，并和该数据进行比较，如果相等，就说明该数据是水仙花数，在控制台输出
			if((ge*ge*ge+shi*shi*shi+bai*bai*bai) == x) {
				System.out.println(x);
			}
		}
	}
}
package com.itheima_04;
/*
 * 需求：统计”水仙花数”共有多少个
 * 
 * 分析：
 * 		A:定义统计变量，初始化值是0
 * 		B:获取三位数，用for循环实现
 * 		C:获取三位数的个位，十位，百位
 * 		D:判断这个三位数是否是水仙花数，如果是，统计变量++
 * 		E:输出统计结果就可以了
 */
public class ForTest5 {
	public static void main(String[] args) {
		//定义统计变量，初始化值是0
		int count = 0;
		
		//获取三位数，用for循环实现
		for(int x=100; x<1000; x++) {
			//获取三位数的个位，十位，百位
			int ge = x%10;
			int shi = x/10%10;
			int bai = x/10/10%10;
			
			//判断这个三位数是否是水仙花数，如果是，统计变量++
			if((ge*ge*ge+shi*shi*shi+bai*bai*bai) == x) {
				count++;
			}
		}
		
		//输出统计结果就可以了
		System.out.println("水仙花数共有："+count+"个");
	}
}
package com.itheima_05;
/*
 * while循环语句的基本格式：
 * 		while(判断条件语句) {
 * 			循环体语句;
 * 		}
 * 扩展格式：
 * 		初始化语句;
 * 		while(判断条件语句) {
 * 			循环体语句;
 * 			控制条件语句;
 * 		}
 * 
 * 回顾for循环的语句格式：
 * 		for(初始化语句;判断条件语句;控制条件语句) {
 * 			循环体语句;
 * 		}
 */
public class WhileDemo {
	public static void main(String[] args) {
		//输出10次HelloWorld
		/*
		for(int x=1; x<=10; x++) {
			System.out.println("HellloWorld");
		}
		*/
		
		//while循环实现
		int x=1;
		while(x<=10) {
			System.out.println("HellloWorld");
			x++;
		}
	}
}
package com.itheima_05;
/*
 * 求1-100之和。
 * 练习：统计水仙花个数。
 */
public class WhileTest {
	public static void main(String[] args) {
		//回顾for循环实现
		
		/*
		//定义求和变量
		int sum = 0;
		//获取1-100之间的数据
		for(int x=1; x<=100; x++) {
			//累加
			sum += x;
		}
		System.out.println("1-100的和是："+sum);
		*/
		
		//while循环实现
		//定义求和变量
		int sum = 0;
		int x = 1;
		while(x<=100) {
			sum += x;
			x++;
		}
		System.out.println("1-100的和是："+sum);
	}
}
package com.itheima_06;
/*
 * do...while循环的基本格式：
 * 		do {
 * 			循环体语句;
 * 		}while(判断条件语句);
 * 扩展格式：
 * 		初始化语句;
 * 		do {
 * 			循环体语句;
 * 			控制条件语句;
 * 		}while(判断条件语句);
 * 执行流程：
 * 		A:执行初始化语句;
 * 		B:执行循环体语句;
 * 		C:执行控制条件语句;
 * 		D:执行判断条件语句，看是true还是false
 * 			如果是true，回到B继续
 * 			如果是false，就结束
 * 
 * 练习：
 * 		求和案例
 * 		统计水仙花个数
 */
public class DoWhileDemo {
	public static void main(String[] args) {
		//输出10次 HelloWorld
		/*
		for(int x=1; x<=10; x++) {
			System.out.println("HelloWorld");
		}
		*/
		
		//do...while改写
		int x=1;
		do {
			System.out.println("HelloWorld");
			x++;
		}while(x<=10);
	}
}
package com.itheima_06;
/*
 * 三种循环的区别：
 * 		A:do...while至少执行一次循环体
 * 		B:for,while循环先判断条件是否成立，然后决定是否执行循环体
 * 
 * for和while的小区别：
 * 		for循环的初始化变量，在循环结束后，不可以被访问。而while循环的初始化变量，是可以被继续使用的。
 * 		如果初始化变量，后面还要继续访问，就使用while，否则，推荐使用for。
 * 
 * 循环的使用推荐：
 * 		for -- while -- do...while
 */
public class DoWhileDemo2 {
	public static void main(String[] args) {
		/*
		int x = 3;
		while(x<3) {
			System.out.println("我爱林青霞");
			x++;
		}
		System.out.println("--------------");
		int y = 3;
		do {
			System.out.println("我爱林青霞");
			y++;
		}while(y<3);
		*/
		
		
		for(int x=1; x<=10; x++){
			System.out.println("爱生活，爱Java");
		}
		//这里的x无法继续访问
		//System.out.println(x);
		System.out.println("-----------------");
		
		int y = 1;
		while(y<=10) {
			System.out.println("爱生活，爱Java");
			y++;
		}
		System.out.println(y);
	}
}
package com.itheima_07;

/*
 * 按要求分析结果，并验证
 * 
 * break：输出2次
 * continue:输出7次
 */
public class BreakAndContinueDemo {
	public static void main(String[] args) {

		for (int x = 1; x <= 10; x++) {
			if (x % 3 == 0) {
				// 分别写break，continue，说说输出几次
				//break;
				continue;
			}
			System.out.println("我爱林青霞");
		}

	}
}
package com.itheima_07;
/*
 * break:中断的意思
 * 使用场景：
 * 		A:switch语句中
 * 		B:循环中
 * 注意：
 * 		离开使用场景是没有意义的。
 * 作用：
 * 		跳出循环，让循环提前结束
 */
public class BreakDemo {
	public static void main(String[] args) {
		//break;
		
		for(int x=1; x<=10; x++) {
			if(x == 3) {
				break;
			}
			System.out.println("HelloWorld");
		}
	}
}
package com.itheima_07;
/*
 * continue:继续的意思
 * 使用场景：
 * 		循环中
 * 注意：
 * 		离开使用场景是没有意义的
 * 作用：
 * 		结束一次循环，继续下一次的循环
 * 区别：
 * 		break:退出循环
 * 		continue:结束一次循环，继续下一次的循环
 */
public class ContinueDemo {
	public static void main(String[] args) {
		//continue;
		
		for(int x=1; x<=10; x++) {
			if(x == 3) {
				//break;
				continue;
			}
			System.out.println("HelloWorld");
		}
	}
}
package com.itheima_01;
/*
 * 数组：存储同一种数据类型的多个元素的容器。
 * 
 * 定义格式：
 * 		A:数据类型[] 数组名;	(推荐的方式)
 * 		B:数据类型 数组名[];
 * 
 * 		举例:
 * 			int[] arr; 定义了一个int类型的数组,数组名是arr
 * 			int arr[]; 定义了一个int类型的变量,变量名是arr数组
 * 
 * 数组初始化：
 * 		A:所谓的初始化,就是为数组开辟内存空间,并为数组中的每个元素赋予初始值
 * 		B:我们有两种方式可以实现数组的初始化
 * 			a:动态初始化	只给出长度,由系统给出初始化值
 * 			b:静态初始化	给出初始化值,由系统决定长度
 * 
 * 动态初始化：
 * 		数据类型[] 数组名 = new 数据类型[数组长度];
 */
public class ArrayDemo {
	public static void main(String[] args) {
		//数据类型[] 数组名 = new 数据类型[数组长度];
		int[] arr = new int[3];
		/*
		 * 左边：
		 * 		int:说明数组中的元素类型是int类型
		 * 		[]:说明这是一个数组
		 * 		arr:这是数组的名称
		 * 
		 * 右边：
		 * 		new:为数组申请内存分配,开辟空间
		 * 		int:说明数组中的元素类型是int类型
		 * 		[]:说明这是一个数组
		 * 		3:数组的长度,其实就是数组中的元素个数
		 */
		
		//输出数组名
		System.out.println("arr:"+arr); //[I@104c575
		//我们获取数组的地址值是没有意义的,我要的是数组中的元素值,该怎么办呢?
		//不用担心,Java已经帮你想好了这个问题
		//其实数组中的每个元素都是有编号的,编号从0开始,最大的编号是数组的长度-1
		//通过数组名和编号的配合使用我们就可以获取指定编号的元素值
		//这个编号的专业叫法：索引
		//访问格式：数组名[索引]
		System.out.println(arr[0]);
		System.out.println(arr[1]);
		System.out.println(arr[2]);
	}
}
package com.itheima_01;
/*
 * 定义一个数组，输出数组名及元素。然后给数组中的元素赋值，再次输出数组名及元素。
 */
public class ArrayTest {
	public static void main(String[] args) {
		//定义数组
		int[] arr = new int[3];
		
		//输出数组名及元素
		System.out.println(arr);
		System.out.println(arr[0]);
		System.out.println(arr[1]);
		System.out.println(arr[2]);
		
		//给数组中的元素赋值
		arr[0] = 100;
		arr[2] = 200;
		
		//再次输出数组名及元素
		System.out.println(arr);
		System.out.println(arr[0]);
		System.out.println(arr[1]);
		System.out.println(arr[2]);
	}
}
package com.itheima_01;
/*
 * 定义两个数组，分别输出数组名及元素。然后分别给数组中的元素赋值，分别再次输出数组名及元素。
 */
public class ArrayTest2 {
	public static void main(String[] args) {
		//定义两个数组
		int[] arr = new int[2];
		int[] arr2 = new int[3];
		
		//分别输出数组名及元素
		System.out.println(arr);
		System.out.println(arr[0]);
		System.out.println(arr[1]);
		
		System.out.println(arr2);
		System.out.println(arr2[0]);
		System.out.println(arr2[1]);
		System.out.println(arr2[2]);
		System.out.println("--------------------");
		
		//然后分别给数组中的元素赋值
		arr[1] = 100;
		
		arr2[0] = 200;
		arr2[2] = 300;
		
		//分别再次输出数组名及元素。
		System.out.println(arr);
		System.out.println(arr[0]);
		System.out.println(arr[1]);
		
		System.out.println(arr2);
		System.out.println(arr2[0]);
		System.out.println(arr2[1]);
		System.out.println(arr2[2]);
	}
}
package com.itheima_01;
/*
 * 定义两个数组，先定义一个数组，赋值，输出。然后定义第二个数组的时候把第一个数组的地址赋值给第二个数组。
 * 然后给第二个数组赋值，再次输出两个数组的名及元素。
 */
public class ArrayTest3 {
	public static void main(String[] args) {
		//定义一个数组
		int[] arr = new int[3];
		//赋值
		arr[0] = 100;
		arr[1] = 200;
		arr[2] = 300;
		//输出
		System.out.println(arr);
		System.out.println(arr[0]);
		System.out.println(arr[1]);
		System.out.println(arr[2]);
		
		//然后定义第二个数组的时候把第一个数组的地址赋值给第二个数组。
		int[] arr2 = arr;
		//给第二个数组赋值
		arr2[0] = 111;
		arr2[1] = 222;
		arr2[2] = 333;
		
		//再次输出两个数组的名及元素
		System.out.println(arr);
		System.out.println(arr[0]);
		System.out.println(arr[1]);
		System.out.println(arr[2]);
		
		System.out.println(arr2);
		System.out.println(arr2[0]);
		System.out.println(arr2[1]);
		System.out.println(arr2[2]);
	}
}
package com.itheima_02;
/*
 * 静态初始化的格式：
 * 		数据类型[] 数组名 = new 数据类型[]{元素1,元素2,元素3,...};
 * 
 * 		举例：
 * 			int[] arr = new int[]{1,2,3};
 * 
 * 		简化格式：
 * 			数据类型[] 数组名 = {元素1,元素2,元素3,...};
 * 			int[] arr = {1,2,3};
 */
public class ArrayDemo {
	public static void main(String[] args) {
		//定义数组
		int[] arr = {1,2,3};
		
		//输出数组名和元素
		System.out.println(arr);
		System.out.println(arr[0]);
		System.out.println(arr[1]);
		System.out.println(arr[2]);
	}
}
package com.itheima_03;
/*
 * 两个常见小问题：
 * 		ArrayIndexOutOfBoundsException:数组索引越界异常
 * 			产生的原因：我们访问了不存在的索引
 * 
 * 		NullPointerException:空指针异常
 * 			产生的原因：数组已经不在指向堆内存的数据了，你还使用数组名去访问元素
 */
public class ArrayDemo {
		public static void main(String[] args) {
			//定义数组
			int[] arr = {1,2,3};
			
			//访问数组元素
			//System.out.println(arr[3]);
			
			//引用类型：类,接口,数组
			//常量：空常量,null,是可以赋值给引用类型的
			arr = null;
			System.out.println(arr[1]);
		}
}
package com.itheima_04;
/*
 * 数组遍历(依次输出数组中的每一个元素)
 */
public class ArrayTest {
	public static void main(String[] args) {
		//定义一个数组
		int[] arr = {11,22,33,44,55};
		
		//原始做法
		System.out.println(arr[0]);
		System.out.println(arr[1]);
		System.out.println(arr[2]);
		System.out.println(arr[3]);
		System.out.println(arr[4]);
		System.out.println("--------");
		
		//通过for循环实现获取数据0-4
		for(int x=0; x<5; x++) {
			System.out.println(arr[x]);
		}
		System.out.println("--------");
		
		//为了解决我们去数组中数元素的个数，数组就提供了一个属性：length
		//用于获取数组元素个数
		//格式：数组名.length
		System.out.println("数组共有"+arr.length+"个");
		System.out.println("--------");
		
		for(int x=0; x<arr.length; x++) {
			System.out.println(arr[x]);
		}
	}
}
package com.itheima_04;
/*
 * 数组获取最值(获取数组中的最大值最小值)
 */
public class ArrayTest2 {
	public static void main(String[] args) {
		//定义数组
		int[] arr = {12,45,98,73,60};
		
		//定义参照物
		int max = arr[0];
		
		//遍历数组,获取除了0索引以外的元素,进行比较
		for(int x=1; x<arr.length; x++) {
			if(arr[x] > max) {
				max = arr[x];
			}
		}
		
		//输出max即可
		System.out.println("max:"+max);
	}
}
package com.itheima_05;
/*
 * 二维数组：其实就是元素为一维数组的数组。
 * 
 * 定义格式：
 * 		A:数据类型[][] 数组名; (推荐的方式)
 * 		B:数据类型 数组名[][];
 * 		C:数据类型[] 数组名[];
 * 初始化：
 * 		A:动态初始化
 * 			数据类型[][] 数组名 = new 数据类型[m][n];
 * 			m表示的是二维数组中一维数组的个数
 * 			n表示的是一维数组中的元素个数
 * 		B:静态初始化
 * 			数据类型[][] 数组名 = new 数据类型[][]{{元素...},{元素...},{元素...},...};
 * 			简化格式：
 * 			数据类型[][] 数组名 = {{元素...},{元素...},{元素...},...};
 * 
 * 二维数组名配合索引可以获取到每一个一维数组。
 * 每一个一维数组配合索引名可以获取到数组中的元素。
 * 
 * 假如我有一个二维数组：arr。
 * 我要从中获取一维数组：arr[索引]
 * 我要从中获取二维数组的元素：arr[索引][索引]
 */
public class ArrayArrayDemo {
	public static void main(String[] args) {
		//数据类型[][] 数组名 = {{元素...},{元素...},{元素...},...};
		int[][] arr = {{1,2,3},{4,5,6},{7,8,9}};
		
		System.out.println(arr); //[[I@1774b9b
		System.out.println(arr[0]); //[I@104c575
		System.out.println(arr[1]);
		System.out.println(arr[2]);
		
		//如何获取二维数组中的元素呢?
		System.out.println(arr[0][0]);
		System.out.println(arr[1][1]);
		System.out.println(arr[2][2]);
	}
}
package com.itheima_05;
/*
 * 二维数组的遍历
 * 
 * System.out.println():输出内容,并换行
 * System.out.print():输出内容
 */
public class ArrayArrayTest {
	public static void main(String[] args) {
		//定义二维数组
		int[][] arr = {{1,2,3},{4,5,6},{7,8,9}};
		
		//获取二维数组的元素
//		System.out.println(arr[0][0]);
//		System.out.println(arr[0][1]);
//		System.out.println(arr[0][2]);
		
		/*
		//第一个一维数组的元素
		for(int x=0; x<arr[0].length; x++) {
			System.out.println(arr[0][x]);
		}
		System.out.println("-----------");
		
		//第二个一维数组的元素
		for(int x=0; x<arr[1].length; x++) {
			System.out.println(arr[1][x]);
		}
		System.out.println("-----------");
		
		//第三个一维数组的元素
		for(int x=0; x<arr[2].length; x++) {
			System.out.println(arr[2][x]);
		}
		*/
		
		/*
		for(int y=0; y<3; y++) {
			for(int x=0; x<arr[y].length; x++) {
				System.out.println(arr[y][x]);
			}
		}
		*/
		
		//二维数组.length获取的其实就是二维数组中有几个一维数组
		for(int y=0; y<arr.length; y++) {
			for(int x=0; x<arr[y].length; x++) {
				System.out.println(arr[y][x]);
			}
		}
		System.out.println("-----------------");
		
//		System.out.println("hello");
//		System.out.println("world");
//		System.out.print("hello");
//		System.out.print("world");
//		System.out.println();
//		System.out.println("hello");
//		System.out.println("world");
		
		//改进代码
		for(int y=0; y<arr.length; y++) {
			for(int x=0; x<arr[y].length; x++) {
				System.out.print(arr[y][x]+"  ");
			}
			System.out.println(); //添加一个空行
		}
	}
}
package com.itheima;

import java.util.Random;

/*
 * Random:用于产生随机数
 * 
 * 使用步骤：
 * 		A:导包
 * 			import java.util.Random;
 * 		B:创建对象
 * 			Random r = new Random();
 * 		C:获取随机数
 * 			int number = r.nextInt(10);
 * 			获取数据的范围：[0,10) 包括0,不包括10
 */
public class RandomDemo {
	public static void main(String[] args) {
		//创建对象
		Random r = new Random();
		
		for(int x=1; x<=10; x++) {
			//获取随机数
			int number = r.nextInt(10);
			System.out.println("number:"+number);
		}
		System.out.println("------------------");
		
		//如何获取1-100之间的随机数呢?
		//int i = r.nextInt(100); //[0,99]
		int i = r.nextInt(100) + 1;
		System.out.println("i:"+i);
	}
}
package com.itheima;

import java.util.Random;
import java.util.Scanner;

/*
 * 猜数字小游戏案例
 *		系统产生一个1-100之间的随机数，请猜出这个数据是多少。
 *
 * 分析：
 * 		A:系统产生一个1-100之间的随机数
 * 			Random r = new Random();
 * 			int number = r.nextInt(100) + 1;
 * 		B:键盘录入我们要猜的数据
 * 		C:比较这两个数据,用if语句实现
 * 			大了：提示大了
 * 			小了：提示小了
 * 			猜中了：提示恭喜你,猜中了
 * 		D:多次猜数据,而我们不知道猜多少次,怎么办呢?
 * 			while(true) {循环体语句;}
 */
public class RandomTest {
	public static void main(String[] args) {
		//系统产生一个1-100之间的随机数
		Random r = new Random();
		//获取随机数
		int number = r.nextInt(100) + 1;
		
		//多次猜数据
		while(true) {
			//键盘录入我们要猜的数据
			Scanner sc = new Scanner(System.in);
			//接收数据
			System.out.println("请输入你要猜的数据(1-100)：");
			int guessNumber = sc.nextInt();
			
			//比较这两个数据,用if语句实现
			if(guessNumber > number) {
				System.out.println("你猜的数据"+guessNumber+"大了");
			}else if(guessNumber < number) {
				System.out.println("你猜的数据"+guessNumber+"小了");
			}else {
				System.out.println("恭喜你,猜中了");
				break;
			}
		}
	}
}
package com.itheima_01;
/*
 * 方法：其实就是完成特定功能的代码块
 * 
 * 定义格式：
 * 		修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) {
 * 			方法体;
 * 			return 返回值;
 * 		}
 * 格式解释：
 * 		A:修饰符	目前记住public static
 * 		B:返回值类型	用于限定返回值的数据类型
 * 		C:方法名	为了方便我们调用方法的名字
 * 		D:参数类型	用于限定调用方法时传入的数据的类型
 * 		E:参数名	用于接收调用方法时传入的数据的变量
 * 		F:方法体	完成功能的代码
 * 		G:return 结束方法,并且把返回值带给调用者
 * 
 * 写一个方法有两个明确：
 * 		A:返回值类型	明确功能结果的数据类型
 * 		B:参数列表		明确有几个参数，以及参数的数据类型
 * 
 * 案例：
 * 		写一个方法用于求和。
 */
public class MethodDemo {
	public static void main(String[] args) {
		
	}
	
	/*
	 * 两个明确：
	 * 		返回值类型：int
	 * 		参数列表：int a,int b
	 */
	public static int sum(int a,int b) {
		int c = a + b;
		return c;
	}
}
package com.itheima_01;
/*
 * 方法的调用：(有明确返回值的方法调用)
 * 		A:单独调用,没有意义
 * 		B:输出调用,有意义,但是不够好,因为我可能需要拿结果进行进一步的操作
 * 		C:赋值调用,推荐方式
 */
public class MethodDemo2 {
	public static void main(String[] args) {
		//单独调用
		//sum(10,20);
		
		//输出调用
		//System.out.println(sum(10,20));
		
		//赋值调用
		int result = sum(10,20);
		//可以对result进行操作
		//result += 10;
		System.out.println(result);
	}
	
	/*
	 * 求和方法
	 * 
	 * 两个明确：
	 * 		返回值类型：int
	 * 		参数列表：int a,int b
	 */
	public static int sum(int a,int b) {
		int c = a + b;
		return c;
	}
}
package com.itheima_01;

import java.util.Scanner;

/*
 * 键盘录入两个数据，返回两个数中的较大值
 */
public class MethodTest {
	public static void main(String[] args) {
		//创建键盘录入对象
		Scanner sc = new Scanner(System.in);
		
		//接收数据
		System.out.println("请输入第一个数据：");
		int a = sc.nextInt();
		
		System.out.println("请输入第二个数据：");
		int b = sc.nextInt();
		
		//调用方法
		int max = getMax(a,b);
		
		//输出结果
		System.out.println("max:"+max);
	}
	
	/*
	 * 返回两个数中的较大值
	 * 
	 * 两个明确：
	 * 		返回值类型：int
	 * 		参数列表：int a,int b
	 */
	public static int getMax(int a,int b) {
		if(a > b) {
			return a;
		}else {
			return b;
		}
	}
}
package com.itheima_01;

import java.util.Scanner;

/*
 * 键盘录入两个数据，比较两个数是否相等
 */
public class MethodTest2 {
	public static void main(String[] args) {
		//创建键盘录入对象
		Scanner sc = new Scanner(System.in);
		
		//接收数据
		System.out.println("请输入第一个数据：");
		int x = sc.nextInt();
		
		System.out.println("请输入第二个数据：");
		int y = sc.nextInt();
		
		//调用方法
		boolean b = compare(x,y);
		
		//输出结果
		System.out.println("b:"+b);
	}
	
	/*
	 * 比较两个数是否相等
	 * 
	 * 两个明确：
	 * 		返回值类型：boolean
	 * 		参数列表：int a,int b
	 */
	public static boolean compare(int a,int b) {
		if(a == b){
			return true;
		}else {
			return false;
		}
	}
}
package com.itheima_01;

import java.util.Scanner;

/*
 * 键盘录入三个数据，返回三个数中的最大值
 */
public class MethodTest3 {
	public static void main(String[] args) {
		//创建键盘录入对象
		Scanner sc = new Scanner(System.in);
		
		//接收数据
		System.out.println("请输入第一个数据：");
		int a = sc.nextInt();
		
		System.out.println("请输入第二个数据：");
		int b = sc.nextInt();
		
		System.out.println("请输入第三个数据：");
		int c = sc.nextInt();
		
		//调用方法
		int max = getMax(a,b,c);
		
		//输出结果
		System.out.println("max:"+max);
	}
	
	/*
	 * 返回三个数中的最大值
	 * 
	 * 两个明确：
	 * 		返回值类型：int
	 * 		参数列表：int a,int b,int c
	 */
	public static int getMax(int a,int b,int c) {
		if(a > b) {
			if(a > c) {
				return a;
			}else {
				return c;
			}
		}else {
			if(b > c) {
				return b;
			}else {
				return c;
			}
		}
	}
}
package com.itheima_02;
/*
 * 需求：写一个方法，在控制台输出10次HelloWorld案例
 * 
 * 两个明确：
 * 		返回值类型：void
 * 		参数列表：没有参数
 * 
 * 如果一个方法没有明确的返回值类型，也不能把返回值类型的地方空出来，应该写void表示该方法无返回值类型。
 * 
 * 方法调用：(void修饰的方法的调用)
 * 		只能单独调用
 * 
 */
public class MethodDemo {
	public static void main(String[] args) {
		//单独调用
		printHelloWorld();
		
		//输出调用
		//System.out.println(printHelloWorld());
		
		//赋值调用
		//void v = printHelloWorld();
	}
	
	/*
	 * 在控制台输出10次HelloWorld案例
	 * 
	 * 两个明确：
	 * 		返回值类型：void
	 * 		参数列表：
	 */
	public static void printHelloWorld() {
//		for(int x=1; x<=10; x++) {
//			System.out.println("HelloWorld");
//		}
		
		for(int x=0; x<10; x++) {
			System.out.println("HelloWorld");
		}
	}
}
package com.itheima_02;
/*
 * 写一个方法，传递一个整数(大于1)，在控制台打印1到该数据的值
 */
public class MethodTest {
	public static void main(String[] args) {
		//调用方法
		printNumber(3);
		System.out.println("------------");
		printNumber(10);
	}
	
	/*
	 * 写一个方法，传递一个整数(大于1)，在控制台打印1到该数据的值
	 * 
	 * 两个明确：
	 * 		返回值类型：void
	 * 		参数列表：int n
	 */
	public static void printNumber(int n) {
		for(int x=1; x<=n; x++) {
			System.out.println(x);
		}
	}
}
package com.itheima_02;
/*
 * 写一个方法，把所有的水仙花数打印在控制台
 */
public class MethodTest2 {
	public static void main(String[] args) {
		//调用方法
		printFlower();
	}
	
	/*
	 * 写一个方法，把所有的水仙花数打印在控制台
	 * 
	 * 两个明确：
	 * 		返回值类型：void
	 * 		参数列表：无参数
	 */
	public static void printFlower() {
		for(int x=100; x<1000; x++) {
			int ge = x%10;
			int shi = x/10%10;
			int bai = x/10/10%10;
			
			if((ge*ge*ge+shi*shi*shi+bai*bai*bai) == x) {
				System.out.println(x);
			}
		}
	}
}
package com.itheima_03;
/*
 * 方法重载：在同一个类中，出现了方法名相同的情况。
 * 方法重载的特点：
 * 		方法名相同，参数列表不同。与返回值无关。
 * 		参数列表不同：
 * 			参数的个数不同
 * 			参数对应的数据类型不同
 * 
 * 注意：
 * 		在调用方法的时候，java虚拟机会通过参数列表的不同来区分同名的方法。
 */
public class MethodDemo {
	public static void main(String[] args) {
		//定义变量
		int a = 10;
		int b = 20;
		
		//求和方法
		int result = sum(a,b);
		System.out.println("result:"+result);
		
		//定义变量
		int c = 30;
		//求和方法
		//int result2 = sum2(a,b,c);
		int result2 = sum(a,b,c);
		System.out.println("result2:"+result2);
		
	}
	
	//不能出现方法名相同，并且参数列表也相同的情况
//	public static int sum(int x,int y) {
//		return x + y;
//	}
	
	public static float sum(float a,float b) {
		return a + b;
	}
	
	//求三个数据的和
	/*
	public static int sum2(int a,int b,int c) {
		return a + b + c;
	}
	*/
	public static int sum(int a,int b,int c) {
		return a + b + c;
	}
	
	//求两个数据的和方法
	public static int sum(int a,int b) {
		//int c = a + b;
		//return c;
		
		return a + b;
	}
}
package com.itheima_03;
/*
 * 比较两个数据是否相等。参数类型分别为两个byte类型，两个short类型，两个int类型，两个long类型，并在main方法中进行测试
 */
public class MethodTest {
	public static void main(String[] args) {
		//System.out.println(compare(10, 20));
		
		//System.out.println(compare((byte)10, (byte)20));
		
		//System.out.println(compare((short)10, (short)20));
		
		System.out.println(compare(10L, 20L));
	}
	
	//byte
	public static boolean compare(byte a,byte b) {
		System.out.println("byte");
		return a == b;
	}
	
	//short
	public static boolean compare(short a,short b) {
		System.out.println("short");
		return a == b;
	}
	
	//int
	public static boolean compare(int a,int b) {
		System.out.println("int");
		return a == b;
	}
	
	//long
	public static boolean compare(long a,long b) {
		System.out.println("long");
		return a == b;
	}
}
package com.itheima_04;

/*
 * 方法的参数如果是基本数据类型：形式参数的改变不影响实际参数。
 * 
 * 形式参数：用于接收实际参数的变量
 * 实际参数：实际参与运算的变量
 */
public class ArgsDemo {
	public static void main(String[] args) {
		int a = 10;
		int b = 20;
		System.out.println("a:"+a+",b:"+b);//a:10,b:20
		change(a,b);
		System.out.println("a:"+a+",b:"+b);//??? a:10,b:20

	}

	public static void change(int a,int b) {//a=10,b=20
		System.out.println("a:"+a+",b:"+b);//a:10,b:20
		a = b;//a=20
		b = a + b;//b=40
		System.out.println("a:"+a+",b:"+b);//a:20,b:40
	}

}
package com.itheima_04;
/*
 * 如果参数是引用数据类型：
 * 		形式参数的改变直接影响实际参数
 */
public class ArgsDemo2 {
	public static void main(String[] args) {
		int[] arr = {1,2,3,4,5};
		for(int x=0; x<arr.length; x++) {
			System.out.println(arr[x]);
		}
		change(arr);
		for(int x=0; x<arr.length; x++) {
			System.out.println(arr[x]);
		}
	}
	

	public static void change(int[] arr) {
		for(int x=0; x<arr.length; x++)
		{
			if(arr[x]%2==0)
			{
				arr[x]*=2;
			}
		}
	}

}
package com.itheima_05;
/*
 * 把遍历数组改进为方法实现，并调用方法
 */
public class MethodTest {
	public static void main(String[] args) {
		//定义一个数组
		int[] arr = {11,22,33,44,55};
		
		//遍历数组
		/*
		for(int x=0; x<arr.length; x++) {
			System.out.println(arr[x]);
		}
		*/
		
		//用方法改进
		//printArray(arr);
		
		//现在已经可以实现我们的要求了，但是我觉得效果不好看
		//我想要输出的结果是这个样子的：[11, 22, 33, 44, 55]
		printArray(arr);
	}
	
	/*
	 * 两个明确：
	 * 		返回值类型：void
	 * 		参数列表：int[] arr
	 */
	/*
	public static void printArray(int[] arr) {
		for(int x=0; x<arr.length; x++) {
			System.out.println(arr[x]);
		}
	}
	*/
	
	public static void printArray(int[] arr) {
		System.out.print("[");
		for(int x=0; x<arr.length; x++) {
			if(x==arr.length-1) {
				System.out.println(arr[x]+"]");
			}else {
				System.out.print(arr[x]+", ");
			}
		}
	}
}
package com.itheima_05;
/*
 * 把获取数组最值改进为方法实现，并调用方法
 * 
 * 练习：最小值的方法练习。
 */
public class MethodTest2 {
	public static void main(String[] args) {
		//定义数组
		int[] arr = {24,36,90,75,81};
		
		/*
		//定义参照物
		int max = arr[0];
		//遍历数组,获取元素,依次比较
		for(int x=1; x<arr.length; x++) {
			if(arr[x] > max) {
				max = arr[x];
			}
		}
		*/
		//写方法实现获取数组中的最大值
		int max = getMax(arr);
		
		//输出结果
		System.out.println("max:"+max);
	}
	
	/*
	 * 两个明确：
	 * 		返回值类型：int
	 * 		参数列表：int[] arr
	 */
	public static int getMax(int[] arr) {
		//定义参照物
		int max = arr[0];
		//遍历数组,获取元素,依次比较
		for(int x=1; x<arr.length; x++) {
			if(arr[x] > max) {
				max = arr[x];
			}
		}
		return max;
	}
}
package com.itheima_05;
/*
 * 写一个方法，用于对数组进行求和，并调用方法。
 */
public class MethodTest3 {
	public static void main(String[] args) {
		//定义数组
		int[] arr = {1,2,3,4,5};
		
		/*
		//定义求和变量
		int sum = 0;
		//获取数组中的每一个元素
		for(int x=0; x<arr.length; x++) {
			//累加
			sum += arr[x];
		}
		*/
		
		//写方法实现
		int sum = sum(arr);
		
		//输出结果
		System.out.println("sum:"+sum);
		
	}
	
	/*
	 * 两个明确：
	 * 		返回值类型：int
	 * 		参数列表：int[] arr
	 */
	public static int sum(int[] arr) {
		//定义求和变量
		int sum = 0;
		//获取数组中的每一个元素
		for(int x=0; x<arr.length; x++) {
			//累加
			sum += arr[x];
		}
		return sum;
	}
}
package com.itheima;

import java.util.Scanner;

/*
 * 需求：键盘录入一个月份，输出该月份对应的季节。
 * 		一年有四季
 * 		3,4,5	春季
 * 		6,7,8	夏季
 * 		9,10,11	秋季
 * 		12,1,2	冬季
 * 
 * 分析：
 * 		A:键盘录入一个月份,用Scanner实现
 * 		B:判断该月份是几月,根据月份输出对应的季节
 * 			if
 * 			switch
 */
public class Test {
	public static void main(String[] args) {
		//键盘录入一个月份,用Scanner实现
		Scanner sc = new Scanner(System.in);
		
		//接收数据
		System.out.println("请输入月份(1-12)：");
		int month = sc.nextInt();
		
		/*
		if(month>12 || month<1) {
			System.out.println("你输入的月份有误");
		}else if(month == 1) {
			System.out.println("冬季");
		}else if(month == 2) {
			System.out.println("冬季");
		}else if(month == 3) {
			System.out.println("春季");
		}else if(month == 4) {
			System.out.println("春季");
		}else if(month == 5) {
			System.out.println("春季");
		}else if(month == 6) {
			System.out.println("夏季");
		}else if(month == 7) {
			System.out.println("夏季");
		}else if(month == 8) {
			System.out.println("夏季");
		}else if(month == 9) {
			System.out.println("秋季");
		}else if(month == 10) {
			System.out.println("秋季");
		}else if(month == 11) {
			System.out.println("秋季");
		}else {
			System.out.println("冬季");
		}
		*/
		
		//目前我们已经实现了我们的需求
		//但是我觉得代码稍微有些麻烦
		//所以我想改进
		//如何改进呢?能不能把相同季节的月份放到一起判断呢
		//能
		//month == 3 || month == 4 || month == 5
		
		if((month == 1) || (month == 2) || (month == 12)) {
			System.out.println("冬季");
		}else if((month == 3) || (month == 4) || (month == 5)) {
			System.out.println("春季");
		}else if((month == 6) || (month == 7) || (month == 8)) {
			System.out.println("夏季");
		}else if((month == 9) || (month == 10) || (month == 11)) {
			System.out.println("秋季");
		}else {
			System.out.println("你输入的月份有误");
		}
	}
}
package com.itheima;

import java.util.Scanner;

/*
 * 需求：键盘录入一个月份，输出该月份对应的季节。
 * 		一年有四季
 * 		3,4,5	春季
 * 		6,7,8	夏季
 * 		9,10,11	秋季
 * 		12,1,2	冬季
 * 
 * 分析：
 * 		A:键盘录入一个月份,用Scanner实现
 * 		B:判断该月份是几月,根据月份输出对应的季节
 * 			if
 * 			switch
 * 
 * case穿透
 */
public class Test2 {
	public static void main(String[] args) {
		//键盘录入一个月份,用Scanner实现
		Scanner sc = new Scanner(System.in);
		
		//接收数据
		System.out.println("请输入月份(1-12)：");
		int month = sc.nextInt();
		
		/*
		switch(month) {
		case 1:
			System.out.println("冬季");
			break;
		case 2:
			System.out.println("冬季");
			break;
		case 3:
			System.out.println("春季");
			break;
		case 4:
			System.out.println("春季");
			break;
		case 5:
			System.out.println("春季");
			break;
		case 6:
			System.out.println("夏季");
			break;
		case 7:
			System.out.println("夏季");
			break;
		case 8:
			System.out.println("夏季");
			break;
		case 9:
			System.out.println("秋季");
			break;
		case 10:
			System.out.println("秋季");
			break;
		case 11:
			System.out.println("秋季");
			break;
		case 12:
			System.out.println("冬季");
			break;
		default:
			System.out.println("你输入的月份有误");
			break;
		}
		*/
		
		/*
		//case穿透
		switch(month) {
		case 1:
			System.out.println("冬季");
			break;
		case 2:
			System.out.println("冬季");
			//break;
		case 3:
			System.out.println("春季");
			break;
		default:
			System.out.println("你输入的月份有误");
			break;
		}
		*/
		
		switch(month) {
		case 1:
		case 2:
		case 12:
			System.out.println("冬季");
			break;
		case 3:
		case 4:
		case 5:
			System.out.println("春季");
			break;
		case 6:
		case 7:
		case 8:
			System.out.println("夏季");
			break;
		case 9:
		case 10:
		case 11:
			System.out.println("秋季");
			break;
		default:
			System.out.println("你输入的月份有误");
			break;
		}
	}
}
package com.itheima;
/*
 * 需求：打印5位数中的所有回文数。
 * 		什么是回文数呢?举例：12321是回文数，个位与万位相同，十位与千位相同。
 * 
 * 分析：
 * 		A:5位数告诉了我们数据的范围,用for循环实现
 * 		B:拿到每一个5位数后,获取其个位,十位,千位,万位的数据
 * 			如何获取呢?假设x是一个5位数
 * 			个位：x%10
 * 			十位：x/10%10
 * 			千位：x/10/10/10%10
 * 			万位：x/10/10/10/10%10
 * 		C:根据条件进行判断,把满足条件的数据输出即可
 */
public class Test3 {
	public static void main(String[] args) {
		//5位数告诉了我们数据的范围,用for循环实现
		for(int x=10000; x<100000; x++) {
			//拿到每一个5位数后,获取其个位,十位,千位,万位的数据
			int ge = x%10;
			int shi = x/10%10;
			int qian = x/10/10/10%10;
			int wan = x/10/10/10/10%10;
			
			//根据条件进行判断,把满足条件的数据输出即可
			if((ge == wan) && (shi == qian)) {
				System.out.println(x);
			}
		}
	}
}
package com.itheima;

/*
 * 需求：
 * 		有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，
 * 		假如兔子都不死，问第二十个月的兔子对数为多少？ 
 * 
 * 规律：
 * 		第一个月：1
 * 		第二个月：1
 * 		第三个月：2
 * 		第四个月：3
 * 		第五个月：5
 * 		...
 * 
 * 		规律：从第三个月开始，每个月的兔子对数是前两个月的兔子对数之和
 *          第一个月和第二个月的兔子对数都是1
 * 
 * 分析：
 * 		A:由于数据比较多,所以我们就定义数组来实现了
 * 			int[] arr = new int[20];
 * 		B:给数组的元素赋值
 * 			arr[0] = 1
 * 			arr[1] = 2
 * 		C:找规律
 * 			arr[2] = arr[1] + arr[0];
 * 			arr[3] = arr[2] + arr[1];
 * 			arr[4] = arr[3] + arr[2];
 * 			arr[5] = arr[4] + arr[3];
 * 			...	
 */
public class Test4 {
	public static void main(String[] args) {
		//定义数组
		int[] arr = new int[20];
		
		//给数组的元素赋值
		arr[0] = 1;
		arr[1] = 1;
		
		//找规律赋值
		for(int x=2; x<arr.length; x++) {
			arr[x] = arr[x-1] + arr[x-2];
		}
		
		//输出结果
		System.out.println("第二十个月兔子的对数是："+arr[19]);
	}
}
package com.itheima;

/*
 * 需求：
 * (1)定义一个int类型的一维数组，内容为{171,72,19,16,118,51,210,7,18}
 * (2)求出该数组中满足要求的元素和。
 * 		要求：求和的元素的个位和十位不能包含7,并且只能为偶数。
 * 
 * 分析：
 * 		A:定义一个int类型的一维数组
 * 		B:定义一个求和变量
 * 		C:遍历数组,获取数组中的每一个元素
 * 		D:判断该元素是否满足条件，如果满足条件就累加
 * 			假设该数据是x
 * 			个位不能是7：x%10 != 7
 * 			十位不能是7：x/10%10 != 7
 * 			必须是偶数：x%2 == 0
 * 		E:输出求和结果
 */
public class Test5 {
	public static void main(String[] args) {
		//定义一个int类型的一维数组
		int[] arr = {171,72,19,16,118,51,210,7,18};
		
		//定义一个求和变量
		int sum = 0;
		
		//遍历数组,获取数组中的每一个元素
		for(int x=0; x<arr.length; x++) {
			//判断该元素是否满足条件，如果满足条件就累加
			if((arr[x]%10 != 7) && (arr[x]/10%10 != 7) && (arr[x]%2 == 0)) {
				sum += arr[x];
			}
		}
		
		//输出求和结果
		System.out.println("sum:"+sum);
	}
}
package com.itheima;

import java.util.Scanner;

/*
 * 需求：在编程竞赛中，有6个评委为参赛的选手打分，分数为0-100的整数分。
 * 选手的最后得分为：去掉一个最高分和一个最低分后 的4个评委平均值。
 * 请写代码实现。(不考虑小数部分)
 * 
 * 分析：
 * 		A:定义一个长度为6的数组
 * 		B:键盘录入评委的分数
 * 		C:写方法实现获取最高分,最低分
 * 		D:写方法求评委的分数和
 * 		E:平均分：(和-最高分-最低分)/(arr.length-2)
 * 		F:输出平均分即可
 */
public class Test6 {
	public static void main(String[] args) {
		//定义一个长度为6的数组
		int[] arr = new int[6];
		
		//创建键盘录入对象
		Scanner sc = new Scanner(System.in);
		
		//键盘录入评委的分数
		for(int x=0; x<arr.length; x++) {
			//接收数据
			System.out.println("请输入第"+(x+1)+"个评委给出的分数(0-100)：");
			int score = sc.nextInt();
			arr[x] = score;
		}
		
		//写方法实现获取最高分,最低分
		//调用方法
		int max = getMax(arr);
		int min = getMin(arr);
		
		//写方法求评委的分数和
		int sum = sum(arr);
		
		//平均分：(和-最高分-最低分)/(arr.length-2)
		int avg = (sum-max-min)/(arr.length-2);
		
		//输出平均分即可
		System.out.println("该选手的最终得分是："+avg);
	}
	
	/*
	 * 两个明确：
	 * 		返回值类型：int
	 * 		参数列表：int[] arr
	 */
	public static int sum(int[] arr) {
		//定义求和变量
		int sum = 0;
		
		for(int x=0; x<arr.length; x++) {
			sum += arr[x];
		}
		
		return sum;
	}
	
	/*
	 * 两个明确：
	 * 		返回值类型：int
	 * 		参数列表：int[] arr
	 */
	public static int getMin(int[] arr) {
		//定义参照物
		int min = arr[0];
		
		for(int x=1; x<arr.length; x++) {
			if(arr[x] < min) {
				min = arr[x];
			}
		}
		
		return min;
	}
	
	/*
	 * 两个明确：
	 * 		返回值类型：int
	 * 		参数列表：int[] arr
	 */
	public static int getMax(int[] arr) {
		//定义参照物
		int max = arr[0];
		
		for(int x=1; x<arr.length; x++) {
			if(arr[x] > max) {
				max = arr[x];
			}
		}
		
		return max;
	}
}
package com.itheima;

import java.util.Scanner;

/*
 * 需求：
 * (1)键盘录入5个int类型的数据存储数组arr中
 * (2)定义方法将arr数组中的内容反转
 * (3)定义方法对反转后的数组进行遍历
 * 
 * 分析：
 * 		A:定义一个长度为5的数组
 * 		B:通过键盘录入数据给数组中的元素赋值
 * 		C:定义方法将arr数组中的内容反转
 * 			什么是反转?如何实现反转
 * 		D:定义方法对反转后的数组进行遍历
 */
public class Test7 {
	public static void main(String[] args) {
		//定义一个长度为5的数组
		int[] arr = new int[5];
		
		//通过键盘录入数据给数组中的元素赋值
		Scanner sc = new Scanner(System.in);
		for(int x=0; x<arr.length; x++) {
			System.out.println("请输入"+(x+1)+"个元素值：");
			int number = sc.nextInt();
			arr[x] = number;
		}
		
		//反转前
		printArray(arr);
		
		//定义方法将arr数组中的内容反转
		reverse(arr);
		
		//定义方法对反转后的数组进行遍历
		printArray(arr);
	}
	
	//遍历数组
	public static void printArray(int[] arr) {
		System.out.print("[");
		for(int x=0; x<arr.length; x++) {
			if(x==arr.length-1) {
				System.out.println(arr[x]+"]");
			}else {
				System.out.print(arr[x]+", ");
			}
		}
	}
	
	/*
	 * 两个明确：
	 * 		返回值类型：void
	 * 		参数列表：int[] arr
	 */
	public static void reverse(int[] arr) {
		for(int start=0,end=arr.length-1; start<=end; start++,end--) {
			int temp = arr[start];
			arr[start] = arr[end];
			arr[end] = temp;
		}
	}
	
}
package com.itheima;

import java.util.Scanner;

/*
 *需求：数组元素查找(查找指定元素第一次在数组中出现的索引)
 *(1)给定数组int[] arr = {5,7,3,2,5};
 *(2)要查询的元素通过键盘录入的方式确定
 *(3)定义一个查找数组元素第一次出现位置的方法(注,要查找的元素就是键盘录入的数据)
 *
 *分析：
 *		A:定义数组int[] arr = {5,7,3,2,5};
 *		B:键盘录入一个被查询的数据
 *		C:写方法实现查找指定元素在数组中第一次出现的索引
 *			遍历数组，依次比较元素，如果相等，就把该处的索引返回即可
 *		D:调用方法,输出结果
 */
public class Test8 {
	public static void main(String[] args) {
		//定义数组int[] arr = {5,7,3,2,5};
		int[] arr = {5,7,3,2,5};
		
		//键盘录入一个被查询的数据
		Scanner sc = new Scanner(System.in);
		
		System.out.println("请输入被查询的数据：");
		int number = sc.nextInt();
		
		//写方法实现查找指定元素在数组中第一次出现的索引
		
		//调用方法,输出结果
		int index = getIndex(arr, number);
		System.out.println("index:"+index);
	}
	
	/*
	 * 两个明确：
	 * 		返回值类型：int
	 * 		参数列表：int[] arr,int value
	 */
	public static int getIndex(int[] arr,int value) {
		//遍历数组，依次比较元素，如果相等，就把该处的索引返回即可
		for(int x=0; x<arr.length; x++) {
			if(arr[x] == value) {
				return x;
			}
		}
		return -1;
	}
}
package com.itheima;

import java.util.Scanner;

/*
 * 需求：键盘录入数据,要求数据是四位的整数,现需要对数据进行加密,加密规则如下:
 * 每位数字都加上5,然后除以10的余数代替该数字,
 * 再将第一位和第四位交换,第二位和第三位交换,
 * 请把加密后的数据输出到控制台
 * 
 * 分析：
 * 		A:键盘录入一个4位数
 * 			举例：4567
 * 		B:定义一个长度为4的数组
 * 			int[] arr = new int[4];
 * 			arr = {4,5,6,7};
 * 		C:对数组中的数据进行加密规则的操作
 * 			每位数字都加上5,然后除以10的余数代替该数字
 * 				arr[x] += 5;
 * 				结果：arr = {9,10,11,12};
 * 				arr[x] %= 10;
 * 				结果：arr = {9,0,1,2};
 * 			再将第一位和第四位交换,第二位和第三位交换
 * 				结果：arr = {2,1,0,9};
 *		D:请把加密后的数据输出到控制台
 */
public class Test9 {
	public static void main(String[] args) {
		//键盘录入一个4位数
		Scanner sc = new Scanner(System.in);
		//接收数据
		System.out.println("请输入一个4位数：");
		int number = sc.nextInt();
		
		//定义一个长度为4的数组
		int[] arr = new int[4];
		arr[0] = number/10/10/10%10;
		arr[1] = number/10/10%10;
		arr[2] = number/10%10;
		arr[3] = number%10;
		
		//对数组中的数据进行加密规则的操作
		//每位数字都加上5,然后除以10的余数代替该数字
		for(int x=0; x<arr.length; x++) {
			arr[x] += 5;
			arr[x] %= 10;
		}
		
		//再将第一位和第四位交换,第二位和第三位交换
		int temp = arr[0];
		arr[0] = arr[3];
		arr[3] = temp;
		
		temp = arr[1];
		arr[1] = arr[2];
		arr[2] = temp;
		
		//请把加密后的数据输出到控制台
		for(int x=0; x<arr.length; x++) {
			System.out.print(arr[x]);
		}
		System.out.println();
	}
}
package com.itheima_01;
/*
 * 面向对象思想：
 * 		面向对象是基于面向过程的编程思想。
 * 
 * 		面向过程：强调的是每一个功能的步骤
 * 		面向对象：强调的是对象，然后由对象去调用功能
 * 
 * 面向对象的思想特点：
 * 		A:是一种更符合我们思考习惯的思想
 * 		B:可以将复杂的事情简单化
 * 		C:将我们从执行者变成了指挥者
 * 
 * 举例：
 * 		买电脑：
 * 			面向过程：我要买电脑--我要明确买电脑的意义--上网查对应的参数信息--去中关村买电脑--讨价还价--买回电脑
 * 			面向对象：我要买电脑--班长去给我买电脑--买回电脑
 * 		洗衣服：
 * 			面向过程：把衣服脱下来--找一个盆--放点洗衣粉--加点水--浸泡10分钟--揉一揉--清洗衣服--拧干--晾起来
 * 			面向对象：把衣服脱下来--打开全自动洗衣机--扔衣服--按钮--晾起来
 */
public class Demo {

}
package com.itheima_01;
/*
 * 我们学习编程语言，其实就是为了把现实世界的事物模拟出来，实现信息化。
 * 
 * 我们是如何表示现实世界的事物的呢?
 * 		A:属性	就是事物的描述信息
 * 		B:行为	就是事物能够做什么
 * 		举例：学生
 * 
 * Java语言最基本的单位是类，所以，我们在后面的学习过程中，是通过类来体现现实世界事物的。
 * 
 * 类：是一组相关的属性和行为的集合
 * 对象：就是该事物的具体体现
 * 		举例：
 * 			类		学生
 * 			对象		班长
 */
public class Demo2 {

}
package com.itheima_02;
/*
 * 手机类：
 * 		成员变量：品牌，价格，颜色...
 * 		成员方法：打电话，发短信...
 */
public class Phone {
	//品牌
	String brand;
	//价格
	int price;
	//颜色
	String color;
	
	//打电话
	public void call(String name) {
		System.out.println("给"+name+"打电话");
	}
	
	//发短信
	public void sendMessage() {
		System.out.println("群发短信");
	}
}
package com.itheima_02;
/*
 * 手机类的测试类
 */
public class PhoneDemo {
	public static void main(String[] args) {
		//创建对象
		Phone p = new Phone();
		
		//输出成员变量值
		System.out.println("品牌："+p.brand);//null
		System.out.println("价格："+p.price);//0
		System.out.println("颜色："+p.color);//null
		System.out.println("------------");
		
		//给成员变量赋值
		p.brand = "锤子";
		p.price = 2999;
		p.color = "棕色";
		
		//再次输出成员变量值
		System.out.println("品牌："+p.brand);//锤子
		System.out.println("价格："+p.price);//2999
		System.out.println("颜色："+p.color);//棕色
		System.out.println("------------");
		
		//调用成员方法
		p.call("林青霞");
		p.sendMessage();
	}
}
package com.itheima_02;
/*
 * 类的定义：
 * 		类是用来描述现实世界的事物的
 * 
 * 事物：
 * 		属性	事物的描述信息
 * 		行为	事物能够做什么
 * 
 * 类是如何和事物进行对应的呢?
 * 		类：
 * 			成员变量
 * 			成员方法
 * 
 * 需求：写一个学生类
 * 
 * 学生事物：
 * 		属性：姓名，年龄...
 * 		行为：学习，吃饭...
 * 
 * 学生类：
 * 		成员变量：姓名,年龄
 * 		成员方法：学习,吃饭
 *
 * 成员变量：和我们前面学习过的变量的定义是一样的。
 * 		位置不同：类中，方法外
 * 		初始化值：不需要给初始化值
 * 成员方法：和我们前面学习过的方法的定义是一样的。
 * 		去掉static关键字
 */
public class Student {
	//成员变量
	//姓名
	String name;
	//年龄
	int age;
	
	//成员方法
	//学习的方法
	public void study() {
		System.out.println("好好学习，天天向上");
	}
	
	//吃饭的方法
	public void eat() {
		System.out.println("学习饿了要吃饭");
	}
}
package com.itheima_02;
/*
 * Student是一个学生事物描述类，main方法不适合放在它里面。
 * 
 * 使用一个类，其实就是使用该类的成员。(成员变量和成员方法)
 * 而我们要想使用一个类的成员，就必须首先拥有该类的对象。
 * 我们如何拥有一个类的对象呢?
 * 		创建对象就可以了?
 * 我们如何创建对象呢?
 * 		格式：类名 对象名 = new 类名();
 * 对象如何访问成员呢?
 * 		成员变量：对象名.变量名
 * 		成员方法：对象名.方法名(...)
 */
public class StudentDemo {
	public static void main(String[] args) {
		//格式：类名 对象名 = new 类名();
		Student s = new Student();
		//System.out.println("s:"+s); //com.itheima_02.Student@193c0cf
		
		//直接输出成员变量值
		System.out.println("姓名："+s.name); //null
		System.out.println("年龄："+s.age); //0
		System.out.println("----------");
		
		//给成员变量赋值
		s.name = "林青霞";
		s.age = 28;
		
		//再次输出成员变量的值
		System.out.println("姓名："+s.name); //林青霞
		System.out.println("年龄："+s.age); //28
		System.out.println("----------");
		
		//调用成员方法
		s.study();
		s.eat();
	}
}
package com.itheima_03;
/*
 * 手机类
 */
public class Phone {
	String brand;
	int price;
	String color;
	
	public void call(String name) {
		System.out.println("给"+name+"打电话");
	}
	
	public void sendMessage() {
		System.out.println("群发短信");
	}
}
package com.itheima_03;

/*
 * 手机类的测试类
 */
public class PhoneDemo {
	public static void main(String[] args) {
		Phone p = new Phone();

		System.out.println(p.brand + "---" + p.price + "---" + p.color);
		
		p.brand = "锤子";
		p.price = 2999;
		p.color = "棕色";
		
		System.out.println(p.brand + "---" + p.price + "---" + p.color);
		
		p.call("林青霞");
		p.sendMessage();
	}
}
package com.itheima_03;
/*
 * 手机类的测试类
 */
public class PhoneDemo2 {
	public static void main(String[] args) {
		Phone p = new Phone();
		p.brand = "小米5s";
		p.price = 1999;
		p.color = "银色";
		System.out.println(p.brand+"---"+p.price+"---"+p.color);
		p.call("林青霞");
		p.sendMessage();
		
		Phone p2 = new Phone();
		p2.brand = "IPhone7S";
		p2.price = 7999;
		p2.color = "土豪金";
		System.out.println(p2.brand+"---"+p2.price+"---"+p2.color);
		p2.call("张曼玉");
		p2.sendMessage();
	}
}
package com.itheima_03;
/*
 * 手机类的测试类
 */
public class PhoneDemo3 {
	public static void main(String[] args) {
		Phone p = new Phone();
		p.brand = "OPPO";
		p.price = 2999;
		p.color = "白色";
		System.out.println(p.brand+"---"+p.price+"---"+p.color);
		
		Phone p2 = p;
		p2.brand = "魅族";
		p2.price = 1999;
		p2.color = "蓝色";
		System.out.println(p.brand+"---"+p.price+"---"+p.color);
		System.out.println(p2.brand+"---"+p2.price+"---"+p2.color);
	}
}
package com.itheima_04;
/*
 * 成员变量和局部变量的区别：
 * 		A:在类中的位置不同
 * 			成员变量：类中，方法外
 * 			局部变量：方法中或者方法声明上(形式参数)
 * 		B:在内存中的位置不同
 * 			成员变量：堆内存
 * 			局部变量：栈内存
 * 		C:生命周期不同
 * 			成员变量：随着对象的创建而存在，随着对象的消失而消失
 * 			局部变量：随着方法的调用而存在，随着方法的调用完毕而消失
 * 		D:初始化值的问题
 * 			成员变量：有默认值
 * 			局部变量：没有默认值。必须先定义，赋值，最后使用
 */
public class Variable {
	int x;
	
	public void show() {
		int y = 0;
		
		System.out.println(x);
		System.out.println(y);
	}
}
package com.itheima_05;
/*
 * 学生类
 * 
 * 通过对象直接访问成员变量，会存在数据安全问题
 * 这个时候，我们就想能不能不让外界的对象直接访问成员变量呢?
 * 能。
 * 如何实现呢?
 * 		private关键字
 * 
 * private:
 * 		是一个修饰符
 * 		可以修饰成员变量，也可以修饰成员方法
 * 		被private修饰的成员只能在本类中被访问
 * 
 * 针对private修饰的成员变量，我们会相应的提供getXxx()和setXxx()用于获取和设置成员变量的值,方法用public修饰
 */
public class Student {
	String name;
	//int age;
	private int age;
	
	public void setAge(int a) {
		if(a<0 || a>200) {
			System.out.println("你给的年龄有误");
		}else {
			age = a;
		}
	}
	
	public int getAge() {
		return age;
	}
	
	public void show() {
		System.out.println("姓名是："+name+",年龄是："+age);
	}
}
package com.itheima_05;
/*
 * 学生类的测试类
 */
public class StudentDemo {
	public static void main(String[] args) {
		//创建学生对象
		Student s = new Student();
		s.show();
		
		s.name = "林青霞";
		//s.age = 28;
		//s.age = -28;
		//s.setAge(-28);
		s.setAge(28);
		s.show();
	}
}
package com.itheima_06;
/*
 * 学生类
 */
public class Student {
	private String name;
	private int age;
	
	public void setName(String n) {
		name = n;
	}
	
	public String getName() {
		return name;
	}
	
	public void setAge(int a) {
		age = a;
	}
	
	public int getAge() {
		return age;
	}
}
package com.itheima_06;
/*
 * 学生类的测试类
 */
public class StudentDemo {
	public static void main(String[] args) {
		//创建对象
		Student s = new Student();
		System.out.println(s.getName()+"---"+s.getAge());
		
		s.setName("林青霞");
		s.setAge(28);
		System.out.println(s.getName()+"---"+s.getAge());
	}
}
package com.itheima_07;
/*
 * 学生类
 * 
 * 起名字我们要求做到见名知意。
 * 而我们现在的代码中的n和a就没有做到见名知意，所以我要改进。
 * 
 * 如果有局部变量名和成员变量名相同，在局部使用的时候，采用的是就近的原则。
 * 
 * 我们有没有办法把局部变量的name赋值给成员变量的name呢?
 * 有。
 * 
 * 什么办法呢?
 * 		用this关键字就可以解决这个问题
 * 
 * this:代表所在类的对象引用
 * 		方法被哪个对象调用，this就代表那个对象
 * 
 * 使用场景：
 * 		局部变量隐藏成员变量
 */
public class Student {
	private String name;
	private int age;
	
	public void setName(String name) { //"林青霞"
		//name = name;
		this.name = name;
	}
	
	public String getName() {
		return name;
	}
	
	public void setAge(int age) {
		//age = age;
		this.age = age;
	}
	
	public int getAge() {
		return age;
	}
}
package com.itheima_07;
/*
 * 学生类的测试类
 */
public class StudentDemo {
	public static void main(String[] args) {
		//创建对象
		Student s = new Student();
		System.out.println(s.getName()+"---"+s.getAge());
		
		s.setName("林青霞");
		s.setAge(28);
		System.out.println(s.getName()+"---"+s.getAge());
	}
}
package com.itheima_08;
/*
 * 构造方法：
 * 		给对象的数据进行初始化
 * 
 * 格式：
 * 		方法名和类名相同
 * 		没有返回值类型，连void都不能写
 * 		没有具体的返回值
 * 
 * 构造方法的注意事项：
 * 		A:如果我们没有给出构造方法，系统将会提供一个默认的无参构造方法供我们使用。
 * 		B:如果我们给出了构造方法，系统将不在提供默认的无参构造方法供我们使用。
 *        这个时候，如果我们想使用无参构造方法，就必须自己提供。
 *        推荐：自己给无参构造方法
 *      C:构造方法也是可以重载的
 * 
 * 成员变量赋值：
 * 		A:setXxx()方法
 * 		B:带参构造方法	
 */
public class Student {
	private String name;
	private int age;
	
	/*
	public Student() {
		System.out.println("这是构造方法");
	}
	*/
	
	public Student() {}
	
	public Student(String name) {
		this.name = name;
	}
	
	public Student(int age) {
		this.age = age;
	}
	
	public Student(String name,int age) {
		this.name = name;
		this.age = age;
	}

	public void show() {
		System.out.println(name+"---"+age);
	}
}
package com.itheima_08;

public class StudentDemo {
	public static void main(String[] args) {
		//如何调用构造方法呢?
		//通过new关键字调用
		//格式：类名 对象名 = new 构造方法(...);
		Student s = new Student();
		s.show();
		
		//public Student(String name)
		Student s2 = new Student("林青霞");
		s2.show();
		
		//public Student(int age)
		Student s3 = new Student(28);
		s3.show();
		
		//public Student(String name,int age)
		Student s4 = new Student("林青霞",28);
		s4.show();
	}
}
package com.itheima_09;
/*
 * 学生类
 */
public class Student {
	//成员变量
	private String name;
	private int age;
	
	//构造方法
	public Student() {}
	
	public Student(String name,int age) {
		this.name = name;
		this.age = age;
	}
	
	//成员方法
	public void setName(String name) {
		this.name = name;
	}
	
	public String getName() {
		return name;
	}
	
	public void setAge(int age) {
		this.age = age;
	}
	
	public int getAge() {
		return age;
	}
}
package com.itheima_09;
/*
 * 学生类的测试类
 */
public class StudentDemo {
	public static void main(String[] args) {
		//无参+setXxx()
		Student s = new  Student();
		s.setName("林青霞");
		s.setAge(28);
		System.out.println(s.getName()+"---"+s.getAge());
		
		//带参构造
		Student s2 = new Student("林青霞",28);
		System.out.println(s2.getName()+"---"+s2.getAge());
	}
}
package com.itheima_10;

public class Student {
	public void study() {
		System.out.println("好好学习,天天向上");
	}
}
package com.itheima_10;

public class Teacher {
	public void test(Student s) {
		s.study();
	}
}
package com.itheima_10;

//需求： 调用Teacher的test方法

//类名作为形式参数：其实这里需要的是该类对象。
public class Test {
	public static void main(String[] args) {
		Teacher t = new Teacher();
		Student s = new Student();
		t.test(s);
	}
}
package com.itheima_11;

public class Student {
	public void study() {
		System.out.println("好好学习,天天向上");
	}
}
package com.itheima_11;

public class Teacher {
	
	public Student getStudent() {
		Student s = new Student();
		return s;
	}
}
package com.itheima_11;

//需求： 通过Teacher得到Student对象，然后调用Student类的方法
//如果方法的返回值是类名：其实返回的是该类的对象
public class Test {
	public static void main(String[] args) {
		Teacher t = new Teacher();
		Student s = t.getStudent();
		s.study();
	}
}
package com.itheima_01;

import java.util.Scanner;

/*
 * Scanner:用于获取键盘录入的数据。(基本数据类型，字符串数据)
 * 		public String nextLine():获取键盘录入的字符串数据
 */
public class ScannerDemo {
	public static void main(String[] args) {
		//创建键盘录入对象
		Scanner sc = new Scanner(System.in);
		
		//接收数据
		System.out.println("请输入一个字符串数据：");
		String s = sc.nextLine();
		
		//输出结果
		System.out.println("s:"+s);
	}
}
package com.itheima_02;
/*
 * String:字符串类
 * 		由多个字符组成的一串数据
 * 		字符串其本质是一个字符数组
 * 
 * 构造方法：
 * 		String(String original):把字符串数据封装成字符串对象
 * 		String(char[] value):把字符数组的数据封装成字符串对象
 * 		String(char[] value, int index, int count):把字符数组中的一部分数据封装成字符串对象
 * 
 * 注意：字符串是一种比较特殊的引用数据类型，直接输出字符串对象输出的是该对象中的数据。
 */
public class StringDemo {
	public static void main(String[] args) {
		//方式1
		//String(String original):把字符串数据封装成字符串对象
		String s1 = new String("hello");
		System.out.println("s1:"+s1);
		System.out.println("---------");
		
		//方式2
		//String(char[] value):把字符数组的数据封装成字符串对象
		char[] chs = {'h','e','l','l','o'};
		String s2 = new String(chs);
		System.out.println("s2:"+s2);
		System.out.println("---------");
		
		//方式3
		//String(char[] value, int index, int count):把字符数组中的一部分数据封装成字符串对象
		//String s3 = new String(chs,0,chs.length);
		String s3 = new String(chs,1,3);
		System.out.println("s3:"+s3);
		System.out.println("---------");
		
		//方式4
		String s4 = "hello";
		System.out.println("s4:"+s4);
	}
}
package com.itheima_02;
/*
 * 通过构造方法创建的字符串对象和直接赋值方式创建的字符串对象有什么区别呢?
 * 		通过构造方法创建字符串对象是在堆内存。
 * 		直接赋值方式创建对象是在方法区的常量池。
 * 		
 * ==:
 * 		基本数据类型：比较的是基本数据类型的值是否相同
 * 		引用数据类型：比较的是引用数据类型的地址值是否相同
 */
public class StringDemo2 {
	public static void main(String[] args) {
		String s1 = new String("hello");
		String s2 = "hello";
		
		System.out.println("s1:"+s1);
		System.out.println("s2:"+s2);
		
		System.out.println("s1==s2:"+(s1==s2)); //false
		
		String s3 = "hello";
		System.out.println("s1==s3:"+(s1==s3)); //false
		System.out.println("s2==s3:"+(s2==s3)); //true
	}
}
package com.itheima_03;
/*
 * Object:是类层次结构中的根类，所有的类都直接或者间接的继承自该类。
 * 如果一个方法的形式参数是Object，那么这里我们就可以传递它的任意的子类对象。
 * 
 * String类的判断功能：
 * boolean equals(Object obj):比较字符串的内容是否相同
 * boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写
 * boolean startsWith(String str):判断字符串对象是否以指定的str开头
 * boolean endsWith(String str):判断字符串对象是否以指定的str结尾
 */
public class StringDemo {
	public static void main(String[] args) {
		//创建字符串对象
		String s1 = "hello";
		String s2 = "hello";
		String s3 = "Hello";
		
		//boolean equals(Object obj):比较字符串的内容是否相同
		System.out.println(s1.equals(s2));
		System.out.println(s1.equals(s3));
		System.out.println("-----------");
		
		//boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写
		System.out.println(s1.equalsIgnoreCase(s2));
		System.out.println(s1.equalsIgnoreCase(s3));
		System.out.println("-----------");
		
		//boolean startsWith(String str):判断字符串对象是否以指定的str开头
		System.out.println(s1.startsWith("he"));
		System.out.println(s1.startsWith("ll"));
	}
}
package com.itheima_03;

import java.util.Scanner;

/*
 * 模拟登录,给三次机会,并提示还有几次。
 * 
 * 分析：
 * 		A:定义两个字符串对象，用于存储已经存在的用户名和密码
 * 		B:键盘录入用户名和密码
 * 		C:拿键盘录入的用户名和密码和已经存在的用户名和密码进行比较
 * 			如果内容相同，提示登录成功
 * 			如果内容不同，提示登录失败，并提示还有几次机会
 */
public class StringTest {
	public static void main(String[] args) {
		//定义两个字符串对象，用于存储已经存在的用户名和密码
		String username = "admin";
		String password = "admin";
		
		//给三次机会，用for循环实现
		for(int x=0; x<3; x++) {
			//键盘录入用户名和密码
			Scanner sc = new Scanner(System.in);
			System.out.println("请输入用户名：");
			String name = sc.nextLine();
			System.out.println("请输入密码：");
			String pwd = sc.nextLine();
			
			//拿键盘录入的用户名和密码和已经存在的用户名和密码进行比较
			if(username.equals(name) && password.equals(pwd)) {
				System.out.println("登录成功");
				break;
			}else {
				if((2-x) ==0) {
					System.out.println("用户名和密码被锁定,请与管理员联系");
				}else {
					System.out.println("登录失败,你还有"+(2-x)+"次机会"); //2,1,0
				}
			}
		}
	}
}
package com.itheima_04;
/*
 * String类的获取功能：
 * int length():获取字符串的长度，其实也就是字符个数
 * char charAt(int index):获取指定索引处的字符
 * int indexOf(String str):获取str在字符串对象中第一次出现的索引
 * String substring(int start):从start开始截取字符串
 * String substring(int start,int end):从start开始，到end结束截取字符串。包括start，不包括end
 */
public class StringDemo {
	public static void main(String[] args) {
		//创建字符串对象
		String s = "helloworld";
		
		//int length():获取字符串的长度，其实也就是字符个数
		System.out.println(s.length());
		System.out.println("--------");
		
		//char charAt(int index):获取指定索引处的字符
		System.out.println(s.charAt(0));
		System.out.println(s.charAt(1));
		System.out.println("--------");
		
		//int indexOf(String str):获取str在字符串对象中第一次出现的索引
		System.out.println(s.indexOf("l"));
		System.out.println(s.indexOf("owo"));
		System.out.println(s.indexOf("ak"));
		System.out.println("--------");
		
		//String substring(int start):从start开始截取字符串
		System.out.println(s.substring(0));
		System.out.println(s.substring(5));
		System.out.println("--------");
		
		//String substring(int start,int end):从start开始，到end结束截取字符串
		System.out.println(s.substring(0, s.length()));
		System.out.println(s.substring(3,8));
	}
}
package com.itheima_04;
/*
 * 遍历字符串(获取字符串中的每一个字符)
 */
public class StringTest {
	public static void main(String[] args) {
		//创建一个字符串对象
		String s = "abcde";
		
		//原始做法
		System.out.println(s.charAt(0));
		System.out.println(s.charAt(1));
		System.out.println(s.charAt(2));
		System.out.println(s.charAt(3));
		System.out.println(s.charAt(4));
		System.out.println("---------");
		
		//用for循环改进
		for(int x=0; x<5; x++) {
			System.out.println(s.charAt(x));
		}
		System.out.println("---------");
		
		//用length()方法获取字符串的长度
		for(int x=0; x<s.length(); x++) {
			System.out.println(s.charAt(x));
		}
	}
}
package com.itheima_04;

import java.util.Scanner;

/*
 * 统计一个字符串中大写字母字符，小写字母字符，数字字符出现的次数。(不考虑其他字符)
 * 
 * 分析：
 * 		A:键盘录入一个字符串数据
 * 		B:定义三个统计变量，初始化值都是0
 * 		C:遍历字符串，得到每一个字符
 * 		D:拿字符进行判断
 * 			假如ch是一个字符。
 * 			大写：ch>='A' && ch<='Z'
 * 			小写：ch>='a' && ch<='z'
 * 			数字：ch>='0' && ch<='9'
 * 		E:输出结果
 */
public class StringTest2 {
	public static void main(String[] args) {
		//键盘录入一个字符串数据
		Scanner sc = new Scanner(System.in);
		System.out.println("请输入一个字符串数据：");
		String s = sc.nextLine();
		
		//定义三个统计变量，初始化值都是0
		int bigCount = 0;
		int smallCount = 0;
		int numberCount = 0;
		
		//遍历字符串，得到每一个字符
		for(int x=0; x<s.length(); x++) {
			char ch = s.charAt(x);
			//拿字符进行判断
			if(ch>='A' && ch<='Z') {
				bigCount++;
			}else if(ch>='a' && ch<='z') {
				smallCount++;
			}else if(ch>='0' && ch<='9') {
				numberCount++;
			}else {
				System.out.println("该字符"+ch+"非法");
			}
		}
		
		//输出结果
		System.out.println("大写字符："+bigCount+"个");
		System.out.println("小写字符："+smallCount+"个");
		System.out.println("数字字符："+numberCount+"个");
	}
}
package com.itheima_05;
/*
 * String类的转换功能：
 * char[] toCharArray():把字符串转换为字符数组
 * String toLowerCase():把字符串转换为小写字符串
 * String toUpperCase():把字符串转换为大写字符串
 * 
 * 字符串的遍历：
 * 		A:length()加上charAt()
 * 		B:把字符串转换为字符数组，然后遍历数组
 */
public class StringDemo {
	public static void main(String[] args) {
		//创建字符串对象
		String s = "abcde";
		
		//char[] toCharArray():把字符串转换为字符数组
		char[] chs = s.toCharArray();
		for(int x=0; x<chs.length; x++) {
			System.out.println(chs[x]);
		}
		System.out.println("-----------");
		
		//String toLowerCase():把字符串转换为小写字符串
		System.out.println("HelloWorld".toLowerCase());
		//String toUpperCase():把字符串转换为大写字符串
		System.out.println("HelloWorld".toUpperCase());
	}
}
package com.itheima_06;
/*
 * 去除字符串两端空格	
 *		String trim()
 * 按照指定符号分割字符串	
 *		String[] split(String str)
 */
public class StringDemo {
	public static void main(String[] args) {
		//创建字符串对象
		String s1 = "helloworld";
		String s2 = "  helloworld  ";
		String s3 = "  hello  world  ";
		System.out.println("---"+s1+"---");
		System.out.println("---"+s1.trim()+"---");
		System.out.println("---"+s2+"---");
		System.out.println("---"+s2.trim()+"---");
		System.out.println("---"+s3+"---");
		System.out.println("---"+s3.trim()+"---");
		System.out.println("-------------------");
		
		//String[] split(String str)
		//创建字符串对象
		String s4 = "aa,bb,cc";
		String[] strArray = s4.split(",");
		for(int x=0; x<strArray.length; x++) {
			System.out.println(strArray[x]);
		}
	}
}
package com.itheima_07;
/*
 * 把数组中的数据按照指定个格式拼接成一个字符串
 * 举例：int[] arr = {1,2,3};	
 * 输出结果：[1, 2, 3]
 * 
 * 分析：
 * 		A:定义一个int类型的数组
 * 		B:写方法实现把数组中的元素按照指定的格式拼接成一个字符串
 * 		C:调用方法
 * 		D:输出结果
 */
public class StringTest {
	public static void main(String[] args) {
		//定义一个int类型的数组
		int[] arr = {1,2,3};
		
		//写方法实现把数组中的元素按照指定的格式拼接成一个字符串
		
		//调用方法
		String s = arrayToString(arr);
		
		//输出结果
		System.out.println("s:"+s);
	}
	
	/*
	 * 两个明确：
	 * 		返回值类型：String
	 * 		参数列表：int[] arr
	 */
	public static String arrayToString(int[] arr) {
		String s = "";
		
		//[1, 2, 3]
		s += "[";
		for(int x=0; x<arr.length; x++) {
			if(x==arr.length-1) {
				s += arr[x];
			}else {
				s += arr[x];
				s += ", ";
			}
		}
		s += "]";
		
		return s;
	}
}
package com.itheima_07;

import java.util.Scanner;

/*
 * 字符串反转
 * 举例：键盘录入”abc”		
 * 输出结果：”cba”
 * 
 * 分析：
 * 		A:键盘录入一个字符串
 * 		B:写方法实现字符串的反转
 * 			a:把字符串倒着遍历，得到的每一个字符拼接成字符串。
 * 			b:把字符串转换为字符数组，然后对字符数组进行反转，最后在把字符数组转换为字符串
 * 		C:调用方法
 * 		D:输出结果
 */
public class StringTest2 {
	public static void main(String[] args) {
		//键盘录入一个字符串
		Scanner sc = new Scanner(System.in);
		System.out.println("请输入一个字符串：");
		String s = sc.nextLine();
		
		//写方法实现字符串的反转
		
		//调用方法
		String result = reverse(s);
		
		//输出结果
		System.out.println("result:"+result);
	}
	
	
	
	/*
	 * 把字符串倒着遍历，得到的每一个字符拼接成字符串。
	 * 
	 * 两个明确：
	 * 		返回值类型：String
	 * 		参数列表：String s
	 */
	
	/*
	public static String reverse(String s) {
		String ss = "";
		
		for(int x=s.length()-1; x>=0; x--) {
			ss += s.charAt(x);
		}
		
		return ss;
	}
	*/
	
	//把字符串转换为字符数组，然后对字符数组进行反转，最后在把字符数组转换为字符串
	public static String reverse(String s) {
		//把字符串转换为字符数组
		char[] chs = s.toCharArray();
		
		//对字符数组进行反转
		for(int start=0,end=chs.length-1; start<=end; start++,end--) {
			char temp = chs[start];
			chs[start] = chs[end];
			chs[end] = temp;
		}
		
		//最后在把字符数组转换为字符串
		String ss = new String(chs);
		return ss;
	}
}
package com.itheima_01;
/*
 * StringBuilder:是一个可变的字符串。字符串缓冲区类。
 * 
 * String和StringBuilder的区别：
 * 		String的内容是固定的。
 * 		StringBuilder的内容是可变的。
 * 
 * 构造方法：
 * 		StringBuilder()
 * 
 * 成员方法：
 * 		public int capacity():返回当前容量
 * 		public int length():返回长度（字符数）
 * 
 * 		容量：理论值
 * 		长度：实际值
 */
public class StringBuilderDemo {
	public static void main(String[] args) {
		//创建对象
		StringBuilder sb = new StringBuilder();
		System.out.println("sb:"+sb);
		System.out.println("sb.capacity():"+sb.capacity());
		System.out.println("sb.length():"+sb.length());
	}
}
package com.itheima_02;
/*
 * 添加功能
 *		public StringBuilder append(任意类型):添加数据，并返回自身对象
 * 反转功能
 *		public StringBuilder reverse()
 */
public class StringBuilderDemo {
	public static void main(String[] args) {
		//创建对象
		StringBuilder sb = new StringBuilder();
		
		//public StringBuilder append(任意类型)
		//StringBuilder sb2 = sb.append("hello");
		
		/*
		System.out.println("sb:"+sb);
		System.out.println("sb2:"+sb2);
		System.out.println(sb == sb2); //true
		*/
		
		/*
		sb.append("hello");
		sb.append("world");
		sb.append(true);
		sb.append(100);
		*/
		
		//链式编程
		sb.append("hello").append("world").append(true).append(100);
		
		System.out.println("sb:"+sb);
		
		//public StringBuilder reverse()
		sb.reverse();
		System.out.println("sb:"+sb);
		
	}
}
package com.itheima_03;
/*
 * StringBuilder和String的相互转换
 * 
 * StringBuilder -- String
 * 		public String toString():通过toString()就可以实现把StringBuilder转成String
 * 
 * String -- StringBuilder
 * 		StringBuilder(String str):通过构造方法就可以实现把String转成StringBuilder
 */
public class StringBuilderTest {
	public static void main(String[] args) {
		//StringBuilder -- String
		/*
		StringBuilder sb = new StringBuilder();
		sb.append("hello").append("world");
		
		String s = sb.toString();
		System.out.println(s);
		*/
		
		//String -- StringBuilder
		String s = "helloworld";
		StringBuilder sb = new StringBuilder(s);
		System.out.println(sb);
	}
}
package com.itheima_03;
/*
 * 把数组拼接成一个字符串
 * 举例：
 * 		int[] arr = {1,2,3};
 * 结果：
 * 		[1, 2, 3]
 */
public class StringBuilderTest2 {
	public static void main(String[] args) {
		//定义一个数组
		int[] arr = {1,2,3};
		
		//写方法实现拼接
		
		//调用方法
		String s = arrayToString(arr);
		
		//输出结果
		System.out.println("s:"+s);
	}
	
	/*
	 * 两个明确：
	 * 		返回值类型：String
	 * 		参数列表：int[] arr
	 */
	public static String arrayToString(int[] arr) {
		StringBuilder sb = new StringBuilder();
		//[1, 2, 3]
		sb.append("[");
		for(int x=0; x<arr.length; x++) {
			if(x==arr.length-1) {
				sb.append(arr[x]);
			}else {
				sb.append(arr[x]).append(", ");
			}
		}
		sb.append("]");
		
		String result = sb.toString();
		
		return result;
	}
}
package com.itheima_03;

import java.util.Scanner;

/*
 * 把字符串反转
 * 
 * 分析：
 * 		A:键盘录入一个字符串
 * 		B:写方法实现反转
 * 			String -- StringBuilder -- reverse() -- String
 * 		C:调用方法
 * 		D:输出结果
 */
public class StringBuilderTest3 {
	public static void main(String[] args) {
		//键盘录入一个字符串
		Scanner sc = new Scanner(System.in);
		System.out.println("请输入一个字符串：");
		String s = sc.nextLine();
		
		//写方法实现反转
		
		//调用方法
		String result = myReverse(s);
		
		//输出结果
		System.out.println("result:"+result);
	}
	
	/*
	 * 两个明确：
	 * 		返回值类型：String
	 * 		参数列表：String
	 */
	public static String myReverse(String s) {
		//String -- StringBuilder -- reverse() -- String
		StringBuilder sb = new StringBuilder(s);
		sb.reverse();
		String result = sb.toString();
		return result;
	}
}
package com.itheima_03;

import java.util.Scanner;

/*
 * 判断一个字符串是否是对称字符串
 * 例如"abc"不是对称字符串，"aba"、"abba"、"aaa"、"mnanm"是对称字符串
 * 
 * 分析：
 * 		A:键盘录入一个字符串
 * 		B:写方法实现判断一个字符串是否是对称字符串
 * 			把字符串反转，和反转前的字符串进行比较，如果内容相同，就说明是对称字符串
 * 		C:调用方法
 * 		D:输出结果
 */
public class StringBuilderTest4 {
	public static void main(String[] args) {
		//键盘录入一个字符串
		Scanner sc = new Scanner(System.in);
		System.out.println("请输入一个字符串：");
		String s = sc.nextLine();
		
		//写方法实现判断一个字符串是否是对称字符串
		
		//调用方法
		boolean b = isSymmetry(s);
		
		//输出结果
		System.out.println("b:"+b);
	}
	
	/*
	 * 两个明确：
	 * 		返回值类型：boolean
	 * 		参数列表：String s
	 */
	public static boolean isSymmetry(String s) {
		//把字符串反转，和反转前的字符串进行比较，如果内容相同，就说明是对称字符串
		StringBuilder sb = new StringBuilder(s);
		sb.reverse();
		String result = sb.toString();
		
		return result.equals(s);
	}
}
package com.itheima_01;

import java.util.ArrayList;

/*
 * 为什么会出现集合类：
 * 		我们学习的是面向对象编程语言，而面向对象编程语言对事物的描述都是通过对象来体现的。
 * 		为了方便对多个对象进行操作，我们就必须对这多个对象进行存储，而要想对多个对象进行存储，
 * 		就不能是一个基本的变量，而应该是一个容器类型的变量。
 * 		到目前为止，我们学习过了哪些容器类型的数据呢？StringBuilder,数组。
 * 		StringBuilder的结果只能是一个字符串类型，不一定满足我们的需求。
 * 		所以，我们目前只能选择数组了，也就是我们前面学习过的对象数组。
 * 		但是，数组的长度是固定的，适应不了变化的需求，那么，我们该如何选择呢?
 * 		这个时候，java就提供了集合类供我们使用。
 * 
 * 集合类的特点：
 * 		长度可变。
 * 
 * ArrayList<E>:
 * 		大小可变数组的实现
 * 
 * 		<E>:是一种特殊的数据类型，泛型。
 * 		怎么用呢?
 * 			在出现E的地方我们使用引用数据类型替换即可
 * 			举例：ArrayList<String>,ArrayList<Student>
 * 
 * 构造方法：
 * 		ArrayList()
 * 
 * 添加元素：
 * 		public boolean add(E e):添加元素
 * 		public void add(int index,E element):在指定的索引处添加一个元素
 */
public class ArrayListDemo {
	public static void main(String[] args) {
		//创建集合对象
		ArrayList<String> array = new  ArrayList<String>();
		
		//add(E e):添加元素
		array.add("hello");
		array.add("world");
		array.add("java");
		
		//add(int index,E element):在指定的索引处添加一个元素
		//array.add(1, "android");
		
		
		System.out.println("array:"+array);
	}
}
package com.itheima_01;

import java.util.ArrayList;

/*
 * 获取元素
 * 		public E get(int index):返回指定索引处的元素
 * 集合长度
 * 		public int size():返回集合中的元素的个数
 * 删除元素
 * 		public boolean remove(Object o):删除指定的元素，返回删除是否成功
 * 		public E remove(int index):删除指定索引处的元素，返回被删除的元素
 * 修改元素
 * 		public E set(int index,E element):修改指定索引处的元素，返回被修改的元素
 */
public class ArrayListDemo2 {
	public static void main(String[] args) {
		//创建集合对象
		ArrayList<String> array = new ArrayList<String>();
		
		//添加元素
		array.add("hello");
		array.add("world");
		array.add("java");
		
		//public E get(int index):返回指定索引处的元素
		//System.out.println("get:"+array.get(0));
		//System.out.println("get:"+array.get(1));
		//System.out.println("get:"+array.get(2));
		
		//public int size():返回集合中的元素的个数
		//System.out.println("size:"+array.size());
		
		//public boolean remove(Object o):删除指定的元素，返回删除是否成功
		//System.out.println("remove:"+array.remove("world"));//true
		//System.out.println("remove:"+array.remove("world"));//false
		
		//public E remove(int index):删除指定索引处的元素，返回被删除的元素
		//System.out.println("remove:"+array.remove(0));
		
		//public E set(int index,E element):修改指定索引处的元素，返回被修改的元素
		System.out.println("set:"+array.set(1, "android"));
		
		//输出
		System.out.println("array:"+array);
	}
}
package com.itheima_01;

import java.util.ArrayList;

/*
 * ArrayList集合的遍历
 * 		通过size()和get()配合实现的
 */
public class ArrayListDemo3 {
	public static void main(String[] args) {
		//创建集合对象
		ArrayList<String> array = new ArrayList<String>();
		
		//添加元素
		array.add("hello");
		array.add("world");
		array.add("java");
		
		//获取元素
		//原始做法
		System.out.println(array.get(0));
		System.out.println(array.get(1));
		System.out.println(array.get(2));
		System.out.println("----------");
		
		for(int x=0; x<3; x++) {
			System.out.println(array.get(x));
		}
		System.out.println("----------");
		
		//如何知道集合中元素的个数呢?size()
		for(int x=0; x<array.size(); x++) {
			System.out.println(array.get(x));
		}
		System.out.println("----------");
		
		//最标准的用法
		for(int x=0; x<array.size(); x++) {
			String s = array.get(x);
			System.out.println(s);
		}
	}
}
package com.itheima_02;

import java.util.ArrayList;

/*
 * 存储字符串并遍历
 * 
 * 分析：
 * 		A:创建集合对象
 * 		B:添加字符串元素
 * 		C:遍历集合
 */
public class ArrayListTest {
	public static void main(String[] args) {
		//创建集合对象
		ArrayList<String> array = new ArrayList<String>();
		
		//添加字符串元素
		array.add("向问天");
		array.add("刘正风");
		array.add("左冷禅");
		array.add("风清扬");
		
		//遍历集合
		for(int x=0; x<array.size(); x++) {
			String s = array.get(x);
			System.out.println(s);
		}
	}
}
package com.itheima_02;

import java.util.ArrayList;

/*
 * 给定一个字符串数组：{“张三丰”,“宋远桥”,“张无忌”,“殷梨亭”,“张翠山”,“莫声谷”}，将数组中的元素添加到集合中，并把所有姓张的人员打印到控制台上。
 * 
 * 分析：
 * 		A:定义字符串数组
 * 		B:创建集合对象
 * 		C:遍历字符串数组，获取到每一个字符串元素
 * 		D:把获取到的字符串元素添加到集合
 * 		E:遍历集合
 * 			要判断每一个字符串元素是否以"张"开头，如果是，就输出在控制台
 */
public class ArrayListTest2 {
	public static void main(String[] args) {
		//定义字符串数组
		String[] strArray = {"张三丰","宋远桥","张无忌","殷梨亭","张翠山","莫声谷"};
		
		//创建集合对象
		ArrayList<String> array = new ArrayList<String>();
		
		//遍历字符串数组，获取到每一个字符串元素
		for(int x=0; x<strArray.length; x++) {
			//把获取到的字符串元素添加到集合
			array.add(strArray[x]);
		}
		
		//遍历集合
		for(int x=0; x<array.size(); x++) {
			String s = array.get(x);
			//要判断每一个字符串元素是否以"张"开头，如果是，就输出在控制台
			if(s.startsWith("张")) {
				System.out.println(s);
			}
		}
	}
}
package com.itheima_02;

import java.util.ArrayList;
/*
 * 存储自定义对象并遍历
 * 
 * 分析：
 * 		A:定义学生类
 * 		B:创建集合对象
 * 		C:创建学生对象
 * 		D:把学生对象作为元素添加到集合中
 * 		E:遍历集合
 */
public class ArrayListTest3 {
	public static void main(String[] args) {
		//创建集合对象
		ArrayList<Student> array = new ArrayList<Student>();
		
		//创建学生对象
		Student s1 = new Student("林青霞",28);
		Student s2 = new Student("张曼玉",30);
		Student s3 = new Student("景甜",25);
		Student s4 = new Student("柳岩",18);
		
		//把学生对象作为元素添加到集合中
		array.add(s1);
		array.add(s2);
		array.add(s3);
		array.add(s4);
		
		//遍历集合
		for(int x=0; x<array.size(); x++) {
			Student s = array.get(x);
			System.out.println(s.getName()+"---"+s.getAge());
		}
	}
}
package com.itheima_02;

public class Student {
	private String name;
	private int age;
	
	public Student() {
		
	}
	public Student(String name, int age) {
		this.name = name;
		this.age = age;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	
	
}
package com.itheima_03;

public class Student {
	private String name;
	private String age;
	public Student() {

	}
	public Student(String name, String age) {
		this.name = name;
		this.age = age;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getAge() {
		return age;
	}
	public void setAge(String age) {
		this.age = age;
	}
	
	
}
package com.itheima_03;

import java.util.ArrayList;
import java.util.Scanner;

/*
 * 创建一个集合，存储学生对象，学生对象的数据来自于键盘录入，最后，遍历集合
 * 
 * 注意：为了方便使用，我把学生类中的所有成员定义为String类型
 * 
 * 分析：
 * 		A:定义学生类
 * 		B:创建集合对象
 * 		C:键盘录入数据,创建学生对象,把键盘录入的数据赋值给学生对象的成员变量
 * 		D:把学生对象作为元素存储到集合中
 * 		E:遍历集合
 * 
 */
public class StudentDemo {
	public static void main(String[] args) {
		//创建集合对象
		ArrayList<Student> array = new ArrayList<Student>();
		
		/*
		//键盘录入数据,创建学生对象,把键盘录入的数据赋值给学生对象的成员变量
		Scanner sc = new Scanner(System.in);
		System.out.println("请输入学生姓名：");
		String name = sc.nextLine();
		System.out.println("请输入学生年龄：");
		String age = sc.nextLine();
		
		Student s = new Student();
		s.setName(name);
		s.setAge(age);
		
		//把学生对象作为元素存储到集合中
		array.add(s);
		*/
		
		//为了提高代码的复用性，我把键盘录入数据给学生对象，并存储到集合中的动作用一个方法来实现
		
		//调用方法
		addStudent(array);
		addStudent(array);
		addStudent(array);
		
		//遍历集合
		for(int x=0; x<array.size(); x++) {
			Student s = array.get(x);
			System.out.println(s.getName()+"---"+s.getAge());
		}
	}
	
	/*
	 * 两个明确：
	 * 		返回值类型：void
	 * 		参数列表：ArrayList<Student> array
	 */
	public static void addStudent(ArrayList<Student> array) {
		//键盘录入数据,创建学生对象,把键盘录入的数据赋值给学生对象的成员变量
		Scanner sc = new Scanner(System.in);
		System.out.println("请输入学生姓名：");
		String name = sc.nextLine();
		System.out.println("请输入学生年龄：");
		String age = sc.nextLine();
		
		Student s = new Student();
		s.setName(name);
		s.setAge(age);
		
		//把学生对象作为元素存储到集合中
		array.add(s);
	}
}
package com.itheima;
/*
 * 自动生成构造方法：
 * 		代码区域右键 -- Source -- Generate Constructors from Superclass...	无参构造方法
 * 		代码区域右键 -- Source -- Generate Constructor using Fields...		带参构造方法
 * 自动生成getXxx()/setXxx():
 * 		代码区域右键 -- Source -- Generate Getters and Setters...
 */
public class Student {
	private String name;
	private int age;
	
	public Student() {
		
	}

	public Student(String name, int age) {
		this.name = name;
		this.age = age;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}
	
	
}
package com.itheima;
/*
 * 创建一个学生数组，存储三个学生对象并遍历
 * 
 * 分析：
 * 		A:定义学生类
 * 		B:创建学生数组
 * 		C:创建学生对象
 * 		D:把学生对象作为元素赋值给学生数组
 * 		E:遍历学生数组
 */
public class StudentDemo {
	public static void main(String[] args) {
		//创建学生数组
		Student[] students = new Student[3];
		
		//创建学生对象
		Student s1 = new Student("曹操",40);
		Student s2 = new Student("刘备",35);
		Student s3 = new Student("孙权",30);
		
		//把学生对象作为元素赋值给学生数组
		students[0] = s1;
		students[1] = s2;
		students[2] = s3;
		
		//遍历学生数组
		for(int x=0; x<students.length; x++) {
			Student s = students[x];
			//System.out.println(s);
			System.out.println(s.getName()+"---"+s.getAge());
		}
	}
}
package com.itheima;
/*
 * 这是我的学生类
 */
public class Student {
	//学号
	private String id;
	//姓名
	private String name;
	//年龄
	private String age;
	//居住地
	private String address;
	
	public Student() {
		
	}

	public Student(String id, String name, String age, String address) {
		this.id = id;
		this.name = name;
		this.age = age;
		this.address = address;
	}

	public String getId() {
		return id;
	}

	public void setId(String id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getAge() {
		return age;
	}

	public void setAge(String age) {
		this.age = age;
	}

	public String getAddress() {
		return address;
	}

	public void setAddress(String address) {
		this.address = address;
	}
	
}
package com.itheima;

import java.util.ArrayList;
import java.util.Scanner;

/*
 * 这是我的学生管理系统的主类
 * 
 * 步骤如下：
 * A:定义学生类
 * B:学生管理系统的主界面的代码编写
 * C:学生管理系统的查看所有学生的代码编写
 * D:学生管理系统的添加学生的代码编写
 * E:学生管理系统的删除学生的代码编写
 * F:学生管理系统的修改学生的代码编写
 */
public class StudentManagerTest {
	public static void main(String[] args) {
		//创建集合对象，用于存储学生数据
		ArrayList<Student> array = new ArrayList<Student>();
		
		//为了让程序能够回到这里来，我们使用循环
		while(true) {
			//这是学生管理系统的主界面
			System.out.println("--------欢迎来到学生管理系统--------");
			System.out.println("1 查看所有学生");
			System.out.println("2 添加学生");
			System.out.println("3 删除学生");
			System.out.println("4 修改学生");
			System.out.println("5 退出");
			System.out.println("请输入你的选择：");
			//创建键盘录入对象
			Scanner sc = new Scanner(System.in);
			String choiceString = sc.nextLine();
			//用switch语句实现选择
			switch(choiceString) {
			case "1":
				//查看所有学生
				findAllStudent(array);
				break;
			case "2":
				//添加学生
				addStudent(array);
				break;
			case "3":
				//删除学生
				deleteStudent(array);
				break;
			case "4":
				//修改学生
				updateStudent(array);
				break;
			case "5":
				//退出
				//System.out.println("谢谢你的使用");
				//break;
			default:
				System.out.println("谢谢你的使用");
				System.exit(0); //JVM退出
				break;
			}
		}
	}
	
	//修改学生
	public static void updateStudent(ArrayList<Student> array) {
		//修改学生的思路：键盘录入一个学号，到集合中去查找，看是否有学生使用的是该学号，如果有就修改该学生
		//创建键盘录入对象
		Scanner sc = new Scanner(System.in);
		System.out.println("请输入你要修改的学生的学号：");
		String id = sc.nextLine();
		
		//定义一个索引
		int index = -1;
		
		//遍历集合
		for(int x=0; x<array.size(); x++) {
			//获取每一个学生对象
			Student s = array.get(x);
			//拿学生对象的学号和键盘录入的学号进行比较
			if(s.getId().equals(id)) {
				index = x;
				break;
			}
		}
		
		if(index == -1) {
			System.out.println("不好意思,你要修改的学号对应的学生信息不存在,请回去重新你的选择");
		}else {
			System.out.println("请输入学生新姓名：");
			String name = sc.nextLine();
			System.out.println("请输入学生新年龄：");
			String age = sc.nextLine();
			System.out.println("请输入学生新居住地：");
			String address = sc.nextLine();
			
			//创建学生对象
			Student s = new Student();
			s.setId(id);
			s.setName(name);
			s.setAge(age);
			s.setAddress(address);
			
			//修改集合中的学生对象
			array.set(index, s);
			
			//给出提示
			System.out.println("修改学生成功");
		}
	}
	
	//删除学生
	public static void deleteStudent(ArrayList<Student> array) {
		//删除学生的思路：键盘录入一个学号，到集合中去查找，看是否有学生使用的是该学号，如果有就删除该学生
		//创建键盘录入对象
		Scanner sc = new Scanner(System.in);
		System.out.println("请输入你要删除的学生的学号：");
		String id = sc.nextLine();
		
		/*
		//遍历集合
		for(int x=0; x<array.size(); x++) {
			//获取到每一个学生对象
			Student s = array.get(x);
			//拿这个学生对象的学号和键盘录入的学号进行比较
			if(s.getId().equals(id)) {
				array.remove(x); //根据索引删除
				break;
			}
		}
		
		//给出提示
		System.out.println("删除学生成功");
		*/
		
		//我们必须给出学号不存在的时候的提示
		
		//定义一个索引
		int index = -1;
		
		//遍历集合
		for(int x=0; x<array.size(); x++) {
			//获取到每一个学生对象
			Student s = array.get(x);
			//拿这个学生对象的学号和键盘录入的学号进行比较
			if(s.getId().equals(id)) {
				index = x;
				break;
			}
		}
		
		if(index == -1) {
			System.out.println("不好意思,你要删除的学号对应的学生信息不存在,请回去重新你的选择");
		}else {
			array.remove(index);
			System.out.println("删除学生成功");
		}
		
	}

	//添加学生
	public static void addStudent(ArrayList<Student> array) {
		//创建键盘录入对象
		Scanner sc = new Scanner(System.in);
		
		//为了让id能够被访问到，我们就把id定义在了循环的外面
		String id;
		
		//为了让代码能够回到这里，用循环
		while(true) {
			System.out.println("请输入学生学号：");
			//String id = sc.nextLine();
			id = sc.nextLine();
			
			//判断学号有没有被人占用
			//定义标记
			boolean flag = false;
			//遍历集合，得到每一个学生
			for(int x=0; x<array.size(); x++) {
				Student s = array.get(x);
				//获取该学生的学号，和键盘录入的学号进行比较
				if(s.getId().equals(id)) {
					flag = true; //说明学号被占用了
					break;
				}
			}
			
			if(flag) {
				System.out.println("你输入的学号已经被占用,请重新输入");
			}else {
				break; //结束循环
			}
		}
		
		
		System.out.println("请输入学生姓名：");
		String name = sc.nextLine();
		System.out.println("请输入学生年龄：");
		String age = sc.nextLine();
		System.out.println("请输入学生居住地：");
		String address = sc.nextLine();
		
		//创建学生对象
		Student s = new Student();
		s.setId(id);
		s.setName(name);
		s.setAge(age);
		s.setAddress(address);
		
		//把学生对象作为元素添加到集合
		array.add(s);
		
		//给出提示
		System.out.println("添加学生成功");
	}
	
	/*
	//添加学生
	public static void addStudent(ArrayList<Student> array) {
		//创建键盘录入对象
		Scanner sc = new Scanner(System.in);
		
		System.out.println("请输入学生学号：");
		String id = sc.nextLine();
		System.out.println("请输入学生姓名：");
		String name = sc.nextLine();
		System.out.println("请输入学生年龄：");
		String age = sc.nextLine();
		System.out.println("请输入学生居住地：");
		String address = sc.nextLine();
		
		//创建学生对象
		Student s = new Student();
		s.setId(id);
		s.setName(name);
		s.setAge(age);
		s.setAddress(address);
		
		//把学生对象作为元素添加到集合
		array.add(s);
		
		//给出提示
		System.out.println("添加学生成功");
	}
	*/
	
	//查看所有学生
	public static void findAllStudent(ArrayList<Student> array) {
		//首先来判断集合中是否有数据，如果没有数据，就给出提示，并让该方法不继续往下执行
		if(array.size() == 0) {
			System.out.println("不好意思,目前没有学生信息可供查询,请回去重新选择你的操作");
			return;
		}
		
		//\t 其实就是一个tab键的位置
		System.out.println("学号\t\t姓名\t年龄\t居住地");
		for(int x=0; x<array.size(); x++) {
			Student s = array.get(x);
			System.out.println(s.getId()+"\t"+s.getName()+"\t"+s.getAge()+"\t"+s.getAddress());
		}
	}
}
package com.itheima;

public class Student {
	private String sid;
	private String name;
	private String age;
	private String address;

	public Student() {
		super();
	}

	public Student(String sid, String name, String age, String address) {
		super();
		this.sid = sid;
		this.name = name;
		this.age = age;
		this.address = address;
	}

	public String getSid() {
		return sid;
	}

	public void setSid(String sid) {
		this.sid = sid;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getAge() {
		return age;
	}

	public void setAge(String age) {
		this.age = age;
	}

	public String getAddress() {
		return address;
	}

	public void setAddress(String address) {
		this.address = address;
	}

}
package com.itheima;

import java.util.ArrayList;
import java.util.Scanner;

public class StudentManangerTest {
	public static void main(String[] args) {
		ArrayList<Student> array = new ArrayList<Student>();
		while (true) {
			System.out.println("--------欢迎来到学生管理系统,请选择：--------");
			System.out.println("1 查看所有学生");
			System.out.println("2 添加学生");
			System.out.println("3 删除学生");
			System.out.println("4 修改学生");
			System.out.println("5 退出");
			System.out.println("请输入你的选择：");
			Scanner sc = new Scanner(System.in);
			String choiceString = sc.nextLine();
			switch (choiceString) {
			case "1":
				findAllStudent(array);
				break;
			case "2":
				addStudent(array);
				break;
			case "3":
				deleteStudent(array);
				break;
			case "4":
				updateStudent(array);
				break;
			case "5":
			default:
				System.out.println("谢谢你的使用 ");
				System.exit(0);
				break;
			}
		}
	}

	private static void updateStudent(ArrayList<Student> array) {
		Scanner sc = new Scanner(System.in);
		System.out.println("请输入你要修改学生的学号：");
		String sid = sc.nextLine();
		int index = -1;
		for (int x = 0; x < array.size(); x++) {
			Student s = array.get(x);
			if (s.getSid().equals(sid)) {
				index = x;
				break;
			}
		}
		if (index != -1) {
			System.out.println("请输入新姓名：");
			String name = sc.nextLine();
			System.out.println("请输入新年龄：");
			String age = sc.nextLine();
			System.out.println("请输入新地址：");
			String address = sc.nextLine();
			Student s = new Student();
			s.setSid(sid);
			s.setName(name);
			s.setAge(age);
			s.setAddress(address);
			array.set(index, s);
			System.out.println("修改学生成功");
		} else {
			System.out.println("不好意思,你要修改的学号对应的学生信息不存在，请回去重新选择你的操作");
			return;
		}
	}

	private static void deleteStudent(ArrayList<Student> array) {
		Scanner sc = new Scanner(System.in);
		System.out.println("请输入你要删除学生的学号：");
		String sid = sc.nextLine();
		int index = -1;
		for (int x = 0; x < array.size(); x++) {
			Student s = array.get(x);
			if (s.getSid().equals(sid)) {
				index = x;
				break;
			}
		}
		if (index != -1) {
			array.remove(index);
			System.out.println("删除学生成功");
		} else {
			System.out.println("不好意思,你要删除的学号对应的学生信息不存在，请回去重新选择你的操作");
			return;
		}
	}

	private static void addStudent(ArrayList<Student> array) {
		Scanner sc = new Scanner(System.in);
		String sid;
		while (true) {
			System.out.println("请输入学号：");
			sid = sc.nextLine();

			boolean flag = false;
			for (int x = 0; x < array.size(); x++) {
				Student s = array.get(x);
				if (s.getSid().equals(sid)) {
					flag = true;
				}
			}

			if (flag == true) {
				System.out.println("你输入的学号已经被占用,请重新输入");
			} else {
				break;
			}
		}

		System.out.println("请输入姓名：");
		String name = sc.nextLine();
		System.out.println("请输入年龄：");
		String age = sc.nextLine();
		System.out.println("请输入地址：");
		String address = sc.nextLine();
		Student s = new Student();
		s.setSid(sid);
		s.setName(name);
		s.setAge(age);
		s.setAddress(address);
		array.add(s);
		System.out.println("添加学生成功");
	}

	private static void findAllStudent(ArrayList<Student> array) {
		if (array.size() == 0) {
			System.out.println("不好意思,目前没有学生信息可供查看,请回去重新选择你的操作");
			return;
		}
		System.out.println("学号\t\t姓名\t年龄\t居住地");
		for (int x = 0; x < array.size(); x++) {
			Student s = array.get(x);
			System.out.println(s.getSid() + "\t" + s.getName() + "\t" + s.getAge() + "\t" + s.getAddress());
		}
	}
}
package com.itheima_01;

import java.io.FileWriter;
import java.io.IOException;

/*
 * 需求：往文件中写数据
 * 		写数据--输出流--FileWriter
 * 
 * FileWriter:
 * 		FileWriter(String fileName):传递一个文件名称
 * 
 * 输出流写数据的步骤：
 * 		A:创建输出流对象
 * 		B:调用输出流对象的写数据的方法
 * 		C:释放资源
 */
public class FileWriterDemo {
	public static void main(String[] args) throws IOException {
		//创建输出流对象
		FileWriter fw = new FileWriter("d:\\a.txt");
		/*
		 * 创建输出流对象做了哪些事情:
		 * 		A:调用系统资源创建了一个文件
		 * 		B:创建输出流对象
		 * 		C:把输出流对象指向文件
		 */
		
		//调用输出流对象的写数据的方法
		//写一个字符串数据
		fw.write("IO流你好");
		//数据没有直接写到文件，其实是写到了内存缓冲区
		fw.flush();
		
		//释放资源
		//通知系统释放和该文件相关的资源
		fw.close();
		
		//while(true) {}
	}
}
package com.itheima_01;

import java.io.FileWriter;
import java.io.IOException;

/*
 * 需求：往文件中写数据
 * 		写数据--输出流--FileWriter
 * 
 * FileWriter:
 * 		FileWriter(String fileName):传递一个文件名称
 * 
 * 输出流写数据的步骤：
 * 		A:创建输出流对象
 * 		B:调用输出流对象的写数据的方法
 * 		C:释放资源
 */
public class FileWriterDemo {
	public static void main(String[] args) throws IOException {
		//创建输出流对象
		FileWriter fw = new FileWriter("d:\\a.txt");
		/*
		 * 创建输出流对象做了哪些事情:
		 * 		A:调用系统资源创建了一个文件
		 * 		B:创建输出流对象
		 * 		C:把输出流对象指向文件
		 */
		
		//调用输出流对象的写数据的方法
		//写一个字符串数据
		fw.write("IO流你好");
		//数据没有直接写到文件，其实是写到了内存缓冲区
		fw.flush();
		
		//释放资源
		//通知系统释放和该文件相关的资源
		fw.close();
		
		//while(true) {}
	}
}
package com.itheima_01;

import java.io.FileWriter;
import java.io.IOException;

/*
 * 输出流写数据的步骤：
 * 		A:创建输出流对象
 * 		B:调用输出流对象的写数据方法，并刷新缓冲区
 * 		C:释放资源
 * 
 * 相对路径：相对当前项目而言的，在项目的根目录下(a.txt)
 * 绝对路径：以盘符开始的路径(d:\\a.txt)
 * 
 * close()和flush()方法的区别：
 * 		flush():刷新缓冲区。流对象还可以继续使用。
 * 		close():先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。
 */
public class FileWriterDemo2 {
	public static void main(String[] args) throws IOException {
		//创建输出流对象
		//FileWriter fw = new FileWriter("d:\\a.txt");
		FileWriter fw = new FileWriter("a.txt");
		
		//调用输出流对象的写数据方法，并刷新缓冲区
		fw.write("helloworld");
		fw.flush();
		fw.write("java");
		fw.flush();
		
		//释放资源
		fw.close();
		
		//Stream closed
		//fw.write("javaee");
		//fw.flush();
	}
}
package com.itheima_01;

import java.io.FileWriter;
import java.io.IOException;

/*
 * void write(String str):写一个字符串数据
 * void write(String str,int index,int len):写一个字符串中的一部分数据
 * void write(int ch):写一个字符数据,这里写int类型的好处是既可以写char类型的数据，也可以写char对应的int类型的值。'a',97
 * void write(char[] chs):写一个字符数组数据
 * void write(char[] chs,int index,int len):写一个字符数组的一部分数据
 */
public class FileWriterDemo3 {
	public static void main(String[] args) throws IOException {
		//创建输出流对象
		FileWriter fw = new FileWriter("b.txt");
		
		//void write(String str):写一个字符串数据
		//fw.write("abcde");
		
		//void write(String str,int index,int len):写一个字符串中的一部分数据
		//fw.write("abcde",0,5);
		//fw.write("abcde",1,3);
		
		//void write(int ch):写一个字符数据,这里写int类型的好处是既可以写char类型的数据，也可以写char对应的int类型的值。'a',97
		//fw.write('a');
		//fw.write(97);
		
		//void write(char[] chs):写一个字符数组数据
		char[] chs = {'a','b','c','d','e'};
		//fw.write(chs);
		
		//void write(char[] chs,int index,int len):写一个字符数组的一部分数据
		//fw.write(chs,0,5);
		fw.write(chs,2,3);
		
		//释放资源
		fw.close();
	}
}
package com.itheima_01;

import java.io.FileWriter;
import java.io.IOException;

/*
 * 如何实现数据的换行?
 * 		\n可以实现换行，但是windows系统自带的记事本打开并没有换行，这是为什么呢?因为windows识别的换行不是\n，而是\r\n
 * 		windows:\r\n
 * 		linux:\n
 * 		mac:\r
 * 如何实现数据的追加写入?
 * 		FileWriter(String fileName, boolean append)
 */
public class FileWriterDemo4 {
	public static void main(String[] args) throws IOException {
		//创建输出流对象
		//FileWriter fw = new FileWriter("c.txt");
		FileWriter fw = new FileWriter("c.txt",true); //表示追加写入，默认是false
		
		for(int x=0; x<10; x++) {
			fw.write("hello"+x);
			fw.write("\r\n");
		}
		
		//释放资源
		fw.close();
	}
}
package com.itheima_02;

import java.io.FileReader;
import java.io.IOException;

/*
 * 需求：从文件中读数据并显示到控制台
 * 		读数据--输入流--FileReader
 * 
 * FileReader:
 * 		FileReader(String fileName):传递文件名称
 * 
 * 输入流读文件的步骤：
 * 		A:创建输入流对象
 * 		B:调用输入流对象的读数据方法
 * 		C:释放资源
 * 
 * java.io.FileNotFoundException: fr.txt (系统找不到指定的文件。)
 */
public class FileReaderDemo {
	public static void main(String[] args) throws IOException {
		//创建输入流对象
//		FileReader fr = new FileReader("fr.txt");
		FileReader fr = new FileReader("FileWriterDemo.java");
		
		//调用输入流对象的读数据方法
		//int read():一次读取一个字符
		
		/*
		//第一次读数据
		int ch = fr.read();
		System.out.println(ch);
		System.out.println((char)ch);
		
		//第二次读数据
		ch = fr.read();
		System.out.println(ch);
		System.out.println((char)ch);
		
		//第三次读数据
		ch = fr.read();
		System.out.println(ch);
		System.out.println((char)ch);
		
		//这是时候，我们发现代码的重复度很高，想用循环改进，但是不知道循环的结束条件是什么
		ch = fr.read();
		System.out.println(ch);
		
		ch = fr.read();
		System.out.println(ch);
		//通过测试，我们知道，如果读取数据的返回值是-1的时候，就说明没有数据了，这也是我们循环的结束条件
		*/
		
		int ch;
		//1:fr.read()
		//2:ch=fr.read()
		//3:ch != -1
		while((ch=fr.read())!=-1) {
			//System.out.println(ch);
			//System.out.println((char)ch);
			System.out.print((char)ch);
		}
		
		//释放资源
		fr.close();
	}
}
package com.itheima_02;

import java.io.FileReader;
import java.io.IOException;

/*
 * 输入流读数据的步骤：
 * 		A:创建输入流对象
 * 		B:调用输入流对象的读数据方法
 * 		C:释放资源
 */
public class FileReaderDemo2 {
	public static void main(String[] args) throws IOException {
		//创建输入流对象
		//FileReader fr = new FileReader("fr2.txt");
		FileReader fr = new FileReader("FileWriterDemo.java");
		
		/*
		//调用输入流对象的读数据方法
		//int read(char[] cbuf)：一次读取一个字符数组的数据，返回的是实际读取的字符个数
		char[] chs = new char[5];
		
		//第一次读数据
		int len = fr.read(chs);
		System.out.println("len:"+len);
		//System.out.println(new String(chs));
		System.out.println(new String(chs,0,len));
		
		//第二次读数据
		len = fr.read(chs);
		System.out.println("len:"+len);
		//System.out.println(new String(chs));
		System.out.println(new String(chs,0,len));
		
		//第三次读数据
		len = fr.read(chs);
		System.out.println("len:"+len);
		System.out.println(new String(chs,0,len));
		
		//我们发现读取代码的方式相似度很高，想用循环改进，但是不知道什么时候结束循环
		len = fr.read(chs);
		System.out.println("len:"+len);
		len = fr.read(chs);
		System.out.println("len:"+len);
		//通过测试，我们知道，如果实际读取长度是-1的时候，说明没有数据了
		 * 
		 */
		
		//char[] chs = new char[5];
		char[] chs = new char[1024]; //这里可以是1024及其整数倍
		int len;
		//1:fr.read(chs)
		//2:len=fr.read(chs)
		//3:len != -1
		while((len=fr.read(chs))!=-1) {
			//System.out.println(new String(chs,0,len));
			System.out.print(new String(chs,0,len));
		}
		
		//释放资源
		fr.close();
	}
}
package com.itheima_03;

import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

/*
 * 需求：
 * 		把项目路径下的FileWriterDemo.java中的内容复制到项目路径下的Copy.java中
 * 
 * 文件复制也是有规律可循的，也就是说有套路。
 * 
 * 数据源：
 * 		FileWriterDemo.java -- 读数据 -- FileReader
 * 目的地：
 * 		Copy.java -- 写数据 -- FileWriter
 */
public class CopyFileDemo {
	public static void main(String[] args) throws IOException {
		//创建输入流对象
		FileReader fr = new FileReader("FileWriterDemo.java");
		//创建输出流对象
		FileWriter fw = new FileWriter("Copy.java");
		
		//读写数据
		int ch;
		while((ch=fr.read())!=-1) {
			fw.write(ch);
		}
		
		//释放资源
		fw.close();
		fr.close();
	}
}
package com.itheima_03;

import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

/*
 * 需求：
 * 		把项目路径下的FileWriterDemo.java中的内容复制到项目路径下的Copy.java中
 * 
 * 数据源：
 * 		FileWriterDemo.java -- 读数据 -- FileReader
 * 目的地：
 * 		Copy.java -- 写数据 -- FileWriter
 */
public class CopyFileDemo2 {
	public static void main(String[] args) throws IOException {
		//创建输入流对象
		FileReader fr  = new FileReader("FileWriterDemo.java");
		//创建输出流对象
		FileWriter fw = new FileWriter("Copy.java");
		
		//读写数据
		char[] chs = new char[1024];
		int len;
		while((len=fr.read(chs))!=-1) {
			fw.write(chs, 0, len);
		}
		
		//释放资源
		fw.close();
		fr.close();
	}
}
package com.itheima_04;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/*
 * BufferedWriter:将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。 
 * BufferedReader:从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。
 */
public class BufferedStreamDemo {
	public static void main(String[] args) throws IOException {
		//创建输出缓冲流对象
		/*
		BufferedWriter bw = new BufferedWriter(new FileWriter("bw.txt"));
		bw.write("hello");
		//bw.flush();
		bw.close();
		*/
		
		//创建输入缓冲流对象
		BufferedReader br = new BufferedReader(new FileReader("FileWriterDemo.java"));
		
		/*
		//一次读写一个字符
		int ch;
		while((ch=br.read())!=-1){
			System.out.print((char)ch);
		}
		*/
		
		//一次读写一个字符数组
		char[] chs = new char[1024];
		int len;
		while((len=br.read(chs))!=-1) {
			System.out.print(new String(chs,0,len));
		}
		
		//释放资源
		br.close();
		
	}
}
package com.itheima_04;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

/*
 * 需求：
 * 		把项目路径下的FileWriterDemo.java中的内容复制到项目路径下的Copy.java中
 * 
 * 数据源：
 * 		FileWriterDemo.java -- 读数据 -- FileReader -- 高效的读数据 -- BufferedReader
 * 目的地：
 * 		Copy.java -- 写数据 -- FileWriter -- 高效的写数据 -- BufferedWriter
 */
public class CopyFileDemo {
	public static void main(String[] args) throws IOException {
		//创建输入缓冲流对象
		BufferedReader br = new BufferedReader(new FileReader("FileWriterDemo.java"));
		//创建输出缓冲流对象
		BufferedWriter bw = new BufferedWriter(new FileWriter("Copy.java"));
		
		//读写数据
		/*
		//一次读写一个字符
		int ch;
		while((ch=br.read())!=-1) {
			bw.write(ch);
		}
		*/
		
		//一次读写一个字符数组
		char[] chs = new char[1024];
		int len;
		while((len=br.read(chs))!=-1) {
			bw.write(chs,0,len);
		}
		
		//释放资源
		bw.close();
		br.close();
	}
}
package com.itheima_05;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/*
 * 缓冲流的特殊功能：
 * BufferedWriter
 * 		void newLine():写一个换行符，这个换行符由系统决定
 * BufferedReader
 * 		String readLine():一次读取一行数据，但是不读取换行符
 */
public class BufferedStreamDemo {
	public static void main(String[] args) throws IOException {
		/*
		BufferedWriter bw = new BufferedWriter(new FileWriter("bw2.txt"));
		for(int x=0; x<10; x++) {
			bw.write("hello"+x);
			//bw.write("\r\n");
			bw.newLine();
			bw.flush();
		}
		bw.close();
		*/
		
		BufferedReader br = new BufferedReader(new FileReader("br.txt"));
		
		/*
		String line = br.readLine();
		System.out.println(line);
		
		line = br.readLine();
		System.out.println(line);
		
		line = br.readLine();
		System.out.println(line);
		
		line = br.readLine();
		System.out.println(line);
		*/
		
		String line;
		//1:br.readLine()
		//2:line=br.readLine()
		//3:line != null
		while((line=br.readLine())!=null) {
			System.out.println(line);
		}
		
		br.close();
	}
}
package com.itheima_05;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

/*
 * 需求：
 * 		把项目路径下的FileWriterDemo.java中的内容复制到项目路径下的Copy.java中
 * 
 * 数据源：
 * 		FileWriterDemo.java -- 读数据 -- FileReader -- 高效的读数据 -- BufferedReader
 * 目的地：
 * 		Copy.java -- 写数据 -- FileWriter -- 高效的写数据 -- BufferedWriter
 */
public class CopyFileDemo {
	public static void main(String[] args) throws IOException {
		//创建输入缓冲流对象
		BufferedReader br = new BufferedReader(new FileReader("FileWriterDemo.java"));
		//创建输出缓冲流对象
		BufferedWriter bw = new BufferedWriter(new FileWriter("Copy.java"));
		
		//读写数据
		String line;
		while((line=br.readLine())!=null) {
			bw.write(line);
			bw.newLine();
			bw.flush();
		}
		
		//释放资源
		bw.close();
		br.close();
	}
}
package com.itheima;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;

/*
 * 键盘录入3个学生信息(学号,姓名,年龄,居住地)存入集合。然后遍历集合把每一个学生信息存入文本文件(每一个学生信息为一行数据，自己定义分割标记)
 * 
 * 分析：
 * 		A:定义学生类
 * 		B:创建集合对象
 * 		C:写方法实现键盘录入学生信息，并把学生对象作为元素添加到集合
 * 		D:创建输出缓冲流对象
 * 		E:遍历集合,得到每一个学生信息，并把学生信息按照一定的格式写入文本文件
 * 			举例：heima001,向问天,30,北京
 * 		F:释放资源
 */
public class ArrayListToFileTest {
	public static void main(String[] args) throws IOException {
		//创建集合对象
		ArrayList<Student> array = new ArrayList<Student>();
		
		//写方法实现键盘录入学生信息，并把学生对象作为元素添加到集合
		addStudent(array);
		addStudent(array);
		addStudent(array);
		
		//创建输出缓冲流对象
		BufferedWriter bw = new BufferedWriter(new FileWriter("array.txt"));
		
		//遍历集合,得到每一个学生信息，并把学生信息按照一定的格式写入文本文件
		for(int x=0; x<array.size(); x++) {
			Student s = array.get(x);
			//heima001,向问天,30,北京
			StringBuilder sb = new StringBuilder();
			sb.append(s.getId()).append(",").append(s.getName()).append(",").append(s.getAge()).append(",").append(s.getAddress());
			
			bw.write(sb.toString());
			bw.newLine();
			bw.flush();
		}
		
		//释放资源
		bw.close();
	}
	
	//添加学生
	public static void addStudent(ArrayList<Student> array) {
		//创建键盘录入对象
		Scanner sc = new Scanner(System.in);
		
		//为了让id能够被访问到，我们就把id定义在了循环的外面
		String id;
		
		//为了让代码能够回到这里，用循环
		while(true) {
			System.out.println("请输入学生学号：");
			//String id = sc.nextLine();
			id = sc.nextLine();
			
			//判断学号有没有被人占用
			//定义标记
			boolean flag = false;
			//遍历集合，得到每一个学生
			for(int x=0; x<array.size(); x++) {
				Student s = array.get(x);
				//获取该学生的学号，和键盘录入的学号进行比较
				if(s.getId().equals(id)) {
					flag = true; //说明学号被占用了
					break;
				}
			}
			
			if(flag) {
				System.out.println("你输入的学号已经被占用,请重新输入");
			}else {
				break; //结束循环
			}
		}
		
		
		System.out.println("请输入学生姓名：");
		String name = sc.nextLine();
		System.out.println("请输入学生年龄：");
		String age = sc.nextLine();
		System.out.println("请输入学生居住地：");
		String address = sc.nextLine();
		
		//创建学生对象
		Student s = new Student();
		s.setId(id);
		s.setName(name);
		s.setAge(age);
		s.setAddress(address);
		
		//把学生对象作为元素添加到集合
		array.add(s);
		
		//给出提示
		System.out.println("添加学生成功");
	}
}
package com.itheima;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;

/*
 * 把上一题的文本文件中的学生信息读取出来存储到集合中，然后遍历集合，在控制台输出
 * 
 * 分析：
 * 		A:定义学生类
 * 		B:创建输入缓冲流对象
 * 		C:创建集合对象
 * 		D:读取文件数据，并把数据按照一定的格式进行分割赋值给学生对象，然后把学生对象作为元素存储到集合
 * 			heima001,向問天,30,北京
 * 		E:释放资源
 * 		F:遍历集合
 */
public class FileToArrayListTest {
	public static void main(String[] args) throws IOException {
		//创建输入缓冲流对象
		BufferedReader br = new BufferedReader(new FileReader("array.txt"));
		
		//创建集合对象
		ArrayList<Student> array = new ArrayList<Student>();
		
		//读取文件数据，并把数据按照一定的格式进行分割赋值给学生对象，然后把学生对象作为元素存储到集合
		String line;
		while((line=br.readLine())!=null) {
			//分割字符串
			String[] strArray = line.split(",");
			//创建学生对象并赋值
			Student s = new Student();
			s.setId(strArray[0]);
			s.setName(strArray[1]);
			s.setAge(strArray[2]);
			s.setAddress(strArray[3]);
			//把学生对象作为元素存储到集合
			array.add(s);
		}
		
		//释放资源
		br.close();
		
		//遍历集合
		System.out.println("学号\t\t姓名\t年龄\t居住地");
		for(int x=0; x<array.size(); x++) {
			Student s = array.get(x);
			System.out.println(s.getId()+"\t"+s.getName()+"\t"+s.getAge()+"\t"+s.getAddress());
		}
	}
}
package com.itheima;
/*
 * 标准的学生类
 */
public class Student {
	//学号
	private String id;
	//姓名
	private String name;
	//年龄
	private String age;
	//居住地
	private String address;
	
	public Student() {
		
	}

	public Student(String id, String name, String age, String address) {
		this.id = id;
		this.name = name;
		this.age = age;
		this.address = address;
	}

	public String getId() {
		return id;
	}

	public void setId(String id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getAge() {
		return age;
	}

	public void setAge(String age) {
		this.age = age;
	}

	public String getAddress() {
		return address;
	}

	public void setAddress(String address) {
		this.address = address;
	}
	
}
package com.itheima;
/*
 * 这是我的学生类
 */
public class Student {
	//学号
	private String id;
	//姓名
	private String name;
	//年龄
	private String age;
	//居住地
	private String address;
	
	public Student() {
		
	}

	public Student(String id, String name, String age, String address) {
		this.id = id;
		this.name = name;
		this.age = age;
		this.address = address;
	}

	public String getId() {
		return id;
	}

	public void setId(String id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getAge() {
		return age;
	}

	public void setAge(String age) {
		this.age = age;
	}

	public String getAddress() {
		return address;
	}

	public void setAddress(String address) {
		this.address = address;
	}
	
}
package com.itheima;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;

/*
 * 这是我的学生管理系统的主类
 * 
 * 步骤如下：
 * A:定义学生类
 * B:学生管理系统的主界面的代码编写
 * C:学生管理系统的查看所有学生的代码编写
 * D:学生管理系统的添加学生的代码编写
 * E:学生管理系统的删除学生的代码编写
 * F:学生管理系统的修改学生的代码编写
 */
public class StudentManagerTest {
	public static void main(String[] args) throws IOException{
		//定义文件路径
		String fileName = "students.txt";
		
		//为了让程序能够回到这里来，我们使用循环
		while(true) {
			//这是学生管理系统的主界面
			System.out.println("--------欢迎来到学生管理系统--------");
			System.out.println("1 查看所有学生");
			System.out.println("2 添加学生");
			System.out.println("3 删除学生");
			System.out.println("4 修改学生");
			System.out.println("5 退出");
			System.out.println("请输入你的选择：");
			//创建键盘录入对象
			Scanner sc = new Scanner(System.in);
			String choiceString = sc.nextLine();
			//用switch语句实现选择
			switch(choiceString) {
			case "1":
				//查看所有学生
				findAllStudent(fileName);
				break;
			case "2":
				//添加学生
				addStudent(fileName);
				break;
			case "3":
				//删除学生
				deleteStudent(fileName);
				break;
			case "4":
				//修改学生
				updateStudent(fileName);
				break;
			case "5":
			default:
				System.out.println("谢谢你的使用");
				System.exit(0); //JVM退出
				break;
			}
		}
	}
	
	//从文件中读数据到集合
	public static void readData(String fileName,ArrayList<Student> array) throws IOException {
		//创建输入缓冲流对象
		BufferedReader br = new BufferedReader(new FileReader(fileName));
		
		String line;
		while((line=br.readLine())!=null) {
			String[] datas = line.split(",");
			Student s = new Student();
			s.setId(datas[0]);
			s.setName(datas[1]);
			s.setAge(datas[2]);
			s.setAddress(datas[3]);
			array.add(s);
		}
		
		br.close();
	}
	
	//把集合中的数据写入文件
	public static void writeData(String fileName,ArrayList<Student> array) throws IOException {
		//创建输出缓冲流对象
		BufferedWriter bw = new BufferedWriter(new FileWriter(fileName));
		
		for(int x=0; x<array.size(); x++) {
			Student s = array.get(x);
			StringBuilder sb = new StringBuilder();
			sb.append(s.getId()).append(",").append(s.getName()).append(",").append(s.getAge()).append(",").append(s.getAddress());
			
			bw.write(sb.toString());
			bw.newLine();
			bw.flush();
		}
		
		bw.close();
	}
	
	//修改学生
	public static void updateStudent(String fileName) throws IOException {
		//创建集合对象
		ArrayList<Student> array = new ArrayList<Student>();
		//从文件中把数据读取到集合中
		readData(fileName, array);
		
		//修改学生的思路：键盘录入一个学号，到集合中去查找，看是否有学生使用的是该学号，如果有就修改该学生
		//创建键盘录入对象
		Scanner sc = new Scanner(System.in);
		System.out.println("请输入你要修改的学生的学号：");
		String id = sc.nextLine();
		
		//定义一个索引
		int index = -1;
		
		//遍历集合
		for(int x=0; x<array.size(); x++) {
			//获取每一个学生对象
			Student s = array.get(x);
			//拿学生对象的学号和键盘录入的学号进行比较
			if(s.getId().equals(id)) {
				index = x;
				break;
			}
		}
		
		if(index == -1) {
			System.out.println("不好意思,你要修改的学号对应的学生信息不存在,请回去重新你的选择");
		}else {
			System.out.println("请输入学生新姓名：");
			String name = sc.nextLine();
			System.out.println("请输入学生新年龄：");
			String age = sc.nextLine();
			System.out.println("请输入学生新居住地：");
			String address = sc.nextLine();
			
			//创建学生对象
			Student s = new Student();
			s.setId(id);
			s.setName(name);
			s.setAge(age);
			s.setAddress(address);
			
			//修改集合中的学生对象
			array.set(index, s);
			//把集合中的数据重新写回到文件
			writeData(fileName, array);
			//给出提示
			System.out.println("修改学生成功");
		}
	}
	
	//删除学生
	public static void deleteStudent(String fileName) throws IOException {
		//创建集合对象
		ArrayList<Student> array = new ArrayList<Student>();
		//从文件中把数据读取到集合中
		readData(fileName, array);
		
		//删除学生的思路：键盘录入一个学号，到集合中去查找，看是否有学生使用的是该学号，如果有就删除该学生
		//创建键盘录入对象
		Scanner sc = new Scanner(System.in);
		System.out.println("请输入你要删除的学生的学号：");
		String id = sc.nextLine();
		
		//我们必须给出学号不存在的时候的提示
		
		//定义一个索引
		int index = -1;
		
		//遍历集合
		for(int x=0; x<array.size(); x++) {
			//获取到每一个学生对象
			Student s = array.get(x);
			//拿这个学生对象的学号和键盘录入的学号进行比较
			if(s.getId().equals(id)) {
				index = x;
				break;
			}
		}
		
		if(index == -1) {
			System.out.println("不好意思,你要删除的学号对应的学生信息不存在,请回去重新你的选择");
		}else {
			array.remove(index);
			//把集合中的数据重新写回到文件
			writeData(fileName, array);
			System.out.println("删除学生成功");
		}
		
	}
	
	//添加学生
	public static void addStudent(String fileName) throws IOException {
		//创建集合对象
		ArrayList<Student> array = new ArrayList<Student>();
		//从文件中把数据读取到集合中
		readData(fileName, array);
				
		//创建键盘录入对象
		Scanner sc = new Scanner(System.in);
		
		//为了让id能够被访问到，我们就把id定义在了循环的外面
		String id;
		
		//为了让代码能够回到这里，用循环
		while(true) {
			System.out.println("请输入学生学号：");
			//String id = sc.nextLine();
			id = sc.nextLine();
			
			//判断学号有没有被人占用
			//定义标记
			boolean flag = false;
			//遍历集合，得到每一个学生
			for(int x=0; x<array.size(); x++) {
				Student s = array.get(x);
				//获取该学生的学号，和键盘录入的学号进行比较
				if(s.getId().equals(id)) {
					flag = true; //说明学号被占用了
					break;
				}
			}
			
			if(flag) {
				System.out.println("你输入的学号已经被占用,请重新输入");
			}else {
				break; //结束循环
			}
		}
		
		
		System.out.println("请输入学生姓名：");
		String name = sc.nextLine();
		System.out.println("请输入学生年龄：");
		String age = sc.nextLine();
		System.out.println("请输入学生居住地：");
		String address = sc.nextLine();
		
		//创建学生对象
		Student s = new Student();
		s.setId(id);
		s.setName(name);
		s.setAge(age);
		s.setAddress(address);
		
		//把学生对象作为元素添加到集合
		array.add(s);
		//把集合中的数据重新写回到文件
		writeData(fileName, array);
		
		//给出提示
		System.out.println("添加学生成功");
	}
	
	//查看所有学生
	public static void findAllStudent(String fileName) throws IOException {
		//创建集合对象
		ArrayList<Student> array = new ArrayList<Student>();
		//从文件中把数据读取到集合中
		readData(fileName, array);
		
		//首先来判断集合中是否有数据，如果没有数据，就给出提示，并让该方法不继续往下执行
		if(array.size() == 0) {
			System.out.println("不好意思,目前没有学生信息可供查询,请回去重新选择你的操作");
			return;
		}
		
		//\t 其实就是一个tab键的位置
		System.out.println("学号\t\t姓名\t年龄\t居住地");
		for(int x=0; x<array.size(); x++) {
			Student s = array.get(x);
			System.out.println(s.getId()+"\t"+s.getName()+"\t"+s.getAge()+"\t"+s.getAddress());
		}
	}
}
package com.itheima_01;
/*
 * static:是一个关键字，用于修饰成员变量和成员方法
 * static的特点：
 * 			被所有的对象所共享
 * 			可以使用类名调用
 * 			静态的加载优先于对象
 * 			随着类的加载而加载
 * 
 */
public class StaticDemo {
	public static void main(String[] args) {
		Person.graduateFrom = "传智学院";
		
		Person p = new Person();
		p.name = "小苍同学";
		p.age = 18;
		//p.graduateFrom = "传智学院";
		p.speak();
		
		Person p2 = new Person();
		p2.name = "小波同学";
		p2.age = 20;
		//p2.graduateFrom = "传智学院";
		p2.speak();
	}
}

class Person {
	String name;
	int age;
	static String graduateFrom;//毕业院校
	
	public void speak() {
		System.out.println(name + "---" + graduateFrom);
	}
}
package com.itheima_01;
/*
 * static的注意事项：
 * 			静态方法：
 * 				可以调用静态的成员变量
 * 				可以调用静态的成员方法
 * 				不可以调用非静态成员变量
 * 				不可以调用非静态成员方法
 * 				静态方法只能调用静态的成员
 * 			非静态方法：
 * 				可以调用静态的成员变量
 * 				可以调用静态的成员方法
 * 				可以调用非静态的成员变量
 * 				可以调用非静态的成员方法
 * 		
 * 	静态的方法中是否有this这个对象？没有的
 * 				
 * 
 */
public class StaticDemo2 {
	public static void main(String[] args) {
		Student.graduateFrom = "传智学院";
		Student.study();
	}
}


class Student {
	String name;
	int age;
	static String graduateFrom;//毕业院校
	
	public static void study() {
		///System.out.println(graduateFrom);
		//sleep();
		
		//System.out.println(name);
		
		//eat();
		
	}
	
	public static void sleep() {
		System.out.println("sleep");
		
	}
	
	public void eat() {
		System.out.println("eat");
		
		System.out.println(graduateFrom);
		sleep();
		
		
	}
	
}
package com.itheima_02;

public class MathDemo {
	public static void main(String[] args) {
		//Math:包含了一些基本的数学运算方法
		//static double PI  
		//System.out.println(Math.PI);
		
		//static double abs(double a)  :返回绝对值
		//System.out.println(Math.abs(15));
		//System.out.println(Math.abs(-10));
		
		//static double ceil(double a) 天花板   向上取整
		//System.out.println(Math.ceil(1.2));
		//System.out.println(Math.ceil(1.6));
		//static double floor(double a)  地板  向下取整
		//System.out.println(Math.floor(1.2));
		//System.out.println(Math.floor(1.6));
		
		//static long round(double a)  ：四舍五入
		//System.out.println(Math.round(1.2));
		//System.out.println(Math.round(1.6));
		
		//static double max(double a, double b) 
		//System.out.println(Math.max(3, 4));
		
		//static double pow(double a, double b) :返回第一个参数的第二个参数次幂
		//System.out.println(Math.pow(3, 2));
		
		//static double random() :返回一个随机数，大于零且小于一
		System.out.println(Math.random());
		
		
		 
	}
}
package com.itheima_03;

public class MyArrays {
	private MyArrays() {} 
	
	/*
	 * 返回数组中最大的元素
	 * 
	 */
	public static int getMax(int[] arr) {
		int max = 0;//参照物
		//遍历数组
		for(int x = 0;x < arr.length;x++) {
			if(arr[x] > max) {
				max = arr[x];//替换参照物
			}
		}
		
		return max;
	}
	
	
	/*
	 * 返回数组中指定参数的索引
	 * 
	 */
	
	public static int getIndex(int[] arr,int a) {
		//遍历数组
		for(int x = 0;x < arr.length;x++) {
			if(arr[x] == a) {
				return x;
			}
		}
		
		return -1;//如果查不到制定的参数，则返回-1
	}
}
package com.itheima_03;

public class MyArraysDemo {
	public static void main(String[] args) {
		int[] arr = {3,5,8,10,1};
		int max = MyArrays.getMax(arr);
		System.out.println(max);
		
		int index = MyArrays.getIndex(arr, 8);
		System.out.println(index);
		
		
	}
}
package com.itheima_04;

public class BlockDemo {
	public static void main(String[] args) {
		
		//局部代码块：存在于方法中，控制变量的生命周期（作用域）
		/*{
			for(int x = 0;x < 10;x++) {
				System.out.println("我爱Java");
			}
			int num = 10;
		}
		System.out.println(num);*/
		
		Teacher t = new Teacher();
		Teacher t2 = new Teacher("小苍老师",18);
	}
}

class Teacher {
	String name;
	int age;
	
	//构造代码块：提取构造方法中的共性，每次创建对象都会执行，并且在构造方法执行之前执行
	/*{
		for(int x = 0;x < 10;x++) {
			System.out.println("我爱Java");
		}
		System.out.println("我爱Java");
	}*/
	
	//静态代码块：随着类的加载而加载，只加载一次，加载类时需要做的一些初始化，比如加载驱动
	static {
		System.out.println("我爱Java");
	}
	
	public Teacher() {
		System.out.println("我是无参空构造");
	}
	
	public Teacher(String name,int age) {
		System.out.println("我是有参构造");
		
		this.name = name;
		this.age = age;
	}
	
	
}
package com.itheima_04;

/*
 *   Coder静态代码块执行 --- Coder构造代码块执行 --- Coder无参空构造执行
 *   
 *   
 *   BlockTest静态代码块执行 --- BlockTest的主函数执行了 --- Coder静态代码块执行 --- Coder构造代码块执行 --- Coder无参空构造执行
 *   Coder构造代码块执行 --- Coder无参空构造执行
 * 
 */
public class BlockTest {
	static {
		System.out.println("BlockTest静态代码块执行");
	}
	
	{
		System.out.println("BlockTest构造代码块执行");
	}
	

	public BlockTest(){
		System.out.println("BlockTest无参构造执行了");
	}
	
	public static void main(String[] args) {
		System.out.println("BlockTest的主函数执行了");
		Coder c = new Coder();
		Coder c2 = new Coder();
	}
}

class Coder {
	
	static {
		System.out.println("Coder静态代码块执行");
	}
	
	{
		System.out.println("Coder构造代码块执行");
	}
	
	public Coder() {
		System.out.println("Coder无参空构造执行");
	}	
	
}
package com.itheima_01;
/*
 * 需求：定义一个方法求两个数的和,并在主方法中调用
 * 
 * 方法：类中的一段具有特定功能的程序，提高了代码的复用性和可维护性
 * 定义格式：
 * 			public static 返回值类型（没有返回值写void） 方法名(参数类型 参数名,参数类型 参数名2) {//形参
 * 				方法体;
 * 			}
 * 调用方式：
 * 		有明确返回值类型：
 * 					赋值调用，将方法的返回值赋值给一个变量
 * 					输出调用，使用输出语句直接输出方法的返回值
 * 					直接调用，没法获取方法的返回值
 * 		没有明确返回值类型：
 * 					直接调用
 * 方法重载：在一个类中有多个重名的方法，这些方法参数不同，和返回值无关
 * 
 * 注意：
 * 		形参：方法声明的变量，只能是变量，接收方法调用时传递进来的数据
 * 		实参：调用方法时传递的数据，可以是常量也可以是变量
 * 
 */
public class MethoDemo {
	public static void main(String[] args) {
		//赋值调用
		//int sum = sum(10,20);//实参
		//System.out.println(sum);
		
		//输出调用
		int a = 10;
		int b = 20;
		System.out.println(sum(a,b));
	}
	
	public static int sum(int a,int b) {
	/*	//使用变量接收求和结果并返回
		int sum = a + b;
		return sum;*/
		
		//直接返回求和结果
		return a + b;
	}
	
}
package com.itheima_02;
/*
 * 需求：定义一个元素类型为int的数组，遍历数组并求和
 * 		
 * 数组：用于存储多个元素的一种容器
 * 数组的特点:
 * 			元素类型必须一致
 * 			元素有整数索引
 * 			一旦定义好长度则无法改变
 * 			可以存储基本数据类型
 * 			也可以存储引用数据类型
 * 定义格式：
 * 			动态初始化
 * 				元素类型[] 数组名 = new 元素类型[10];
 * 			静态初始化
 * 				元素类型[] 数组名 = {元素1,元素2,元素3};
 * 				元素类型[] 数组名  = new 元素类型[]{元素1,元素2,元素3};
 * 
 */
public class ArrayDemo {
	public static void main(String[] args) {
		//使用静态初始化定义数组
		int[] arr = {1,2,3,4,5};
		//定义一个变量用于存储求和结果
		int sum = 0;
		//遍历数组
		for(int x = 0;x < arr.length;x++) {
			sum += arr[x];
		}
		
		System.out.println(sum);
	}
	
	

}
package com.itheima_03;
/*
 * 定义一个标准的学生类，在主方法中创建对象并调用
 * 			姓名，年龄，性别3个成员变量
 * 			无参，有参两个构造方法
 * 			为每个成员变量定义getter/setter方法
 * 			定义一个show方法，输出成员变量
 */
public class Student {
	private String name;//姓名
	private int age;//年龄
	private String gender;//性别
	
	/*//无参构造
	public Student() {}
	//有参构造
	public Student(String name,int age,String gender) {
		this.name = name;
		this.age = age;
		this.gender = gender;
	}
	
	//name
	public String getName() {
		return name;
	}
	
	public void setName(String name) {
		this.name = name;
	}
	
	//age
	public int getAge() {
		return age;
	}
	
	public void setAge(int age) {
		this.age = age;
	}
	
	//gender
	public String getGender() {
		return gender;
	}
	
	public void setGender(String gender) {
		this.gender = gender;
	}*/
	
	
	
	//show：用于输出所有的成员变量
	public void show() {
		System.out.println(name + "," + age + "," + gender);
	}

	public Student() {
		super();
		// TODO Auto-generated constructor stub
	}

	public Student(String name, int age, String gender) {
		super();
		this.name = name;
		this.age = age;
		this.gender = gender;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	public String getGender() {
		return gender;
	}

	public void setGender(String gender) {
		this.gender = gender;
	}
	
	
}
package com.itheima_03;

public class StudentTest {
	public static void main(String[] args) {
		//创建学生对象
		Student s = new Student();
		//为成员变量进行赋值
		s.setName("张三");
		s.setAge(18);
		s.setGender("男");
		s.show();
		
		System.out.println("----------");
		
		Student s2 = new Student("李四",20,"其他");
		//s2.show();
		System.out.println(s2.getName());
	}
}
package com.itcast.day01;

public class ArrayUtils {
	// 8.使用静态的特点定义一个工具类专门用于操作数组的, 这个工具类有以下功能
	// 1)可以将整数类型的数组中的最大值找到
	// 2)可以将整数类型的数组中的最小值找到
	// 3)可以遍历一个整数数组;
	// 4)可以求出数组中最大值的角标
	// 5)可以求出数组中最小值的角标;
	// 6)可以对整数类型的数组进行排序

	private ArrayUtils() {

	}

	// 1)可以将整数类型的数组中的最大值找到
	public static int getMax(int[] arr) {
		int max = arr[0];// 假设第一元素是最大值
		for (int i = 1; i < arr.length; i++) {
			int j = arr[i];
			if (j > max) {
				max = j;
			}
		}
		return max;
	}

	// 2)可以将整数类型的数组中的最小值找到
	public static int getMin(int[] arr) {
		int min = arr[0];
		for (int i = 1; i < arr.length; i++) {
			int j = arr[i];
			if (j < min) {// 如果j比我的min还小.证明我假设错了.需要替换
				min = j;

			}
		}
		return min;
	}
	// 3)可以遍历一个整数数组;

	public static void printArr(int[] arr) {
		for (int i = 0; i < arr.length; i++) {// [12,243,45,345];

			if (i == 0) {
				System.out.print("[" + arr[i]);
			} else if (i == arr.length - 1) {
				System.out.print("," + arr[i] + "]");
			} else {
				System.out.print("," + arr[i]);
			}
		}
	}

	// 4)可以求出数组中最大值的角标
	public static int getMaxIndex(int[] arr) {// int [] arr ={23,3455,87,95,346}
		int maxIndex = 0;// 我假设0角标就是最大值//1
		for (int i = 1; i < arr.length; i++) {
			int j = arr[maxIndex];// 我认为最大的元素 3455
			int m = arr[i];// 87
			if (m > j) {
				maxIndex = i;
			}

		}
		
		
		return maxIndex;

	}

	// 5)可以求出数组中最小值的角标;
	public static int getMinIndex(int[] arr) {// int [] arr ={23,3455,87,95,346}
		int minIndex = 0;// 我假设0角标就是最大值//1
		for (int i = 1; i < arr.length; i++) {
			int j = arr[minIndex];// 我认为最大的元素 3455
			int m = arr[i];// 87
			if (m < j) {
				minIndex = i;
			}

		}
		return minIndex;

	}
	// 6)可以对整数类型的数组进行排序

	public static void sortArr(int[] arr) {
		/*
		 * for (int i = 0; i < arr.length - 1; i++) { // 取出左边的 int j = arr[i];
		 * // 取出右边的 int k = arr[i + 1]; if (j > k) { int temp = arr[i]; arr[i] =
		 * arr[i + 1]; arr[i + 1] = temp;
		 * 
		 * } }
		 */

		for (int x = 0; x < arr.length - 1; x++) {
			for (int i = 0; i < arr.length - 1 - x; i++) {
				// 取出左边的
				int j = arr[i];
				// 取出右边的
				int k = arr[i + 1];
				if (j > k) {
					int temp = arr[i];
					arr[i] = arr[i + 1];
					arr[i + 1] = temp;
				}
			}
		}
	}

}
package com.itcast.day01;

public class Car {

	// 品牌
	private String brand;

	public String getBrand() {
		return brand;
	}

	public void setBrand(String brand) {
		this.brand = brand;
	}

	public String getColor() {
		return color;
	}

	public void setColor(String color) {
		this.color = color;
	}

	public int getWheelNumber() {
		return wheelNumber;
	}

	public void setWheelNumber(int wheelNumber) {
		this.wheelNumber = wheelNumber;
	}

	// 颜色
	private String color;
	// 轮子个数
	private int wheelNumber;

	public Car(String brand, String color, int wheelNumber) {
		super();
		this.brand = brand;
		this.color = color;
		this.wheelNumber = wheelNumber;
	}

	public Car() {
		super();
	}

	public void show() {
		System.out.println("这个是" + color + "色" + wheelNumber + "个轮子的" + brand + "汽车");
	}

}
package com.itcast.day01;

public class Man {

	private String name;

	/*
	 * {// 当我们调用我们的构造函数的时候,这个构造代码块就会执行 System.out.println("我很帅,我全都是18"); }
	 */

	static {// 当我们调用我们的构造函数的时候,这个构造代码块就会执行
		System.out.println("我很帅,我全都是18");
	}

	private int age;
	private String color;

	public Man(String name, int age, String color) {
		super();
		this.name = name;
		this.age = age;
		this.color = color;
	}

	public Man() {
		super();
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	public String getColor() {
		return color;
	}

	public void setColor(String color) {
		this.color = color;
	}

}
package com.itcast.day01;

public class Person {
	private String name;
	private String sex;
	private int age ;
	public Person() {
		
	}
	public Person(String name, String sex, int age) {
		
		this.name = name;
		this.sex = sex;
		this.age = age;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getSex() {
		return sex;
	}
	public void setSex(String sex) {
		this.sex = sex;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	
	
	
	
}
package com.itcast.day01;

public class Person1 {
	public static void main(String[] args) {
		Person[] arr = new Person[5];
		Person p = new Person("小青", "女", 19);
		Person p1 = new Person("小白", new String("女"), 19);
		Person p2 = new Person("小红", new String("女"), 18);
		Person p3 = new Person("小黑", "男", 19);
		Person p4 = new Person("小王", "男", 19);
		arr[0] = p;
		arr[1] = p1;
		arr[2] = p2;
		arr[3] = p3;
		arr[4] = p4;
		int count = 0;
		for (int i = 0; i < arr.length; i++) {
			if (arr[i].getSex() .equals("女")) {//==地址值, equal比较内容;
				if (arr[i].getAge() > 18) {
					count++;
				}
			}
		}
		System.out.println(count);
	}
}
package com.itcast.day01;

import java.util.Random;

public class SelectStudent {

	public static void main(String[] args) {
		int row = 0;
		int colum = 0;

		Random random = new Random();
		row = random.nextInt(11) + 1;

		if (row == 1) {
			colum = random.nextInt(7) + 1;
		} else if (row == 11 || row == 10) {
			colum = random.nextInt(5) + 1;
		} else {
			colum = random.nextInt(8) + 1;
		}
		System.out.println("幸运的同学是第" + row + "排,第" + colum + "列的同学");
	}

}
package com.itcast.day01;

import java.util.Random;
import java.util.Scanner;

public class Test1 {

	// 实现猜测游戏, 游戏规则,随机生成一个1-100内的整数, 然后键盘录入一个数
	// 如果就提示用户"这个数比我们随机的数大输入的数大了", 当然如果用户输入的
	// 数比我们
	// 随机生成的数小的话就提示"输入的数小了",直到用户输对为止;

	public static void main(String[] args) {
		// 需要Random随机数对象
		Random random = new Random();
		int number = random.nextInt(100) + 1;
		// 创建Scanner对象
		Scanner scanner = new Scanner(System.in);
		// 我们需要定义变量来记录不断变化的次数
		int count = 0;
		while (true) {
			System.out.println("请输入一个1-100的整数");
			int input = scanner.nextInt();
			count++;
			if (input > number) {
				System.out.println("你输入的大了");

			} else if (input < number) {
				System.out.println("你输入的小了");
			} else {
				System.out.println("你猜中,真幸运");
				break;
			}

		}
		System.out.println(count);

	}

}
package com.itcast.day01;

public class Test10 {
	
	

}
package com.itcast.day01;

public class Test2 {

	public static void main(String[] args) {
		int[] arr = { 23, 34, 45, 5, 78 };
		arr[2] = 521;

		for (int i = 0; i < arr.length; i++) {// 第一次走的循环的初始化变量 ,这个只走一次,
												// 紧接着看条件满足不,如果满足就执行一次循环体,
												// 然后在循环后的操作
												// 然后在看判断语句是否满足,如果满足执行循环体,
												// 知道不满足为止;

			System.out.println(arr[i]);

		}
	}

}
package com.itcast.day01;

public class Test3 {

	// 5.现在已知数组int[] arr = {12,34,465,3,45};
	// 要求创建一个新的数组,将arr的元素倒序放入新数组中,
	// 然后求出数组中的最大值是多少?然后求出最大值的角标是第几个

	public static void main(String[] args) {
		int[] arr = { 12, 34, 465, 3, 45 };
		int[] newArr = new int[arr.length];
//		for (int i = 0; i < newArr.length; i++) {
//			newArr[i] = arr[i];
//		}
		
		for (int i = 0; i < newArr.length; i++) {
			newArr[i] = arr[arr.length-1-i]; 
		}

		for (int i = 0; i < newArr.length; i++) {
			System.out.println(newArr[i]);
		}

	}

}
package com.itcast.day01;

public class Test4 {

	public static void main(String[] args) {
		int []arr={12,322,34,424,33};
		int[]newarr=new int[arr.length];
		for (int i = 0; i < newarr.length; i++) {
			newarr[i]=arr[arr.length-1-i];
		}
		for (int i = 0; i < newarr.length; i++) {
			System.out.println(newarr[i]);
		}
	}
}
package com.itcast.day01;

public class Test5 {

	public static void main(String[] args) {
//		Car car = new Car("法拉利", "黄", 2);
//		car.show();
//
//		Car car2 = new Car();
//		car2.setBrand("奔驰");
//		car2.setColor("红");
//		car2.setWheelNumber(5);
//		car2.show();
//
//		getSum(10, 20);
		
		Test5 test5 = new Test5();
		test5.getSum(10, 20);
		
		String valueOf = String.valueOf(10);
		
	}

	public void getSum(int a, int b) {
		System.out.println(a + b);
	}

}
package com.itcast.day01;

public class Test6 {

	// 8.使用静态的特点定义一个工具类专门用于操作数组的, 这个工具类有以下功能
	// 1)可以将整数类型的数组中的最大值找到
	// 2)可以将整数类型的数组中的最小值找到
	// 3)可以遍历一个整数数组;
	// 4)可以求出数组中最大值的角标
	// 5)可以求出数组中最小值的角标;
	// 6)可以对整数类型的数组进行排序

	public static void main(String[] args) {
		int[] arr = { 234, 123, 64, 2, 57689, 23 };

		System.out.println("数组中最大值是" + ArrayUtils.getMax(arr));
		;
		System.out.println("数组中最小值是" + ArrayUtils.getMin(arr));
		;
		System.out.println("数组中最大值的角标是" + ArrayUtils.getMaxIndex(arr));
		;
		System.out.println("数组中最小值的角标是" + ArrayUtils.getMinIndex(arr));
		;
		ArrayUtils.sortArr(arr);
		ArrayUtils.printArr(arr);

	}

}
package com.itcast.day01;

public class Test7 {

	public static void main(String[] args) {
		{// 局部代码块
			int x = 10;//限制变量的使用范围;
		}

		//System.out.println(x);
	}

}
package com.itcast.day01;

public class Test8 {

	public static void main(String[] args) {
		Man man = new Man();
		Man man1 = new Man();

	}

}
package com.itcast.day01;

public class Test9 {
	//定义一个Person类, person类有 姓名, 年龄, 性别; 请使用标准类的方式实现这个类
	//创建一个长度为5的数组, 然后创建五个person对象存入数组中
	//求这个数组中年龄大于18的女生有多少个?
	

}
1. int x = 10; 
   int y = x++;
   int z = x++ + --y + x;

	求z的值
2. 键盘录入两个整数,分别赋值给int变量x,y然后比较x和y的大小
3. 实现猜测游戏, 游戏规则,随机生成一个1-100内的整数, 然后键盘录入一个数
如果这个数比我们随机的数大就提示用户"输入的数大了", 当然如果用户输入的数比我们
随机生成的数小的话就提示"输入的数小了",直到用户输对为止;
4.统计第三题用户猜的次数
5.现在已知数组int[] arr = {12,34,465,3,45};
要求创建一个新的数组,将arr的元素倒序放入新数组中,
然后求出数组中的最大值是多少?然后求出最大值的角标是第几个
6.将第五题中最大值和最小值的位置进行交换;
7.定义中国人类, 中国人都有国籍,并且值是中国, 有年龄,姓名,性别;
8.使用静态的特点定义一个工具类专门用于操作数组的, 这个工具类有以下功能
  1)可以将整数类型的数组中的最大值找到
  2)可以将整数类型的数组中的最小值找到
  3)可以遍历一个整数数组;
  4)可以求出数组中最大值的角标
  5)可以求出数组中最小值的角标;
  6)可以对整数类型的数组进行排序
9.能够说出代码块特点



package com.itheima_01;
/*
 * 继承：多个类有共同的成员变量和成员方法，抽取到另外一个类中（父类），在让多个类去继承这个父类，我们的多个类就可以获取到父类中的成员了。
 * extends
 * 
 */
public class ExtendsDemo {
	public static void main(String[] args) {
		DotA d = new DotA();
		d.start();
		
		LOL l = new LOL();
		l.start();
	}
}

class Game {
	String name;
	double version;//版本号
	String agent;//代理商
	
	public void start() {
		System.out.println("游戏启动了");
	}
	
	public void stop() {
		System.out.println("游戏关闭了");
	}
}

class DotA extends Game {
	/*String name;
	double version;//版本号
	String agent;//代理商
	
	public void start() {
		System.out.println("游戏启动了");
	}
	
	public void stop() {
		System.out.println("游戏关闭了");
	}*/
}

class LOL extends Game {
	/*String name;
	double version;//版本号
	String agent;//代理商
	
	public void start() {
		System.out.println("游戏启动了");
	}
	
	public void stop() {
		System.out.println("游戏关闭了");
	}*/
	
}
package com.itheima_02;
/*
 * Java中继承的特点：
 * 			Java语言只支持单一继承，只能继承一个父类（一个儿子只能有一个亲爹）
 * 			Java语言支持多层继承（一个儿子可以有一个亲爹，还可以有一个亲爷爷）
 * 
 */
public class ExtendsDemo2 {
	public static void main(String[] args) {
		LOL l = new LOL();
		l.update();
		l.start();
	}
}

class Game {
	public void start() {
		System.out.println("游戏启动了");
	}
}

class PCGame extends Game {
	public void update() {
		System.out.println("PCGame更新了");
	}
}

class MobileGame extends Game {
	public void update() {
		System.out.println("MobileGame更新了");
	}
}

class LOL extends PCGame {
	
}
package com.itheima_02;
/*
 * 继承中成员变量的特点
 * 		子类只能获取父类非私有成员
 * 		子父类中成员变量的名字不一样直接获取父类的成员变量
 * 		子父类中成员变量名字是一样的获取的是子类的成员变量
 * 
 * 就近原则：谁离我近我就用谁
 * 		如果有局部变量就使用局部变量
 * 		如果没有局部变量，有子类的成员变量就使用子类的成员变量
 * 		如果没有局部变量和子类的成员变量，有父类的成员变量就使用父类的成员变量
 * 		啥都没有，出错了！！！
 * 
 * super:可以获取父类的成员变量和成员方法,用法和this是相似的
 */
public class ExtendsDemo3 {
	public static void main(String[] args) {
		Kid3 k = new Kid3();
		k.show();
	}
}

class Dad3 {
	String name = "建霖";
}

class Kid3 extends Dad3 {
	String name = "四葱";
	
	public void show() {
		String name = "五葱";
		
		System.out.println(super.name);
		System.out.println(this.name);
		System.out.println(name);
	}
}
package com.itheima_02;
/*
 * 继承中成员方法的特点
 * 		子类中没有这个方法，调用父类的
 * 		子类中重写了这个方法，调用子类的
 * 
 
 	方法的重写：在子父类当中，子类的方法和父类的完全一样，子类重写了父类的方法（覆盖），当子类重写了父类的方法之后，使用子类对象调用的就是子类的方法
 	方法的重载：在一个类中，有多个重名的方法，但是其参数不一样（参数的个数，参数的类型，参数的顺序），和返回值无关
 
 */
public class ExtendsDemo4 {
	public static void main(String[] args) {
		Kid4 k = new Kid4();
		k.eat();
	}
}

class Dad4 {
	public void eat() {
		System.out.println("小酌两口");
		System.out.println("去睡觉了");
	}
}

class Kid4 extends Dad4 {
	public void eat() {
		System.out.println("好好吃饭");
	}
}

package com.itheima_03;
/*
 * 	方法重写的应用场景：当父类的方法不能完全满足子类使用，这个时候子类重写父类的方法，
 * 				    并可以在方法中使用关键字super调用父类的方法，这样做即可以保有父类的功能，也可以拥有子类特有的功能
 *  方法重写的注意事项：
 *  			  不能重写父类私有的方法
 *  			 权限必须大于等于父类方法的权限
 *  
 *  注解：@
 *  
 */
public class ExtendsDemo5 {
	public static void main(String[] args) {
		NewPhone np = new NewPhone();
		np.call();
	}
}

class Phone {
	void call() {
		System.out.println("打电话");
	}
}

class NewPhone extends Phone {
	
	@Override
	public void call() {
		System.out.println("录音");
		//System.out.println("打电话");
		
		//super.call();
	}
}
package com.itheima_03;
/*
 * 继承中构造方法的执行顺序
 * 			在子父类中，创建子类对象，调用子类的构造方法，
 * 			在子类的构造方法的第一行代码如果没有调用父类的构造或者没有调用子类的其他构造，则默认调用父类无参构造
 * 为什么要调用父类构造？
 * 			因为需要给父类的成员变量初始化
 * 肯定会先把父类的构造执行完毕，在去执行子类构造中的其他代码
 * 
 * 我是父类无参构造 --- 我是子类有参构造 --- 我是子类无参构造
 */
public class ExtendsDemo6 {
	public static void main(String[] args) {
		//Die d = new Die();
		Zi6 z = new Zi6();
	}
}

class Die6 {
	public Die6() {
		System.out.println("我是父类无参构造");
	}
	
	public Die6(int num) {
		System.out.println("我是父类有参构造");
	}
}

class Zi6 extends Die6 {
	public Zi6() {
		//super(1);
		//super();
		
		this(1);//不会再调用父类的无参构造了
		
		System.out.println("我是子类无参构造");
	}
	
	public Zi6(int num) {
		//会默认调用父类无参构造
		System.out.println("我是子类有参构造");
	}
}
package com.itheima_03;
/*
 * this和super的区别
		this:当前对象的引用
			调用子类的成员变量
			调用子类的成员方法
			在子类的构造方法第一行调用子类其他构造方法
		super:子类对象的父类引用
			调用父类的成员变量
			调用父类的成员方法
			在子类的构造方法第一行调用父类的构造方法
			
			

 */
public class ExtendsDemo7 {
	public static void main(String[] args) {
		Zi z = new Zi();
		z.function();
	}
}

class Die {
	int num = 10;
	
	public Die() {
		System.out.println("我是父类无参构造");
	}
	
	public Die(int num) {
		System.out.println("我是父类有参构造");
	}
	
	public void method() {
		System.out.println("我是父类的方法");
	}
}


class Zi extends Die {
	//int num = 30;
	
	public Zi() {
		//this(1);//第一行不调用子类其他构造或者是父类构造，默认调用父类无参构造
		super();
		System.out.println("我是子类无参构造");
	}
	
	public Zi(int num) {
		System.out.println("我是子类有参构造");
	}
	
	public void method() {
		System.out.println("我是子类的方法");
	}
	
	public void function() {
		//this.num = 50;
		//System.out.println(num);
		//this.method();
		
		//super.num = 40;
		//super.method();
		
		System.out.println(this.num);
	}
}


package com.itheima_01;
/*
 * abstract:关键字，用于修饰方法和类
 * 抽象方法：不同类的方法是相似，但是具体内容又不太一样，所以我们只能抽取他的声明，没有具体的方法体，没有具体方法体的方法就是抽象方法
 * 抽象类：有抽象方法的类必须是抽象类
 * 
 * 注意：一个类继承了抽象类需要重写他所有的抽象方法,否则这个类就得是抽象类
 */
public class AbstractDemo {

}

abstract class Animal {
	public abstract void eat();
	
	//非抽象方法子类可以不重写
	public void run() {
		
	}
}

class Cat extends Animal {

	@Override
	public void eat() {
		System.out.println("猫吃鱼");
		
	}
	
	/*public void eat() {
		System.out.println("猫吃鱼");
	}*/
}

abstract class Dog extends Animal {
	/*public void eat() {
		System.out.println("狗吃屎");
	}*/
}
package com.itheima_02;
/*
 * 抽象类的特点：
 * 		抽象方法只能在抽象类里面
 * 		抽象类和抽象方法必须被abstract修饰
 * 		抽象类不能创建对象（不能实例化）
 * 		抽象类中可以有非抽象的方法
 * 		抽象类和类的关系也是继承
 * 		一个类继承了抽象类要么重写所有的抽象方法，要么他自己是抽象类
 */
public class AbstractDemo2 {
	public static void main(String[] args) {
		//Animal a = new Animal();
	}
}

abstract class Animal {
	public abstract void eat();
	
	public void run() {
		
	}
}

class Cat extends Animal {

	@Override
	public void eat() {
		// TODO Auto-generated method stub
		
	}

}
package com.itheima_03;
/*
 * 抽象类的成员特点：
 * 		成员变量
 * 			可以有成员变量
 * 			可以有常量
 * 		成员方法
 * 			可以有抽象方法
 * 			可以有非抽象方法
 * 		构造方法
 * 			可以有构造方法的，需要对抽象类的成员变量进行初始化
 * 
 * final:修饰类、成员变量、成员方法
 */
public class AbstractDemo3 {
	public static void main(String[] args) {
		Dog d = new Dog();
		d.barking();
	}
}

abstract class Animal {
	String name = "哮天犬";
	final int num = 10;
	
	public Animal() {
		System.out.println("我是抽象类的构造方法");
	}
	
	public abstract void eat();
	
	public void run() {}
}

class Dog extends Animal {
	public void barking() {
		System.out.println(name);
		System.out.println(num);
	}

	@Override
	public void eat() {
		// TODO Auto-generated method stub
		
	}
}


package com.itheima_04;
/*
 *	基础班老湿，就业班老湿
 *
 *	共性：
 *		属性	姓名，年龄，性别
 *		行为	讲课，唱歌
 */
public class AbstractTest {
	public static void main(String[] args) {
		BasicTeacher bt = new BasicTeacher();
		bt.name = "风清扬";
		bt.teach();
		
		JobTeacher jt = new JobTeacher();
		jt.name = "苍老师";
		jt.teach();
	}
}

abstract class Teacher {
	
	String name;//姓名
	int age;//年龄
	String gender;//性别
	
	//讲课
	public abstract void teach();
}

class BasicTeacher extends Teacher {

	@Override
	public void teach() {
		System.out.println(name + "讲基础班课程");
		
	}
	
}

class JobTeacher extends Teacher {

	@Override
	public void teach() {
		System.out.println(name + "讲就业班课程");
	}
	
}

package com.itheima_04;
/*
 *	雇员(Employee)示例：
	需求：
		公司中 
			程序员(programmer)有姓名(name)，工号(id)，薪水(pay)，工作内容(work)。
			项目经理(Manager)除了有姓名(name)，工号(id)，薪水(pay)，还有奖金(bonus)，工作内容(work)
			
	员工：
		属性 name，id，pay
		行为 work
 */
public class AbstractTest2 {
	public static void main(String[] args) {
		Programmer p = new Programmer();
		p.work();
		
		Manager m = new Manager();
		m.work();
	}
}

abstract class Employee {
	String name;//姓名
	String id;//id
	double pay;//薪水
	
	//工作
	public abstract void work();
	
}

class Programmer extends Employee {

	@Override
	public void work() {
		System.out.println("写代码");
	}
	
}

class Manager extends Employee {
	byte bonus;
	
	@Override
	public void work() {
		System.out.println("盯着程序员写代码");
	}
	
}
 
package com.itheima_04;
/*
 *	足疗店
 *		技师
 *			足疗技师
 *			其他技师
 *
 *	共性：
 *		属性  姓名，年龄
 *		行为  服务
 */
public class AbstractTest3 {
	public static void main(String[] args) {
		足疗技师 zl = new 足疗技师();
		zl.service();
		
		其他技师 qt = new 其他技师();
		qt.service();
	}
}

abstract class 技师 {
	String name;//姓名
	int age;//年龄
	
	//服务
	public abstract void service();
}

class 足疗技师 extends 技师 {

	@Override
	public void service() {
		System.out.println("按按脚揉揉肩");
	}
	
}

class 其他技师 extends 技师 {

	@Override
	public void service() {
		System.out.println("你懂的");
	}
	
}

 
package com.itheima_01;
/*
 * final： 修饰符，可以用于修饰类、成员方法和成员变量
 * final所修饰的类：不能被继承，不能有子类
 * final所修饰的方法:不能被重写
 * final所修饰的变量：是不可以修改的，是常量
 * 
 * 常量：
 * 		字面值常量：1,2,3
 * 		自定义常量：被final所修饰的成员变量，一旦初始化则不可改变
 * 
 * 注意：自定义常量必须初始化，可以选择显示初始化或者构造初始化
 * 
 *  
 */
public class FinalDemo {
	public static void main(String[] args) {
		//Animal a = new Animal();
		//a.eat();
		
		Dog d = new Dog();
		//d.eat();
		
		//d.num = 20;
		System.out.println(d.NUM);
	}
}

/*final*/ class Animal {
	public final void eat() {
		System.out.println("吃东西");
	}
}

class Dog extends Animal {
	/*public void eat() {}*/
	
	final int NUM;
	
	public Dog() {
		NUM = 10;
	}
}

package com.itheima_01;
/*
 * 匿名对象:没有名字的对象
 * 匿名对象的应用场景：
 * 		当方法只调用一次的时候可以使用匿名对象
 * 		可以当作参数进行传递，但是无法在传参之前做其他的事情
 * 	
 * 注意：匿名对象可以调用成员变量并赋值，但是赋值并没有意义
 * 			
 */
public class AnonymousObejctDemo {
	public static void main(String[] args) {
		//Student s = new Student();
		//s.study();
		//s.study();
		//s.study();
		
		//new Student();//匿名对象，没有变量引用的对象
		//new Student().study();
		//new Student().study();
		//new Student().study();
		
		//new Student().age = 18;
		//System.out.println(new Student().age);
		
		
		//Student s = new Student();
		//s.age = 18;
		//s.name = "张三";
		//method(s);
		
		method(new Student());
		
	}
	
	public static void method(Student s) {
		
	}

		
}


class Student {
	String name;
	int age;
	
	public void study() {
		System.out.println("好好学习，高薪就业");
	}
}

package com.itheima_01;
/*
 * 多态的前提：
 * 	子父类的继承关系
 * 	方法的重写
 * 	父类引用指向子类对象
 * 
 * 动态绑定：运行期间调用的方法，是根据其具体的类型
 * 
 * 
 * 
 * 
 */
public class PoymorphicDemo {
	public static void main(String[] args) {
		/*Cat c = new Cat();
		c.eat();*/
		
		//父类引用 Animal a
		//指向	 =
		//子类对象 new Cat()
		
		Animal a = new Cat();
		a.eat();
		
	}
}

class Animal {
	public void eat() {
		System.out.println("吃东西");
	}
}


class Cat extends Animal {
	public void eat() {
		System.out.println("猫吃鱼");
	}
}
package com.itheima_01;
/*
 *	
 * 	多态的成员特点:
 * 		成员变量  编译时看的是左边，运行时看的左边
 * 		成员方法  编译时看的是左边，运行时看右边
 * 		静态方法  编译时看的是左边，运行时看的也是左边
 * 
 * 
 * 编译时看的都是左边，运行时成员方法看的是右边，其他（成员变量和静态的方法）看的都是左边
 * 
 */
public class PoymorphicDemo2 {
	public static void main(String[] args) {
		Dad d = new Kid();
		//System.out.println(d.num);
		
		//d.method();
		d.function();//使用变量去调用静态方法，其实相当于用变量类型的类名去调用
	}
}

class Dad {
	int num = 20;
	
	public void method() {
		System.out.println("我是父类方法");
	}
	
	public static void function() {
		System.out.println("我是父类静态方法");
	}
}

class Kid extends Dad {
	int num = 10;
	
	public void method() {
		System.out.println("我是子类方法");
	}
	
	public static void function() {
		System.out.println("我是子类静态方法");
	}
}



 
package com.itheima_01;
/*
 *	
 * 	多态中的向上转型和向下转型:
 * 
 *  引用类型之间的转换
 *  	向上转型
 *  		由小到大(子类型转换成父类型)
 *  	向下转型
 *  		由大到小
 *  基本数据类型的转换
 *  	自动类型转换
 *  		由小到大
 *  		byte short char --- int --- long --- float --- double
 *  	强制类型转换
 *  		由大到小
 *  		
 * 	
 * 
 */
public class PoymorphicDemo3 {
	public static void main(String[] args) {
		Animal2 a = new Dog();//向上转型
		//a.eat();
		
		Dog d = (Dog)a;//向下转型
		d.swim();
		
	}
}

class Animal2 {
	public void eat() {
		System.out.println("吃东西");
	}
}


class Dog extends Animal2 {
	public void eat() {
		System.out.println("啃骨头");
	}
	
	public void swim() {
		System.out.println("狗刨");
	}
}


package com.itheima_01;
/*
 *	
 * 	多态的优缺点
 * 		优点：可以提高可维护性（多态前提所保证的），提高代码的可扩展性
		缺点：无法直接访问子类特有的成员
 */
public class PoymorphicDemo4 {
	public static void main(String[] args) {
		MiFactory factory = new MiFactory();
		factory.createPhone(new MiNote());
		
		factory.createPhone(new RedMi());
	}

	
}

class MiFactory {
	/*public void createPhone(MiNote mi) {
		mi.call();
	}
	
	public void createPhone(RedMi mi) {
		mi.call();
	}*/
	
	public void createPhone(Phone p) {
		p.call();
	}
	
}

interface Phone {
	public void call();
}

//小米Note
class MiNote implements Phone{
	public void call() {
		System.out.println("小米Note打电话");
	}
}

//红米
class RedMi implements Phone {
	public void call() {
		System.out.println("红米打电话");
	}
}
package com.itheima_01;
/*
 * Java语言的继承是单一继承，一个子类只能有一个父类（一个儿子只能有一个亲爹）
 * Java语言给我们提供了一种机制，用于处理继承单一的局限性的，接口
 * 
 * 接口：接口是一个比抽象类还抽象的类，接口里所有的方法全是抽象方法，接口和类的关系是实现，implements
 * interface
 * 
 * 格式：
 * 		interface 接口名 {
 * 
 * 		}
 * 
 */
public class InterfaceDemo {
	public static void main(String[] args) {
		BillGates gates = new BillGates();
		gates.code();
	}
}


class Boss {
	public void manage() {
		System.out.println("管理公司");
	}
}

class Programmer {
	public void code() {
		System.out.println("敲代码");
	}
}

//比尔盖茨
class BillGates extends Programmer {
	
}
package com.itheima_01;
/*
 * 接口的成员特点：
 * 		只能有抽象方法
 * 		只能有常量
 * 		默认使用public&abstract修饰方法
 * 		只能使用public&abstract修饰方法
 * 		默认使用public static final来修饰成员变量
 * 
 * 建议：建议大家手动的给上默认修饰符
 * 
 * 注意：
 * 		接口不能创建对象（不能实例化）
 * 		类与接口的关系是实现关系，一个类实现一个接口必须实现它所有的方法

 */
public class InterfaceDemo2 {
	public static void main(String[] args) {
		//Animal a = new Animal();
		//Animal.num;
	}
}


interface Animal {
	public static final int num = 10;
	
	public abstract void eat();
}

class Cat implements Animal {

	public void eat() {
		
	}
	
}
package com.itheima_01;
/*
 * 
 * 类与类：继承关系，单一继承，多层继承
 * 类与接口：实现关系，多实现
 * 接口与接口的关系：继承关系，多继承
 */
public class InterfaceDemo3 {
	public static void main(String[] args) {
		
	}
}

interface InterA extends InterB {
	public abstract void method();
}

interface InterB {
	public abstract void function();
}

interface InterC extends InterA {
	
}

class Demo implements InterC {

	@Override
	public void method() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void function() {
		// TODO Auto-generated method stub
		
	}

	
	
}
 
package com.itheima_02;
/* 	
 * 	篮球运动员和教练
	乒乓球运动员和教练
	现在篮球运动员和教练要出国访问,需要学习英语
	请根据你所学的知识,分析出来哪些是类,哪些是抽象类,哪些是接口
 */
public class InterfaceTest {
	public static void main(String[] args) {
		//创建篮球运动员对象
		BasketBallPlayer bbp = new BasketBallPlayer();
		bbp.name = "女兆月日";
		bbp.age = 35;
		bbp.gender = "男";
		bbp.sleep();
		bbp.study();
		bbp.speak();
		System.out.println("-------------");
		//创建乒乓球教练对象
		PingpangCoach ppc = new PingpangCoach();
		ppc.name = "刘胖子";
		ppc.age = 40;
		ppc.gender = "男";
		ppc.sleep();
		ppc.teach();
		//ppc.speak();
		
		
		
	}
}

class Person {
	String name;//姓名
	int age;//年龄
	String gender;//性别
	
	//无参构造
	public Person() {}
	
	//有参构造
	public Person(String name,int age,String gender) {
		this.name = name;
		this.age = age;
		this.gender = gender;
	}
	
	//吃
	public void eat() {
		System.out.println("吃饭");
	}
	
	//睡
	public void sleep() {
		System.out.println("睡觉");
	}
}

//学习说英语
interface SpeakEnglish {
	public abstract void speak();
}

//运动员
abstract class Player extends Person {
	//学习
	public abstract void study();
}

//教练
abstract class Coach  extends Person {
	//教
	public abstract void teach();
}

//篮球运动员
class BasketBallPlayer extends Player  implements SpeakEnglish{

	@Override
	public void study() {
		System.out.println("学扣篮");
	}

	@Override
	public void speak() {
		System.out.println("说英语");
	}
	
}
//乒乓球运动员
class PingpangPlayer extends Player {

	@Override
	public void study() {
		System.out.println("学抽球");
	}
	
}
//篮球教练
class BasketBallCoach extends Coach implements SpeakEnglish {

	@Override
	public void teach() {
		System.out.println("教扣篮");
	}

	@Override
	public void speak() {
		System.out.println("说英语");
	}
	
}
//乒乓球教练
class PingpangCoach extends Coach {

	@Override
	public void teach() {
		System.out.println("教抽球");
	}
	
}
package com.itheima_01;

 

/*
 * 成员内部类：
 * 		在类的成员位置，和成员变量以及成员方法所在的位置是一样的
 * 		在内部类当中，可以直接访问外部类的成员，包括私有成员
 */
public class InnerDemo {
	public static void main(String[] args) {
		//Outer o = new Outer();
		//o.method();
		
		
		Outer.Inner i = new Outer().new Inner();
		i.function();
		
		 
		
	}
}


class Outer {
	private int num = 10;
	
	public void method() {
		Inner i = new Inner();
		i.function();
	}
	
	class Inner {
		public void function() {
			System.out.println(num);
		}
	}
}


package com.itheima_01;
/*
 * 成员内部类的修饰符：
 * 		我们可以使用权限修饰符修饰成员内部类，但是如果使用私有来修饰，则无法在其他类中访问
 * 		我们可以使用static修饰成员内部类，不用再创建外部类的对象了
 * 
 * 我们可以使用abstract,final修饰成员内部类
 */
public class InnerDemo2 {
	public static void main(String[] args) {
		//Outer2.Inner2 i;
		
		//Outer2.Inner2 i = new Outer2.Inner2();
		//i.function();
		
		Outer2.Inner2.function();
	}
}

class Outer2 {
	public void method() {
		Inner2 i = new Inner2();
	}
	
	static class Inner2 {
		public static void function() {
			System.out.println("function");
		}
	}
}
package com.itheima_02;
/*
 * 局部内部类
 * 		在方法内，出了方法之后就无法使用
 * 		
 * 
 */
public class InnerDemo3 {
	public static void main(String[] args) {
		Outer o = new Outer();
		o.method();
	}
}

class Outer {
	public void method() {
		int num = 10;
		
		class Inner {
			public void function() {
				System.out.println("function");
			}
		}
		
		Inner i = new Inner();
		i.function();
		
	}
	
	public void test() {
		//Inner i = new Inner();
		//System.out.println(num);
	}
}

package com.itheima_03;
/*
 * 匿名内部类:
 * 		可以把匿名内部类看成是一个没有名字的局部内部类
 * 		定义在方法当中
 * 		必须在定义匿名内部类的时候创建他的对象
 * 格式：
 * 		new 类/接口(){
 * 			如果是创建了继承这个类的子类对象，我们可以重写父类的方法
 * 			如果是创建了实现这个接口的子类对象，我们必须要实现该接口的所有方法
 * 		};
 * 原理：而是创建了继承这个类的子类对象或者是创建了实现这个接口的子类对象
 * 	
 */
public class InnerDemo4 {
	public static void main(String[] args) {
		Outer o = new Outer();
		o.method();
	}
}


interface Inner {
	public void function();
}

class Outer {
	public void method() {
		
		/*new Inner() {

			@Override
			public void function() {
				System.out.println("function");
			}
			
		}.function();;*/
		
		Inner i = new Inner() {

			@Override
			public void function() {
				System.out.println("function");
			}
			
		};
		
		i.function();
		i.function();
		
		
	}
}

 
package com.itheima_04;

public interface Animal {
	public abstract void eat();
}
package com.itheima_04;

public class Cat implements Animal {

	@Override
	public void eat() {
		System.out.println("猫吃鱼");
	}

}
package com.itheima_04;

public class Dog implements Animal {

	@Override
	public void eat() {
		System.out.println("狗啃骨头");
	}

}
package com.itheima_04;
/*
 * 匿名内部类的应用场景:
 * 		作为参数进行传递
 * 		
 *      
 */
public class InnerDemo5 {
	public static void main(String[] args) {
		 //method(new Dog());
		 //method(new Cat());
		
	
		
		method(
				new Animal() {

					@Override
					public void eat() {
						System.out.println("猫吃鱼");
					}
					
				}	
		);
	}	
	
	public static void method(Animal a) {
		a.eat();
	}
}
  
package com.itheima_01;
/*
 * 包的特点：
 * 		可以有多层
 * 		不同包下的文件名可以重复
 * 		包的声明必须是第一行代码
 * 
 */
public class PackageDemo {

}

package com.itheima_01;

import java.util.ArrayList;

/*
 * 
 * 不同包之间的互相访问
 * 		使用类的全名
 * 		使用关键字import将类导入
 * 
 * 
 * 注意：*代表的是通配符，代表导入了这个包下所有的类，并没有导入子包下的类
 * 
 * 类的全名：包名.类名
 * 
 * 
 */
public class PackageDemo2 {
	public static void main(String[] args) {
		//相同包下的类可以直接访问，不需要做其他的操作
		//PackageDemo pd = new PackageDemo();
		
		java.util.ArrayList list = new java.util.ArrayList();
		
		ArrayList list2 = new ArrayList();
	}
}

package com.itheima_02;
/*
 * 权限修饰符：
		public 当前类，相同包下不同的类,不同包下的类
		default 当前类，相同包下不同的类
		private 当前类
		protected 当前类，相同包下不同的类
		
		default:当前包下使用
		protected:让子类对象使用
 *  
 */
public class PermissionsDemo {
	
	public void publicMethod() {
		System.out.println("publicMethod");
	}
	
	void defaultMethod() {
		System.out.println("defaultMethod");
	}

	private void privateMethod() {
		System.out.println("privateMethod");
	}
	
	protected void protectedMethod() {
		System.out.println("protectedMethod");
	}
	
	public static void main(String[] args) {
		PermissionsDemo pd = new PermissionsDemo();
		pd.publicMethod();
		pd.defaultMethod();
		pd.privateMethod();
		pd.protectedMethod();
	}
}
package com.itheima_02;

public class PermissionsDemo2 {
	
	 
	
	public static void main(String[] args) {
		PermissionsDemo pd = new PermissionsDemo();
		pd.publicMethod();
		pd.defaultMethod();
		//pd.privateMethod();
		pd.protectedMethod();
	}
}
package com.itheima_03;

import com.itheima_02.PermissionsDemo;

public class PermissionsDemo3 {
	
	 
	
	public static void main(String[] args) {
		PermissionsDemo pd = new PermissionsDemo();
		pd.publicMethod();
		//pd.defaultMethod();
		//pd.privateMethod();
		//pd.protectedMethod();
	}
}
package com.itheima_03;

import com.itheima_02.PermissionsDemo;

public class PermissionsDemo4 extends PermissionsDemo {
	
	public void function() {
		super.publicMethod();
		super.protectedMethod();
	}
	 
	
	public static void main(String[] args) {
	
	}
}
package com.itcast.cn;

import java.util.Scanner;

public class Test7 {

	public static void main(String[] args) {

		NetGame netGame = new NetGame("LOL");
		boolean login = netGame.login();
		if (login) {
			netGame.Opreate();
			netGame.loginOut();
		}

		ComputerSigleGame game = new ComputerSigleGame("红警");
		game.Opreate();

		HongBaiSingle single = new HongBaiSingle();
		single.putCard(new Card("超级玛丽"));
		single.Opreate();

		PSP psp = new PSP();

		psp.putCard(new Card("超级玛丽"));

		psp.Opreate();

	}

}

abstract class Game {

	public Game(String name) {
		super();
		this.name = name;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	private String name;

	public abstract void Opreate();
}

class NetGame extends Game {

	private String username;
	private String password;

	public NetGame(String name) {
		super(name);
		// TODO Auto-generated constructor stub
	}
	// 现在有网络游戏是游戏的一种,网络游戏有游戏名字,游戏账号,和游戏密码,都有登录,退出功能,登录的时候需要判断用户名和密码,网络游戏是通过键盘和鼠标进行操作的;

	public boolean login() {

		Scanner scanner = new Scanner(System.in);
		System.out.println("请输入账号和密码");
		username = scanner.nextLine();
		password = scanner.nextLine();

		if (username.equals("林青霞") && password.equals("我爱你")) {

			System.out.println(getName() + "登录成功");
			return true;

		}

		return false;

	}

	@Override
	public void Opreate() {
		System.out.println("通过键盘和鼠标去操作" + getName() + "游戏吧");

	}

	public void loginOut() {
		System.out.println("我退出了" + getName() + "游戏");
	}

}

abstract class SigleGame extends Game {

	public SigleGame(String name) {
		super(name);
		// TODO Auto-generated constructor stub
	}

	@Override
	public abstract void Opreate();

}

class ComputerSigleGame extends SigleGame {

	public ComputerSigleGame(String name) {
		super(name);
	}

	@Override
	public void Opreate() {
		System.out.println("通过键盘,鼠标,手柄操作" + getName() + "游戏");
	}

}

class HongBaiSingle extends SigleGame implements CardCao {

	public HongBaiSingle() {
		super(null);
	}

	public HongBaiSingle(String name) {
		super(name);
		// TODO Auto-generated constructor stub
	}

	@Override
	public void Opreate() {

		if (getName() == null) {
			System.out.println("你还没插卡呢,玩个屁啊");
		} else {

			System.out.println("我通过手柄操作" + getName() + "的游戏");
		}
	}

	@Override
	public void putCard(Card card) {
		setName(card.getName());
	}
}

interface CardCao {
	void putCard(Card card);
}

class Card {
	private String name;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Card(String name) {
		super();
		this.name = name;
	}

}

class PSP extends SigleGame implements CardCao {

	public PSP() {
		super(null);

	}

	public PSP(String name) {
		super(name);
		// TODO Auto-generated constructor stub
	}

	@Override
	public void putCard(Card card) {
		setName(card.getName());

	}

	@Override
	public void Opreate() {
		System.out.println("通过手柄操作" + getName() + "游戏");

	}

}
package com.itheima_01;
/*
 * String toString()  : 返回该对象的字符串表示
 * 		 return getClass().getName() + "@" + Integer.toHexString(hashCode());
 * 		 getClass():返回一个字节码对象
 * 		 Integer.toHexString():返回指定参数的十六进制字符串形式
 * 		 hashCode()：返回该对象的哈希码值（内部地址）
 * 
 * 	
 * 
 * boolean equals(Object obj)  
 * 
 */
public class ObjectDemo {
	public static void main(String[] args) {
		Student s = new Student();
		s.name = "zhangsan";
		s.age = 18;
		System.out.println(s.toString());//com.itheima_01.Student@737951b0
		System.out.println(s);//说明我们输出一个对象就是默认输出这个对象的toString()方法
	}
}

class Student extends Object {
	String name;
	int age;
	/*
	public String toString() {
		return name + "@" + age;
	}
	*/
	
	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + "]";
	}
	
	
}
package com.itheima_01;

import java.util.ArrayList;

/*
 * boolean equals(Object obj)  
 * 		使用==来比较两个对象是否相等，则比较地址值是否相等
 */
public class ObjectDemo2 {
	public static void main(String[] args) {
		Person p = new Person("zhangsan",18);
		Person p2 = new Person("zhangsan",19);
		
		//boolean flag = p.equals(p2);
		
		boolean flag = p.equals(new ArrayList());
		System.out.println(flag);
	}
}

class Person {
	String name;
	int age;
	
	public Person(String name,int age) {
		this.name = name;
		this.age = age;
	}


	@Override
	public boolean equals(Object obj) {
		//提高效率
		if (this == obj)
			return true;
		
		if (obj == null)
			return false;
		//提高健壮性
		if (getClass() != obj.getClass())
			return false;
		
		//向下转型
		Person other = (Person) obj;
		
		if (age != other.age)
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}
	
	
	/*@Override
	public boolean equals(Object o) {
		//提高效率 当前对象和传递进来的对象地址值一样，则不用比较成员
		if(this == o) {
			return true;
		}
		
		//提高代码的健壮性
		if(this.getClass() != o.getClass()) {
			return false;
		}
		
		//向下转型
		Person other = (Person) o;
		
		if(!this.name.equals(other.name)) {
			return false;
		}
		
		if(this.age != other.age) {
			return false;
		}
		
		return true;
	}*/
	
	
}
package com.itheima_02;
/*
 * System:包含一些有用的类字段和方法。它不能被实例化
 * static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)  
 * static long currentTimeMillis()  
 * static void exit(int status) 
   static void gc()  
 * 
 */
public class SystemDemo {
	public static void main(String[] args) {
		//method();
		//method2();
		//method3();
		
		//static void gc()  
		//Demo d = new Demo();
		new Demo();
		System.gc();
	}

	private static void method3() {
		//static void exit(int status) :终止虚拟机
		
		for (int i = 0; i < 100000; i++) {
			System.out.println(i);
			if(i == 100) {
				System.exit(0);
			}
		}
	}

	private static void method2() {
		/*
		 *  static long currentTimeMillis() :以毫秒值返回当前系统时间
		 *  这个毫秒的时间是相对时间，相对于1970-1-1 00:00:00 ： 0
		 *  1970-1-1 00:00:01 : 1000
		 *  1970-1-1 00:01:00: 1000 * 60
		 *  1970-1-1 01:00:00: 1000 * 60 * 60
		 *  1000毫秒 = 1秒
		 *  
		 */
		//System.out.println(System.currentTimeMillis());
		
		
		long start = System.currentTimeMillis();
		for (int i = 0; i < 100000; i++) {
			System.out.println(i);
		}
		long end = System.currentTimeMillis();
		System.out.println(end - start);
	}

	private static void method() {
		/*
		 * static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)  
		 * 复制数组
		 * 参数1：源数组
		 * 参数2：源数组的起始索引位置
		 * 参数3：目标数组
		 * 参数4：目标数组的起始索引位置
		 * 参数5：指定接受的元素个数
		 */
		int[] src = {1,2,3,4,5};
		int[] dest = new int[5];
		System.arraycopy(src, 2, dest, 4, 3);
		
		for (int i = 0; i < dest.length; i++) {
			System.out.print(dest[i]);
		}
	}
}

class Demo {
	@Override
	protected void finalize() throws Throwable {
		System.out.println("我被回收了");
	}
}
package com.itheima_03;

import java.util.Date;

/*
 * Date: 表示特定的瞬间，精确到毫秒，他可以通过方法来设定自己所表示的时间，可以表示任意的时间
 * System.currentTimeMillis():返回的是当前系统时间，1970-1-1至今的毫秒数
 * 
 * 构造方法：
 * 		Date() ：创建的是一个表示当前系统时间的Date对象
		Date(long date) ：根据"指定时间"创建Date对象
 
 */
public class DateDemo {
	public static void main(String[] args) {
		//Date()
		//Date d = new Date();
		//System.out.println(d);//Thu Aug 26 14:17:28 CST 2049
		//System.out.println(d.toLocaleString());
		
		//Date(long date) 
		Date d2 = new Date(1000 * 60 * 60 * 24);//时区 有时差
		System.out.println(d2.toLocaleString());

	}
}
package com.itheima_03;

import java.util.Date;

/*
 * Date的常用用方法
		毫秒值 --- Date
			设置
			返回值是void，参数long
			void setTime(long time)  
			Date(long date)
		Date --- 毫秒值
			获取
			返回long，无参数
			long getTime()  
 */
public class DateDemo2 {
	public static void main(String[] args) {
		Date d = new Date();//默认当前系统时间
		//d.setTime(1000 * 60 * 60 * 24 * 2);
		System.out.println(d.toLocaleString());
		System.out.println(d.getTime());//172800000
		
		
		d.setTime(172800000L);
		System.out.println(d.toLocaleString());
	}
}
package com.itheima_04;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/*
 * SimpleDateFormat:
 * 		格式化：
 * 			Date --- String
 * 			2049-8-26 2049年8月26日
 * 			String format(Date date) 
 * 		解析：
 * 			String --- Date
 * 			"2049-8-26"
 * 			Date parse(String source) 
 * 
 * 构造方法：
 * 		SimpleDateFormat() ：使用默认的模式进行对象的构建
 * 		SimpleDateFormat(String pattern) ：使用的指定的模式进行对象的构建
 * 
 * 注意：Exception in thread "main" java.text.ParseException: Unparseable date: "49年9月26日  下午1:29"
 * 	    解析的字符串，模式必须和构建对象的模式一样
 *
 */
public class SimpleDateFormatDemo {
	public static void main(String[] args) throws ParseException {
		//method();
		//method2();
		//使用指定的模式进行对象的构建
		//1999年9月1日 10:10:10
		//4个小姨2个大美眉和2个小弟弟
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
		
		//格式化
		Date date = new Date();
		String s = sdf.format(date);
		System.out.println(s);//2049年08月26日 13:39:12

		
		//解析
		Date d = sdf.parse("2049年08月26日 13:39:12");
		System.out.println(d.toLocaleString());


		

	}

	private static void method2() throws ParseException {
		//使用指定的模式进行对象的构建
		//1999年9月1日
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日");
		//格式化
		Date date = new Date();
		String s = sdf.format(date);
		System.out.println(s);//2049年08月26日
		
		//解析
		Date d = sdf.parse("2049年08月26日");
		System.out.println(d.toLocaleString());
	}

	private static void method() throws ParseException {
		//使用默认模式进行对象的构建
		SimpleDateFormat sdf = new SimpleDateFormat();
		//创建日期对象
		Date date = new Date();
		
		//格式化 把日期对象转换成字符串
		String s = sdf.format(date);
		System.out.println(s);//49-8-26 下午1:29
		
		//解析 把字符串转换成日期对象
		Date d = sdf.parse("49年9月26日  下午1:29");
		System.out.println(d.toLocaleString());
	}

}
package com.itheima_05;

import java.util.Calendar;

/*
 * Calendar：日历，提供了一些操作年月日时的方法
 * 
 * 获取
 * 修改
 * 添加
 * 
 * 
 */
public class CalendarDemo {
	public static void main(String[] args) {
		//static Calendar getInstance()  
		Calendar c = Calendar.getInstance();
		
		//void set(int field, int value) ：把指定的字段修改成指定的值
		//c.set(Calendar.DAY_OF_MONTH, 20);
		
		//void add(int field, int amount): 在指定的字段上加上指定的值
		c.add(Calendar.DAY_OF_MONTH, -1);
		
		//int get(int field) // 返回给定日历字段的值
		//public static final int YEAR 1 
		//System.out.println(Calendar.YEAR);
		
		//int year = c.get(1);
		int year = c.get(Calendar.YEAR);
		int month = c.get(Calendar.MONTH) + 1;
		int day = c.get(Calendar.DAY_OF_MONTH);
		
		
		System.out.println(year + "年" + month + "月" + day + "日");
		 
	}
}
package com.itheima_06;
/*
 * 需求：判断一个数是否符合int类型的范围
 * 由于基本数据类型只能做一些简单的操作和运算，所以Java为我们封装了基本数据类型，为每种基本数据类型提供了包装类
 * 包装类就是封装了基本数据类型的类，为我们提供了更多复杂的方法和一些变量
 * 
 * byte		Byte
 * short	Short
 * char		Character
 * int		Integer
 * long		Long
 * float	Float
 * double	Double
 * boolean	Boolean
 * 
 * Integer:
 * 		String --- int
 * 			方式1：int intValue()
 * 			方式2： static int parseInt(String s) 
 * 		int --- String
 * 			方式1： + ""
 * 			方式2：String toString()
 * 
 * 构造方法：
 * 		Integer(int value) 
 * 		Integer(String s) 

 
 */
public class IntegerDemo {
	public static void main(String[] args) {
		/*int n = 10;
		if(n >= Math.pow(-2, 31) && n <= Math.pow(2, 31) -1) {
			System.out.println("符合");
		}
		else {
			System.out.println("不符合");
		}*/
		
		//Integer(String s) 
		//Integer i = new Integer("10");
		//System.out.println(i);
		
		//int intValue()  
		//int a = i.intValue();
		//System.out.println(a + 10 );
		
		//static int parseInt(String s) 
		//int b = Integer.parseInt("20");
		//System.out.println(b + 30);
		
		
		//Integer(int value)
		//Integer i2 = new Integer(40);
		//String s = i2.toString();
		//System.out.println(s);
		
		//static String toString(int i)  
		//String s2 = Integer.toString(50);
		//System.out.println(s2);
		
	}
}
package com.itheima_06;

import java.util.ArrayList;

/*
 * JDK1.5特性：自动装箱和拆箱
 * 
 */
public class IntegerDemo2 {
	public static void main(String[] args) {
		//Integer i = new Integer(10);
		
		//自动装箱
		//相当于： Integer i = new Integer(10);
		//Integer i = 10;
		
		//自动拆箱
		//相当于 int a = i.intValue();
		//Integer i = 10;
		//int a = i;
		
		Integer i = 10;
		Integer i2 = 20;
		Integer i3 = i + i2;
		/*
		 * Integer i3 = new Integer(i.intValue() + i2.intValue());
		 * 
		 */
		
		ArrayList list = new ArrayList();
		list.add(1);//自动装箱，list.add(new Integer(1));
	}
}
package com.itheima_07;
/*
 * 	校验qq号码
* 		要求必须是5-15位
* 		0不能开头
* 		必须都是数字
	
	正则表达式：就是一套规则，可以用于匹配字符串
	
	boolean matches(String regex) ：判断当前字符串是否匹配指定的正则表达式，如果匹配则返回true，否则返回false
* 
*  
 */
public class RegexDemo {
	public static void main(String[] args) {
		String qq = "12a345";
		/*boolean flag = checkQQ(qq);
		System.out.println(flag);*/
		
		
		boolean flag = qq.matches("[1-9][0-9]{4,14}");
		System.out.println(flag);
	}
	
	public static boolean checkQQ(String qq) {
		int length = qq.length();
		//要求必须是5-15位
		if(length < 5 || length > 15) {
			return false;
		}
		
		//0不能开头
		if(qq.startsWith("0")) {
			return false;
		}
		
		//必须都是数字
		for (int i = 0; i < length; i++) {
			//得到参数的每一个字符
			char c = qq.charAt(i);
			if(c < '0' || c > '9') {
				return false;
			}
		}
		
		
		
		
		return true;//符合要求
	}
	 

	
}
package com.itcast.day05;

import java.util.Date;

public class DateDemo {

	@SuppressWarnings("deprecation")
	public static void main(String[] args) {
		Date date = new Date();// 默认获取的是当前系统时间

		String localeString = date.toLocaleString();
		System.out.println(localeString);
//		Date date1 = new Date(0);// 获取的当前时区所代表的1970 1 1 的时差时间;
		
		
	}

}
package com.itcast.day05;

public class Test1 {

	// 2.通过System这个类的arraycopy方法将已知数组int [] arr
	// ={12,234,45,324};中中间两个元素拷贝到另外一个新数组中;

	public static void main(String[] args) {
//		int [] arr ={12,234,45,324};
//		
//		int[] newArr = new int[4];
//		System.arraycopy(arr, 1, newArr, 0, 2);
//		
//		for (int i = 0; i < newArr.length; i++) {
//			System.out.println(newArr[i]);
//		}
		
		for (int i = 0; i < 1000000; i++) {
			new Mei();
		}
		
		System.gc();
		
		
		
		

	}

}

class Mei{
	@Override
	protected void finalize() throws Throwable {
		System.out.println("我爱林青霞");
	}
}
package com.itcast.day05;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

public class Test2 {

	public static void main(String[] args) throws ParseException {
		String date = "1997_07_01 08:08:08";// 这个字符串;

		// 想让将这个字符串转成 1997年08月01日 08:08:08;
		// SimpleDateFormat dateFormat = new SimpleDateFormat();//使用默认格式的,不可取
		SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy_MM_dd HH:mm:ss");// 使用指定格式的,可取
		// 通过parse方法将字符串解析成Date
		Date parse = dateFormat.parse(date);

		// long time = parse.getTime();
		// time += 1000 * 60 * 60 * 24 * 31L;// 一定要L再去改变时间;
		//
		// Date newDate = new Date(time);

		// 获取Calender
		Calendar instance = Calendar.getInstance();
		instance.setTime(parse);

		int i = instance.get(Calendar.MONTH);
		//
		System.out.println(i);

		instance.set(Calendar.MONTH, i + 1);

		System.out.println(instance.get(Calendar.MONTH));

		// SimpleDateFormat dateFormat2 = new SimpleDateFormat("yyyy年MM月dd日
		// HH:mm:ss");
		// // 通过format方法将日期转成想要的字符串表现形式
		//
		// String format = dateFormat2.format(newDate);
		// System.out.println(format);
	}

}
package com.itcast.day05;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Scanner;

public class Test3 {
	
	public static void main(String[] args) throws ParseException {
		// (1)将当前的时间解析成 xxxx年xx月xx日 xx:xx:xx 这种格式显示;
		// (2)已知一个字符串时间String date = "2000_02_29#####23-23-23";
		// a. 请将字符串时间转成一个date对象
		// b.然后通过对象获取出以上date对象明天这个时候的毫秒值
		// c.然后通过获取刚才获取的毫秒值获取出明天的date对象;
		// d.然后将获取出新的date对象的时间以xxxx年xx月xx日 xx:xx:xx 这种格式显示出来;
		
		demo1();
		
		Demo2();
		
		
		//输入格式为 xxxx-xx-xx
		
		Scanner scanner = new Scanner(System.in);
		System.out.println("请输入出生年月日格式为 xxxx-xx-xx");
		String nextLine = scanner.nextLine();
		//需要将输入出生年月日转成date对象啊, 只有转成date对象才能得到出生的毫秒值
		SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");
		Date parse = format.parse(nextLine);
		
		long birthTime = parse.getTime();
		
		long currentTimeMillis = System.currentTimeMillis();
		
		long result = currentTimeMillis - birthTime;
		
		int day =  (int)(result/(1000*60*60*24));
		System.out.println(day);
		System.out.println(day/365);
		
		
		
		
		
		
		
		
		
	}

	private static void Demo2() throws ParseException {
		String date = "2000_02_29#####23-23-23";
		//现在我们需要将字符串转成Date对象,需要创建SimpleDateFormat ,通过SimpleDateFormat的Parse方法就可以实现
		
		SimpleDateFormat format = new SimpleDateFormat("yyyy_MM_dd#####HH-mm-ss");
		//可以解析
		Date parse = format.parse(date);
		
		long time = parse.getTime();
		time+= 1000*60*60*24L;
		System.out.println(time);
		
		parse.setTime(time);
		
		System.out.println(parse.toLocaleString());
		
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
		String format2 = simpleDateFormat.format(parse);
		System.out.println(format2);
	}

	private static void demo1() {
		Date date = new Date();//获取当前系统时间
		//将时间格式化成 xxxx年xx月xx日 xx:xx:xx的格式字符串
		SimpleDateFormat format = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
		String format2 = format.format(date);
		System.out.println(format2);
	}

}
package com.itcast.day05;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;

import javax.swing.text.html.HTMLDocument.HTMLReader.SpecialAction;

public class Test4 {
	
	public static void main(String[] args) {
		//获取当前时间
		Date date = new Date();
		//获取1971年1月1日 8:00;
		
		Date date2 = new Date(1000L*60*60*24*365);
		
		Date date3 = new Date(0);//代表就是1970 1月1日 8:00东八区的时间
		
//		

		Date date4 = new Date(0);
		
		date4.setYear(100);
		
		long time = date4.getTime();
		
		long result = date.getTime()- time;
		
		System.out.println(result/(1000L*60*60*24));
		
		
		//将时间字符串转成Date对象 1.首先创建SimpleDateFormat (里面的格式需要时间字符串的格式一致)
							//2.调用simpledateformat对象的parse(String date);
		
		//将Date对象转成我们想要的时间字符串;1.创建SimpleDateFormat(里面的格式需要和想要的格式一致)
								// 2. 调用SimleDateFormat的对象的format方法Date对象转成我们想要的字符串;
		
		Date date5 = new Date();//
		SimpleDateFormat dateFormat =new SimpleDateFormat("yyyy年MM月dd");
		String format = dateFormat.format(date5);
		System.out.println(format);
		
		ArrayList list = new ArrayList<>();
		
		//Integer integer = new Integer(1);
		list.add(1);
		
		String regex = "[1-9][3][0-9]{3,12}";
		
		String qq = "034565";
		
		boolean matches = qq.matches(regex);
		System.out.println(matches);
		
		String s = ".a.a.a.a.a";
		
		String replace = s.replace(".", "b");
		System.out.println(replace);
		
		String replaceAll = s.replaceAll(".", "b");
		System.out.println(replaceAll);
		
		String[] split = s.split("\\.");
		System.out.println(split.length);
		
		
		
		
		
		
	}

}
package com.itcast.day05;

import java.util.Date;

public class DateDemo {

	@SuppressWarnings("deprecation")
	public static void main(String[] args) {
		Date date = new Date();// 默认获取的是当前系统时间

		String localeString = date.toLocaleString();
		System.out.println(localeString);
//		Date date1 = new Date(0);// 获取的当前时区所代表的1970 1 1 的时差时间;
		
		
	}

}
package com.itcast.day05;

public class Test1 {

	// 2.通过System这个类的arraycopy方法将已知数组int [] arr
	// ={12,234,45,324};中中间两个元素拷贝到另外一个新数组中;

	public static void main(String[] args) {
//		int [] arr ={12,234,45,324};
//		
//		int[] newArr = new int[4];
//		System.arraycopy(arr, 1, newArr, 0, 2);
//		
//		for (int i = 0; i < newArr.length; i++) {
//			System.out.println(newArr[i]);
//		}
		
		for (int i = 0; i < 1000000; i++) {
			new Mei();
		}
		
		System.gc();
		
		
		
		

	}

}

class Mei{
	@Override
	protected void finalize() throws Throwable {
		System.out.println("我爱林青霞");
	}
}
package com.itcast.day05;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

public class Test2 {

	public static void main(String[] args) throws ParseException {
		String date = "1997_07_01 08:08:08";// 这个字符串;

		// 想让将这个字符串转成 1997年08月01日 08:08:08;
		// SimpleDateFormat dateFormat = new SimpleDateFormat();//使用默认格式的,不可取
		SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy_MM_dd HH:mm:ss");// 使用指定格式的,可取
		// 通过parse方法将字符串解析成Date
		Date parse = dateFormat.parse(date);

		// long time = parse.getTime();
		// time += 1000 * 60 * 60 * 24 * 31L;// 一定要L再去改变时间;
		//
		// Date newDate = new Date(time);

		// 获取Calender
		Calendar instance = Calendar.getInstance();
		instance.setTime(parse);

		int i = instance.get(Calendar.MONTH);
		//
		System.out.println(i);

		instance.set(Calendar.MONTH, i + 1);

		System.out.println(instance.get(Calendar.MONTH));

		// SimpleDateFormat dateFormat2 = new SimpleDateFormat("yyyy年MM月dd日
		// HH:mm:ss");
		// // 通过format方法将日期转成想要的字符串表现形式
		//
		// String format = dateFormat2.format(newDate);
		// System.out.println(format);
	}

}
package com.itcast.day05;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Scanner;

public class Test3 {
	
	public static void main(String[] args) throws ParseException {
		// (1)将当前的时间解析成 xxxx年xx月xx日 xx:xx:xx 这种格式显示;
		// (2)已知一个字符串时间String date = "2000_02_29#####23-23-23";
		// a. 请将字符串时间转成一个date对象
		// b.然后通过对象获取出以上date对象明天这个时候的毫秒值
		// c.然后通过获取刚才获取的毫秒值获取出明天的date对象;
		// d.然后将获取出新的date对象的时间以xxxx年xx月xx日 xx:xx:xx 这种格式显示出来;
		
		demo1();
		
		Demo2();
		
		
		//输入格式为 xxxx-xx-xx
		
		Scanner scanner = new Scanner(System.in);
		System.out.println("请输入出生年月日格式为 xxxx-xx-xx");
		String nextLine = scanner.nextLine();
		//需要将输入出生年月日转成date对象啊, 只有转成date对象才能得到出生的毫秒值
		SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");
		Date parse = format.parse(nextLine);
		
		long birthTime = parse.getTime();
		
		long currentTimeMillis = System.currentTimeMillis();
		
		long result = currentTimeMillis - birthTime;
		
		int day =  (int)(result/(1000*60*60*24));
		System.out.println(day);
		System.out.println(day/365);
		
		
		
		
		
		
		
		
		
	}

	private static void Demo2() throws ParseException {
		String date = "2000_02_29#####23-23-23";
		//现在我们需要将字符串转成Date对象,需要创建SimpleDateFormat ,通过SimpleDateFormat的Parse方法就可以实现
		
		SimpleDateFormat format = new SimpleDateFormat("yyyy_MM_dd#####HH-mm-ss");
		//可以解析
		Date parse = format.parse(date);
		
		long time = parse.getTime();
		time+= 1000*60*60*24L;
		System.out.println(time);
		
		parse.setTime(time);
		
		System.out.println(parse.toLocaleString());
		
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
		String format2 = simpleDateFormat.format(parse);
		System.out.println(format2);
	}

	private static void demo1() {
		Date date = new Date();//获取当前系统时间
		//将时间格式化成 xxxx年xx月xx日 xx:xx:xx的格式字符串
		SimpleDateFormat format = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
		String format2 = format.format(date);
		System.out.println(format2);
	}

}
package com.itcast.day05;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;

import javax.swing.text.html.HTMLDocument.HTMLReader.SpecialAction;

public class Test4 {
	
	public static void main(String[] args) {
		//获取当前时间
		Date date = new Date();
		//获取1971年1月1日 8:00;
		
		Date date2 = new Date(1000L*60*60*24*365);
		
		Date date3 = new Date(0);//代表就是1970 1月1日 8:00东八区的时间
		
//		

		Date date4 = new Date(0);
		
		date4.setYear(100);
		
		long time = date4.getTime();
		
		long result = date.getTime()- time;
		
		System.out.println(result/(1000L*60*60*24));
		
		
		//将时间字符串转成Date对象 1.首先创建SimpleDateFormat (里面的格式需要时间字符串的格式一致)
							//2.调用simpledateformat对象的parse(String date);
		
		//将Date对象转成我们想要的时间字符串;1.创建SimpleDateFormat(里面的格式需要和想要的格式一致)
								// 2. 调用SimleDateFormat的对象的format方法Date对象转成我们想要的字符串;
		
		Date date5 = new Date();//
		SimpleDateFormat dateFormat =new SimpleDateFormat("yyyy年MM月dd");
		String format = dateFormat.format(date5);
		System.out.println(format);
		
		ArrayList list = new ArrayList<>();
		
		//Integer integer = new Integer(1);
		list.add(1);
		
		String regex = "[1-9][3][0-9]{3,12}";
		
		String qq = "034565";
		
		boolean matches = qq.matches(regex);
		System.out.println(matches);
		
		String s = ".a.a.a.a.a";
		
		String replace = s.replace(".", "b");
		System.out.println(replace);
		
		String replaceAll = s.replaceAll(".", "b");
		System.out.println(replaceAll);
		
		String[] split = s.split("\\.");
		System.out.println(split.length);
		
		
		
		
		
		
	}

}
1. == 和 equals
==比较是地址值
equals是默认的也是地址值,只不过在以后开发过程中,我们要对equals进行重写,我们一般用快捷生成;
系统默认重写的equals方法 ,本质比较的是我们成员变量;

2.Date
	构造方法:
		new Date()//获取当前系统时间
		new Date(long date)//获取指定时间

		//针对毫秒值转成date对象,还有就是date对象转成毫秒
		setTime(long date);//可以指定某个时间
		getTime();//获取时间
3.SimpleDateFormat
	一个内容是将 Date对象转成成String  // format (Date date)
	另外一个内容格式将 日期的String字符串转成date对象;//parse(String date)
	
	为什么要互相转化
		将Date对象转成字符串是方便我们查看,
		将字符串转成Date对象是方便操作
4.日期类 Calendar
	专门提供了操作年,月,日,时的方法;

5.  
	将数字字符串转成int 
	1. int Integer.paserInt(String str)//能将数字字符串转成int类型的值
	将int 值转成字符串;
	2. int值+"";

	byte -->Byte;
	int--->Integer;
	short--->Short;
	char--->Character
	float --->Float
	double --->Double   //Double.parseDouble()
	boolean ---->Boolean
	long---->Long;
6.正则表达式
	原则如果以后用到正则需要通过网络搜取;

	字符串在使用正则的时候需要注意
	如果是正则方法,'.'代表的是所有,需要进行=转义"\\.";

1. == 和 equals
==比较是地址值
equals是默认的也是地址值,只不过在以后开发过程中,我们要对equals进行重写,我们一般用快捷生成;
系统默认重写的equals方法 ,本质比较的是我们成员变量;

2.Date
	构造方法:
		new Date()//获取当前系统时间
		new Date(long date)//获取指定时间

		//针对毫秒值转成date对象,还有就是date对象转成毫秒
		setTime(long date);//可以指定某个时间
		getTime();//获取时间
3.SimpleDateFormat
	一个内容是将 Date对象转成成String  // format (Date date)
	另外一个内容格式将 日期的String字符串转成date对象;//parse(String date)
	
	为什么要互相转化
		将Date对象转成字符串是方便我们查看,
		将字符串转成Date对象是方便操作
4.日期类 Calendar
	专门提供了操作年,月,日,时的方法;

5.  
	将数字字符串转成int 
	1. int Integer.paserInt(String str)//能将数字字符串转成int类型的值
	将int 值转成字符串;
	2. int值+"";

	byte -->Byte;
	int--->Integer;
	short--->Short;
	char--->Character
	float --->Float
	double --->Double   //Double.parseDouble()
	boolean ---->Boolean
	long---->Long;
6.正则表达式
	原则如果以后用到正则需要通过网络搜取;

	字符串在使用正则的时候需要注意
	如果是正则方法,'.'代表的是所有,需要进行=转义"\\.";

package com.itheima_01;

import java.util.ArrayList;

/*
 *  ArrayList
 *  集合的体系结构：
 *  	由于不同的数据结构（数据的组织，存储方式），所以Java为我们提供了不同的集合，
 *  	但是不同的集合他们的功能都是相似，不断的向上提取，将共性抽取出来，这就是集合体系结构形成的原因
 *  
 *  体系结构：
 *  		怎么学习?最顶层开始学习，因为最顶层包含了所有的共性
 *  		怎么使用？使用最底层，因为最底层就是具体的实现
 *  
 *  Collection
 *  List
 *  ArrayList
 */
public class CollectionDemo {
	public static void main(String[] args) {		
		//创建集合对象
		ArrayList al = new ArrayList();
		//添加元素
		al.add("hello");
		al.add("world");
		al.add("java");
		//遍历集合
		for(int x = 0;x < al.size();x++) {
			System.out.println(al.get(x));
		}
		
	}
}
package com.itheima_01;

import java.util.ArrayList;
import java.util.Collection;

/*
 * 	Collection 	
 * 			boolean add(E e)  
 * 			void clear()  
 * 			boolean contains(Object o)  
 * 			boolean isEmpty() 
 * 			boolean remove(Object o) 
 * 			int size() 
 * 			Object[] toArray()  
 
 
 * 
 * 
 * Iterator<E> iterator()  
 
 * 		
 */
public class CollectionDemo2 {
	public static void main(String[] args) {		
		//创建集合对象
		//Collection c = new Collection();//Collection是接口，不能实例化
		Collection c = new ArrayList();//多态，父类引用指向子类对象  
		
		//boolean add(E e)  
		System.out.println(c.add("hello"));//永远可以添加成功，因为ArrayList他允许重复
		System.out.println(c.add("world"));
		
		//void clear()：清空集合
		//c.clear();
		
		//boolean contains(Object o)  :判断集合中是否包含指定元素
		//System.out.println(c.contains("java"));
		
		//boolean isEmpty() :是否为空
		//System.out.println(c.isEmpty());
		
		
		//boolean remove(Object o) :删除元素
		//System.out.println(c.remove("java"));
		
		//int size() :返回集合中的元素个数
		//System.out.println(c.size());
		
		//Object[] toArray()  :将集合转换成一个Object类型的数组
		Object[] objs = c.toArray();
		for (int i = 0; i < objs.length; i++) {
			System.out.println(objs[i]);
		}
		
		
		
		System.out.println(c);
	}
}
package com.itheima_02;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

/*
 * 集合的遍历方式：
 * 		1.toArray(),可以把集合转换成数组，然后遍历数组即可
 * 		2.iterator(),可以返回一个迭代器对象，我们可以通过迭代器对象来迭代集合
 * 
 * Iterator：可以用于遍历集合
 * 	E next()  :返回下一个元素
 *  boolean hasNext()  ：判断是否有元素可以获取
 * 
 *  注意：Exception in thread "main" java.util.NoSuchElementException
 *  	使用next方法获取下一个元素，如果没有元素可以获取，则出现NoSuchElementException
	
 */
public class IteratorDemo {
	public static void main(String[] args) {
		//method();
		//创建集合对象
		Collection c = new ArrayList();
		//添加元素
		c.add("hello");
		c.add("world");
		c.add("java");
		
		//获取迭代器对象
		Iterator it = c.iterator();
		
		//Object next()  :返回下一个元素
		//boolean hasNext()  ：判断是否有元素可以获取
		
		/*if(it.hasNext())
			System.out.println(it.next());
		if(it.hasNext())
			System.out.println(it.next());
		if(it.hasNext())
			System.out.println(it.next());
		if(it.hasNext())
			System.out.println(it.next());*/
		
		while(it.hasNext()) {
			System.out.println(it.next());
		}
	}

	private static void method() {
		//创建集合对象
		Collection c = new ArrayList();
		//添加元素
		c.add("hello");
		c.add("world");
		c.add("java");
		//获取数组
		Object[] objs = c.toArray();
		//遍历数组
		for (int i = 0; i < objs.length; i++) {
			System.out.println(objs[i]);
		}
	}

	

}
package com.itheima_02;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

/*
 * 集合的遍历方式：
 * 		1.toArray(),可以把集合转换成数组，然后遍历数组即可
 * 		2.iterator(),可以返回一个迭代器对象，我们可以通过迭代器对象来迭代集合
 * 
 * Iterator：可以用于遍历集合
 * 	E next()  :返回下一个元素
 *  boolean hasNext()  ：判断是否有元素可以获取
 * 
 *  注意：Exception in thread "main" java.util.NoSuchElementException
 *  	使用next方法获取下一个元素，如果没有元素可以获取，则出现NoSuchElementException
	
 */
public class IteratorDemo2 {
	public static void main(String[] args) {
		//method();
		//创建集合对象
		Collection c = new ArrayList();
		//添加元素
		c.add("hello");
		c.add("world");
		c.add("java");
		
		//获取迭代器对象
		Iterator it = c.iterator();
		
		//Object next()  :返回下一个元素
		//boolean hasNext()  ：判断是否有元素可以获取
		
		/*if(it.hasNext())
			System.out.println(it.next());
		if(it.hasNext())
			System.out.println(it.next());
		if(it.hasNext())
			System.out.println(it.next());
		if(it.hasNext())
			System.out.println(it.next());*/
		
		while(it.hasNext()) {
			System.out.println(it.next());
		}
	}

	private static void method() {
		//创建集合对象
		Collection c = new ArrayList();
		//添加元素
		c.add("hello");
		c.add("world");
		c.add("java");
		//获取数组
		Object[] objs = c.toArray();
		//遍历数组
		for (int i = 0; i < objs.length; i++) {
			System.out.println(objs[i]);
		}
	}

	

}
package com.itheima_02;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;

/*
 * 需求：判断集合中是否包含元素java，如果有则添加元素android
 * Exception in thread "main" java.util.ConcurrentModificationException:并发修改异常
 * 迭代器是依赖于集合的，相当于集合的一个副本，当迭代器在操作的时候，如果发现和集合不一样，则抛出异常
 * 
 * 解决方案:
 * 		你就别使用迭代器
 * 		在使用迭代器进行遍历的时候使用迭代器来进行修改
 */
public class IteratorDemo3 {
	public static void main(String[] args) {
		//method();
		
		//创建集合对象
		//Collection c = new ArrayList();
		List c = new ArrayList();
		//添加元素
		c.add("hello");
		c.add("world");
		c.add("java");
		
		//我们可以通过遍历来获取集合中的每一个元素，然后进行比较即可
		/*Iterator it = c.iterator();
		while(it.hasNext()) {
			String s = (String)it.next();
			if(s.equals("java")) {
				c.add("android");
			}
		}*/
		
		ListIterator lit = c.listIterator();
		while(lit.hasNext()) {
			String s = (String)lit.next();
			if(s.equals("java")) {
				lit.add("android");
			}
		}
		
		System.out.println(c);

	}

	private static void method() {
		//创建集合对象
		Collection c = new ArrayList();
		//添加元素
		c.add("hello");
		c.add("world");
		c.add("java");
		//判断集合中是否包含元素java
		if(c.contains("java")) {
			c.add("android");
		}
		
		System.out.println(c);
	}


	

}
package com.itheima_03;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

/*
 * 使用集合存储自定义对象并遍历
 * 由于集合可以存储任意类型的对象，当我们存储了不同类型的对象，就有可能在转换的时候出现类型转换异常，
 * 所以java为了解决这个问题，给我们提供了一种机制，叫做泛型
 * 
 * 泛型：是一种广泛的类型，把明确数据类型的工作提前到了编译时期，借鉴了数组的特点
 * 泛型好处：
 * 			避免了类型转换的问题
 * 			可以减少黄色警告线
 * 			可以简化我们代码的书写
 * 
 * 什么时候可以使用泛型？
 * 		问API，当我们看到<E>，就可以使用泛型了
 * 			
 */
public class GenericDemo {
	public static void main(String[] args) {
		//创建集合对象
		Collection<Student> c = new ArrayList<Student>();
		//创建元素对象
		Student s = new Student("zhangsan",18);
		Student s2 = new Student("lisi",19);
		//添加元素对象
		c.add(s);
		c.add(s2);
		//遍历集合对象
		
		Iterator<Student> it = c.iterator();
		while(it.hasNext()) {
			//String str = (String)it.next();
			//System.out.println(str);
			
			Student stu = it.next();
			System.out.println(stu.name);
		}
	}
}

class Student {
	String name;
	int age;
	
	public Student(String name,int age) {
		this.name = name;
		this.age = age;
	}
}
package com.itheima_04;

import java.util.ArrayList;
import java.util.Collection;

/*
 * foreach:增强for循环，一般用于遍历集合或者数组
 * 格式：
 * 		for(元素的类型 变量 : 集合或者数组对象) {
 * 			可以直接使用变量;
 * 		}
	注意：在增强for循环中不能修改集合，否则会出现并发修改异常。
	
	public interface Iterable<T>
	实现这个接口允许对象成为 "foreach" 语句的目标。

 */
public class ForEachDemo {
	public static void main(String[] args) {
		 //创建集合对象
		Collection<String> c = new ArrayList<String>();
		//添加元素
		c.add("hello");
		c.add("world");
		c.add("java");
		
		//增强for循环遍历集合
		/*for(Object obj : c) {
			System.out.println(obj);
		}*/
		
		
		/*for(String s : c) {
			System.out.println(s.toUpperCase());
		}*/
		
		for (String string : c) {
			c.add("android");
			System.out.println(string);
		}
	}
}
package com.itheima_05;

import java.util.ArrayList;
import java.util.List;

/*
 * List:
 * 		有序的（存储和读取的顺序是一致的）
 * 		有整数索引
 * 		允许重复的
 * 
 * List的特有功能：
 * 			void add(int index, E element)  
 * 			E get(int index)  
 * 			E remove(int index)  
 *  		E set(int index, E element)
 *  
 *   增删改查
 

 *   
 */
public class ListDemo {
	public static void main(String[] args) {
		//创建的列表对象
		List list = new ArrayList();
		
		//void add(int index, E element)  : 在指定索引位置添加指定元素
		list.add(0, "hello");
		list.add(0, "world");
		list.add(1, "java");
		
		//E get(int index)  :根据索引返回元素
		/*System.out.println(list.get(0));
		System.out.println(list.get(1));
		System.out.println(list.get(2));*/
		//System.out.println(list.get(3));
		
		/*for (int i = 0; i < list.size(); i++) {
			System.out.println(list.get(i));
		}*/
		
		//E remove(int index)  : 删除指定元素并返回
		
		//System.out.println(list.remove(5));
		
		//E set(int index, E element) : 将指定索引位置的元素替换为指定元素，并将原先的元素返回
		System.out.println(list.set(0, "android"));
		
		System.out.println(list);
	}
}
package com.itheima_06;

import java.util.LinkedList;

/*
 * List的常用子类：
 * 		ArrayList
 * 			底层是数组结构，查询快，增删慢
 * 		LinkedList
 * 			底层结构是链表，查询慢，增删快
 * 
 * 如何选择使用不同的集合？
 * 		如果查询多，增删少，则使用ArrayList
 * 		如果查询少，增删多，则使用LinkedList
 * 		如果你不知道使用什么，则使用ArrayList
 * 
 * LinkedList的特有功能：
 * 			void addFirst(E e)  
 * 			void addLast(E e) 
 			E getFirst()  
 			E getLast()  
 			E removeFirst() 
 			E removeLast() 
 * 				
 */
public class LinkedListDemo {
	public static void main(String[] args) {
			LinkedList list = new LinkedList();
			list.add("hello");
			list.add("world");
		
			//void addFirst(E e)  :将元素添加到索引为0的位置
 			//void addLast(E e) ：将元素添加到索引为size()-1的位置
			list.addFirst("java");
			list.addLast("android");
			
 			//E getFirst()  :获取索引为0的元素
 			//E getLast()  ：获取索引为size()-1的元素
			//System.out.println(list.getFirst());
			//System.out.println(list.getLast());
			
 			//E removeFirst() :删除索引为0的元素并返回
 			//E removeLast() ：删除索引为size()-1的元素并返回
			System.out.println(list.removeFirst());
			System.out.println(list.removeLast());
			
			
			System.out.println(list);
	}
}
package com.itheima_07;

import java.util.ArrayList;
import java.util.List;

/*
 * 需求：定义一个方法，返回指定列表中指定元素的索引位置
 * 
 * 判断元素是否存在
 * 
 */
public class ListTest {
	public static void main(String[] args) {
		List list = new ArrayList();
		list.add("hello");
		list.add("world");
		list.add("java");
		
		//int index = index(list,"php");
		//System.out.println(index);
		
		//boolean flag = contains(list, "php");
		//System.out.println(flag);
		
		boolean flag = list.contains("php");
		System.out.println(flag);
	}
	
	public static int index(List list,Object other) {
		for(int x = 0;x < list.size();x++) {
			//获取列表中的元素
			Object obj = list.get(x);
			//使用列表中的元素和指定的元素进行比较
			if(obj.equals(other)) {
				return x;
			}
		}
		//查找不到指定的元素
		return -1;
	}
	
	public static boolean contains(List list,Object other) {
		//获取指定元素在指定列表中的索引位置
		int index = index(list,other);
		//如果索引位置大于等于0，则认为元素存在，否则不存在
		if(index >= 0) {
			return true;
		}
		else {
			return false;
		}
	}
	
	
	
}
package com.itcast.day06;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class Test1 {
	
	public static void main(String[] args) {
		Collection  c = new ArrayList<>();
		
		c.add(new Object());
		c.add("abc");
		//
		// boolean contains = c.contains(new Object());
		// System.out.println(contains);
		
		//通过iterator方法获取Iterator对象;
		Iterator iterator = c.iterator();
		//通过对象的hasNext()方法判断有没有下一个元素,如果有就迭代
		while (iterator.hasNext()) {//只是判断有没有下一个,并没有取出
			
			Object next = iterator.next();//这个才是真正取出元素
			System.out.println(next);
		}
		
		System.out.println(c);
		
		
		
		
	}

}
package com.itcast.day06;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

import javax.security.auth.Subject;

public class Test2 {
	public static void main(String[] args) {
		Collection<Student> c = new ArrayList<Student>();

		c.add(new Student("张三", 16));
		c.add(new Student("李四", 17));
		c.add(new Student("王五", 18));
		c.add(new Student("赵六", 19));
		c.add(new Student("吴七", 20));
		Iterator<Student> it = c.iterator();//获取迭代器
		// 定义一个计数器
		int count = 0;
		while (it.hasNext()) {//判断有没有下一个元素
			Student next = it.next();//取出下一个元素;

			if (next.getAge() > 18) {
				count++;
			}
		}
		
		/*Demo<Integer> demo = new Demo<Integer>();
		demo.setT(19);
		
		System.out.println(demo.getT());*/
		
		
	}

}

class Demo1<E>{
	public E getE(E e){
		 return e;
	}
}

class Demo<HELLO> {
	
	private HELLO t;

	public HELLO getT() {
		return t;
	}

	public void setT(HELLO t) {
		this.t = t;
	}
	
}

class Student {
	private String name;
	private int age;

	public Student() {
		super();
		// TODO Auto-generated constructor stub
	}

	public Student(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

}
package com.itcast.day06;

import java.util.ArrayList;
import java.util.List;

public class Test3 {

	public static void main(String[] args) {
		MyStack<String> myStack = new MyStack<String>(new ArrayList<String>());
		
		//压栈
		myStack.popIn("你好");
		myStack.popIn("我好");
		myStack.popIn("静雅好");
		myStack.popIn("静静好");
		myStack.popIn("丫丫好");
		
		
		//弹栈
		System.out.println(myStack.popOut());;
		System.out.println(myStack.popOut());;
		System.out.println(myStack.popOut());;
		System.out.println(myStack.popOut());;
		System.out.println(myStack.popOut());;
		
		
		ArrayList<String> arrayList =new ArrayList<String>();
		
		arrayList.add("niha");
		arrayList.add("wohao");
		arrayList.add("tahao");
		
		//
		System.out.println(arrayList.remove(arrayList.size()-1));
		System.out.println(arrayList.remove(arrayList.size()-1));
		System.out.println(arrayList.remove(arrayList.size()-1));
		

	}

}

class MyStack<E> {
	// 需要有一个容器
	private ArrayList<E> list;

	public MyStack(ArrayList<E> list) {
		super();
		this.list = list;
	}

	public void popIn(E e) {

		list.add(e);//压栈的本质就是将元素存到集合中;

	}
	
	public E popOut(){
		
		if(list.size()==0){
			return null;
		}else{
			return list.remove(list.size()-1);
		}
		
	}

}
package com.itcast.day06;

import java.util.LinkedList;

public class Test4 {
	public static void main(String[] args) {
		Stack<String> stack=new Stack<String>(new LinkedList<>());
		stack.popIn("java");
		stack.popIn("hello");
		stack.popIn("world");
		
		System.out.println(stack.popOut());
		System.out.println(stack.popOut());
		System.out.println(stack.popOut());


	}
}
class Stack<E>{
	private LinkedList<E> linkedList;

	public Stack(LinkedList<E> linkedList) {
		super();
		this.linkedList = linkedList;
	}
	public void popIn(E e) {
		linkedList.add(e);
	}
	public  E popOut(){
		if (linkedList.size()==0) {
			return null;
		}else{
			return linkedList.removeLast();
		}
		
	}
}
package com.itcast.day06;

import java.util.ArrayList;
import java.util.Random;

public class Test5 {

	public static void main(String[] args) {
		// 通过随机数,生成8个偶数,偶数的范围(1-20)之间;
		// 将生成的偶数添加到集合当中;
		// 实现集合去重;

		Random random = new Random();

		ArrayList<Integer> list = new ArrayList<>();// 装备好容器,装随机出来的偶数

		while (true) {
			int ron = random.nextInt(20) + 1;
			if (ron % 2 == 0) {// 证明是一个偶数,我们需要添加集合中
				list.add(ron);
				if (list.size() == 8) {// 当我们的集合装了8个偶数的时候就不要循环了;
					break;
				}

			}
		}
		System.out.println(list);
		// 走到这里,集合中已经装满了8个元素

		// 装备新的容器
		ArrayList<Integer> arrayList = new ArrayList<>();

		for (Integer integer : list) {

			// 我需要将老集合中的元素放到新集合中,放的时候需要判断新集合是否包含了这个元素
			if (!arrayList.contains(integer)) {

				arrayList.add(integer);
			}
		}
		
		System.out.println(arrayList);

	}

}
1.集合的框架
	是根据干爹来学习的
	ArrayList ---> List --->Collection;

	contains 方法是将传进来的元素和集合中所有的元素的equals 判断是否是相同,如果对象的equals方法没有重写,默认比较的就是地址值;


	集合和数组的区别
		1.集合的长度可以改变,数组一旦确定就不能改变
		2.数组只能存储一类事物; 集合可以存多类事物
		3.集合中只能存储引用数据类型, 而数组都可以存储;
2.并发修改异常
	在用迭代器遍历集合的时候,采用了集合的增删操作就会出现并发修改异常;

	如何避免;
		1.不用迭代器
		2.采用迭代器的增删对集合进行增删操作;

		3.并发修改异常出现的根本原因
			副本(创建集合的时候集合会随之生成一个数组副本,而数组的长度是不可以改变的)的长度和集合长度冲突了;

			为什么用迭代器就可以删除:
				因为迭代器是生成一个新的数组;这样的话,集合的长度和副本的长度就相匹配;
3.泛型的优点
	1.减少了强制类型转化的问题
	2.将运行时的问题提前到了编译期间;


	泛型在以后工作中的使用:
		当一个类中有不确定的成员的时候就需要定义泛型啊;

4. 增强for的格式
	for(数据类型 变量名 : 需要迭代的数组或者集合对象名){
	}
5,.数组结构的特点
	查找块,增删慢;
6.链表结构
	查询慢,增删快;
7. 栈的特点
		先进后出
   队列的特点
		先进先出;
8.List是列表     
	元素存储有序, 存储和取出的顺序是一致
	有角标,元素可以重复

    增删改查的操作
	void add(int index, E e);//在指定位置添加元素;后面元素顺延;
	boolean add(E e);//collection里面的方法;
	E set(int index,E e);//可以将指定位置上的元素修改并返回被修改的元素
	remove(E e)//这个是collection里面继承过来,删除指定元素
	E remove(int index);//删除指定位置的元素,并将删除元素返回;

	list.listIteroter();//这个迭代器里面提供了添加方法;

9.
	定义栈的格式
	  1.首先定义一个类
	  2.定义一个成员变量,成员是一个容器(集合)
	  3.在创建这个类时候需要给定容器
	  4.提供压栈弹栈方法






package com.itheima_01;
/*
 * 需求：实现学号和姓名这样有对应关系的数据存储
 * 为了体现这种有对应关系的数据，我们使用以前所学的内容是可以实现的，但是略有不变，所以java又给我买提供了一种专门用于存储对应关系的集合，Map
 * 
 * Map:将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值
 * 
 * Map和Collection有什么区别？
 * 			Map:是一个双列集合，常用语处理有对应关系的数据，key是不可以重复的，我们也称之为是夫妻对集合
 * 			Collection:是单列集合，Collection有不同的子体系，有的允许重复有索引有序，有的不允许重复而且无序，那么我们也称之为单身汉集合
 * 
 * 一对一：一个学号对应一个姓名
 * 
 */
public class MapDemo {

}
package com.itheima_01;

import java.util.HashMap;
import java.util.Map;

/*
 * 	Map的常用功能：
 * 		映射功能：
 * 			 	V put(K key, V value) 
 * 		获取功能：
 * 				V get(Object key) 
 * 				int size() 
 * 		判断功能：
 * 				boolean containsKey(Object key) 
 				boolean containsValue(Object value) 
 				boolean isEmpty() 
 
 * 		删除功能：
 * 				void clear()  
 * 				V remove(Object key)  
 * 
 * 		遍历功能：
 * 				Set<Map.Entry<K,V>> entrySet() 
 * 
 * 
 * 			Set<K> keySet()  
 * 			Collection<V> values()  
 
 */
public class MapDemo2 {
	public static void main(String[] args) {
		//创建Map对象
		Map<String,String> map = new HashMap<String,String>();
		
		//V put(K key, V value) ：就是将key映射到value，如果key存在，则覆盖value，并将原来的value返回
		System.out.println(map.put("ITCAST001", "张三"));
		System.out.println(map.put("ITCAST002", "李四"));
		System.out.println(map.put("ITCAST001", "王五"));
		
		//void clear() : 清空所有的对应关系  
		//map.clear();
		
		//V remove(Object key) :根据指定的key删除对应关系，并返回key所对应的值，如果没有删除成功则返回null
		//System.out.println(map.remove("ITCAST005"));
		
		//boolean containsKey(Object key) : 判断指定key是否存在
		//System.out.println(map.containsKey("ITCAST003"));
		
		//boolean containsValue(Object value)：判断指定的value是否存在
		//System.out.println(map.containsValue("王五"));
		
		//boolean isEmpty() : 判断是否有对应关系
		//System.out.println(map.isEmpty());
		
		//int size() : 返回对应关系的个数
		//System.out.println(map.size());
		
		//V get(Object key) : 根据指定的key返回对应的value
		System.out.println(map.get("ITCAST002"));
		
		System.out.println(map);
	}
}
package com.itheima_01;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/*
 * 	Set<K> keySet()  
 * 	Collection<V> values() 
 */
public class MapDemo3 {
	public static void main(String[] args) {
		//创建Map对象
		Map<String,String> map = new HashMap<String,String>();
		//添加映射关系
		map.put("ITCAST001", "张三");
		map.put("ITCAST002", "李四");
		map.put("ITCAST005", "李四");
		
		//Set<K> keySet() : 以Set的形式获返回所有的key
		Set<String> keys = map.keySet();
		for (String key : keys) {
			System.out.println(key);
		}
		System.out.println("-----------");
		
		//Collection<V> values() :
		Collection<String> values = map.values();
		for (String value : values) {
			System.out.println(value);
		}
		
		
	}
}
package com.itheima_01;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/*
 * 	Map的第一种遍历方式：
 * 			首先召集所有的丈夫
 * 			遍历所有的丈夫
 * 			获取每一个丈夫
 * 			让每一个丈夫去找他自己的媳妇
 */
public class MapDemo4 {
	public static void main(String[] args) {
		//创建Map对象
		Map<String,String> map = new HashMap<String,String>();
		//添加映射关系
		map.put("谢婷疯", "张箔纸");
		map.put("陈关西", "钟欣桶");
		map.put("李亚碰", "王飞");
		//遍历Map对象
		
		//首先召集所有的丈夫
		Set<String> keys = map.keySet();
		//遍历所有的丈夫
		for (String key : keys) {
			//让每个丈夫去找他自己的媳妇就可以了
			String value = map.get(key);
			System.out.println("丈夫：" + key + "---" + "媳妇：" + value);
		}
		
	}
}
package com.itheima_01;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/*
 * 	Map的第二种遍历方式：
 * 		通过结婚证对象来获取丈夫和媳妇
 * 
 *  class 结婚证<K,V> {
 *  	K 丈夫;
 *  	V 媳妇;
 *  
 *  	public 结婚证(K 丈夫，V 媳妇) {
 *  		this.丈夫 = 丈夫;
 *  		this.媳妇 = 媳妇;
 *  	}
 *  
 *  
 *  	public K get丈夫() {
 *  		return 丈夫;
 *  	}
 *  
 *  	public V get媳妇() {
 *  		return 媳妇;
 *  	}
 *  }
 *  
 *  
 *  class Entry<K,V> {
 *  	K key;
 *  	V value;
 *  
 *  	public Entry(K key，V value) {
 *  		this.key = key;
 *  		this.value = value;
 *  	}
 *  
 *  
 *  	public K getKey() {
 *  		return key;
 *  	}
 *  
 *  	public V getValue() {
 *  		return value;
 *  	}
 *  }
 *  
 *  Set<Map.Entry<K,V>> entrySet()  
 * 
 */
public class MapDemo5 {
	public static void main(String[] args) {
		//创建Map对象
		Map<String,String> map = new HashMap<String,String>();
		//添加映射关系
		map.put("尹志平", "小龙女");
		map.put("令狐冲", "东方菇凉");
		map.put("玄慈", "叶二娘");
		//获取所有的结婚证对象
		Set<Map.Entry<String,String>> entrys = map.entrySet();
		//遍历包含了结婚证对象的集合
		for (Map.Entry<String, String> entry : entrys) {
			//获取每个单独的结婚证对象
			//通过结婚证对象获取丈夫和媳妇
			String key = entry.getKey();
			String value = entry.getValue();
			
			System.out.println("丈夫：" + key + "---" + "媳妇:" + value);
		}
		
	}
}
package com.itheima_02;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/*
 * 
 * 使用HashMap存储数据并遍历（字符串作为key）
 * 
 */
public class HashMapDemo {
	public static void main(String[] args) {
		//创建Map对象
		HashMap<String,String> hm = new HashMap<String,String>();
		//添加映射关系
		hm.put("ITCAST001", "张三");
		hm.put("ITCAST002", "李四");
		hm.put("ITCAST003", "王五");
		hm.put("ITCAST003", "赵六");
		//遍历Map对象
		
		//方式1 获取所有的key，通过key来获取value
		Set<String> keys = hm.keySet();
		for (String key : keys) {
			String value = hm.get(key);
			System.out.println(key + "=" + value);
		}
		
		System.out.println("------------------");
		
		//方式2：获取所有的结婚证对象，然后通过结婚证对象获取丈夫和媳妇
		Set<Map.Entry<String, String>> entrys = hm.entrySet();
		for (Map.Entry<String, String> entry : entrys) {
			String key = entry.getKey();
			String value = entry.getValue();
			System.out.println(key + "=" + value);
		}
	}
}
package com.itheima_02;

import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

/*
 * 
 * 使用HashMap存储数据并遍历（自定义对象作为key）
 * 
 */
public class HashMapDemo2 {
	public static void main(String[] args) {
		//创建Map对象
		HashMap<Student,String> hm = new HashMap<Student,String>();
		//创建key对象
		Student s = new Student("zhangsan",18);
		Student s2 = new Student("lisi",20);
		Student s3 = new Student("lisi",20);
		
		//添加映射关系
		hm.put(s, "ITCAST001");
		hm.put(s2, "ITCAST002");
		hm.put(s3, "ITCAST002");
		
		//遍历Map对象
		//方式1： 获取所有的key，通过key来获取value
		Set<Student> keys = hm.keySet();
		for (Student key : keys) {
			String value = hm.get(key);
			System.out.println(key + "=" + value);
		}
		System.out.println("-----");
		
		//方式2：获取所有结婚证对象，通过结婚证对象获取丈夫和媳妇
		Set<Map.Entry<Student, String>> entrys = hm.entrySet();
		for (Entry<Student, String> entry : entrys) {
			Student key = entry.getKey();
			String value = entry.getValue();
			
			System.out.println(key + "=" + value);
		}
		
	}
}
package com.itheima_02;

public class Student {
	String name;
	int age;
	
	public Student(String name,int age) {
		this.name = name;
		this.age = age;
	}

	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + "]";
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + age;
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Student other = (Student) obj;
		if (age != other.age)
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}
	
	
	
	
}
package com.itheima_01;

import java.util.HashSet;

/*
 *	使用HashSet存储字符串并遍历 	
 *	
 *	Set的特点：
 *			 无序（存储和读取的顺序可能不一样）
 *			不允许重复
 *			没有整数索引

 */
public class HashSetDemo {
	public static void main(String[] args) {
		//创建集合对象
		//Set set = new HashSet();
		HashSet<String> set = new HashSet<String>();
		//添加元素
		set.add("hello");
		set.add("world");
		System.out.println(set.add("java"));
		System.out.println(set.add("java"));
		
		//遍历集合对象
		for(String s : set) {
			System.out.println(s);
		}
		
	}
}
package com.itheima_01;

import java.util.HashSet;

/*
 *	使用HashSet存储自定义对象并遍历 	
 *	通过查看源码发现：
 *				HashSet的add()方法，首先会使用当前集合中的每一个元素和新添加的元素进行hash值比较，
 *				如果hash值不一样，则直接添加新的元素
 *				如果hash值一样，比较地址值或者使用equals方法进行比较
 *				比较结果一样，则认为是重复不添加
 *				所有的比较结果都不一样则添加

 */
public class HashSetDemo2 {
	public static void main(String[] args) {
		//创建集合对象
		HashSet<Student> hs = new HashSet<Student>();
		//创建元素对象
		Student s = new Student("zhangsan",18);
		Student s2 = new Student("lisi",19);
		Student s3 = new Student("lisi",19);
		//添加元素对象
		hs.add(s);
		hs.add(s2);
		hs.add(s3);
		//遍历集合对象
		for (Student student : hs) {
			System.out.println(student);
		}
		 
	}
		 
}

class Student {
	String name;
	int age;
	
	public Student(String name,int age) {
		this.name = name;
		this.age = age;
	}

	@Override
	public String toString() {
		return "Student [name=" + name + ", age=" + age + "]";
	}
	
	
	@Override
	public boolean equals(Object obj) {
		//System.out.println("-------------------");
		Student s = (Student)obj;//向下转型，可以获取子类特有成员
		
		//比较年龄是否相等，如果不等则返回false
		if(this.age != s.age) {
			return false;
		}
		
		//比较姓名是否相等，如果不等则返回false
		if(!this.name.equals(s.name)) {
			return false;
		}
		
		//默认返回true，说明两个学生是相等的
		return true;
	}
	
	@Override
	public int hashCode() {
		return 1;
	}
	
}
package com.itheima_02;

import java.util.HashSet;

public class HashSetDemo3 {
	public static void main(String[] args) {
		//创建集合对象
		HashSet<Person> hs = new HashSet<Person>();
		//创建元素对象
		Person p = new Person("zhangsan",20);
		Person p2 = new Person("lisi",20);
		Person p3 = new Person("lisi",20);
		//添加元素对象
		hs.add(p);
		hs.add(p2);
		hs.add(p3);
		//遍历集合对象
		for (Person person : hs) {
			System.out.println(person);
		}
		
	}
}
package com.itheima_02;

public class Person {
	String name;
	int age;
	
	public Person(String name,int age) {
		this.name = name;
		this.age = age;
	}

	@Override
	public String toString() {
		return "Person [name=" + name + ", age=" + age + "]";
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + age;
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Person other = (Person) obj;
		if (age != other.age)
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		return true;
	}
	
	/*
	@Override
	public int hashCode() {
		
		 * 我们发现当hashCode方法永远返回整数1时，所有对象的hash值都是一样的，
		 * 有一些对象他的成员变量完全不同，但是他们还需要进行hash和equals方法的比较，
		 * 如果我们可以让成员变量不同的对象，他们的hash值也不同，这就可以减少一部分equals方法的比较
		 * 从而可以提高我们程序的效率
		 * 
		 * 可以尝试着让hashCode方法的返回值和对象的成员变量有关
		 * 可以让hashCode方法返回所有成员变量之和，
		 * 让基本数据类型直接想加，然后引用数据类型获取hashCode方法返回值后再相加（boolean不可以参与运算）
		 * 
		 
		//return age;
		return age + name.hashCode();
	}
	
	@Override
	public boolean equals(Object obj) {
		System.out.println("-------------");
		
		//提高效率
		if(this == obj) {
			return true;
		}
		
		//提高健壮性
		if(this.getClass() != obj.getClass()) {
			return false;
		}
		
		
		
		//向下转型
		Person p = (Person)obj;
		
		if(!this.name.equals(p.name)) {
			return false;
		}
		
		if(this.age != p.age) {
			return false;
		}
		
		return true;
		
	}*/
	
	
	
}
package com.itheima_03;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/*
 * Collections：
 * 面试题：Collection和Collections有什么区别？
 * 		Collection是集合体系的最顶层，包含了集合体系的共性
 * 		Collections是一个工具类，方法都是用于操作Collection
 * 
 */
public class CollectionsDemo {
	public static void main(String[] args) {
		//static void swap(List list, int i, int j) :将指定列表中的两个索引进行位置互换
		List<Integer> list = new ArrayList<Integer>();
		list.add(1);
		list.add(4);
		Collections.swap(list, 0, 1);
		
		System.out.println(list);
	
	}

	private static void method6() {
		//static void  sort(List<T> list) :按照列表中元素的自然顺序进行排序
		List<Integer> list = new ArrayList<Integer>();
		list.add(1);
		list.add(4);
		list.add(3);
		list.add(2);
		
		Collections.sort(list);
		System.out.println(list);
	}

	private static void method5() {
		//static void shuffle(List list):傻否，随机置换  
		List<Integer> list = new ArrayList<Integer>();
		list.add(1);
		list.add(2);
		list.add(3);
		list.add(4);
		Collections.shuffle(list);
		System.out.println(list);
	}

	private static void method4() {
		//static void reverse(List list)  :反转
		List<Integer> list = new ArrayList<Integer>();
		list.add(1);
		list.add(2);
		list.add(3);
		list.add(4);
		
		Collections.reverse(list);
		System.out.println(list);
	}

	private static void method3() {
		//static void fill(List list, Object obj) :使用指定的对象填充指定列表的所有元素
		List<String> list = new ArrayList<String>();
		list.add("hello");
		list.add("world");
		list.add("java");
		System.out.println(list);
		
		Collections.fill(list, "android");
		
		System.out.println(list);
	}

	private static void method2() {
		//static void copy(List dest, List src) :是把源列表中的数据覆盖到目标列表
		//注意：目标列表的长度至少等于源列表的长度
		//创建源列表
		List<String> src = new ArrayList<String>();
		src.add("hello");
		src.add("world");
		src.add("java");
		
		//创建目标列表
		List<String> dest = new ArrayList<String>();
		dest.add("java");
		dest.add("java");
		dest.add("java");
		dest.add("java");
		Collections.copy(dest, src);
		System.out.println(dest);
	}

	private static void method() {
		//static int  binarySearch(List list, Object key) 使用二分查找法查找指定元素在指定列表的索引位置 
		List<Integer> list = new ArrayList<Integer>();
		list.add(1);
		list.add(2);
		list.add(3);
		list.add(4);
		
		int index = Collections.binarySearch(list, 4);
		System.out.println(index);
	}
}
package com.itheima_03;

import java.util.ArrayList;
import java.util.Collections;

/*
 *	模拟斗地主发牌 
 	
 	买牌
 	洗牌
 	发牌
 
 */
public class CollectionsTest {
	public static void main(String[] args) {
		//买牌
		String[] arr = {"黑桃","红桃","方片","梅花"};
		String[] arr2 = {"A","2","3","4","5","6","7","8","9","10","J","Q","K"};
		
		ArrayList<String> box = new ArrayList<String>();
		//添加每张牌
		for (int i = 0; i < arr.length; i++) {
			//获取每一个花色
			for (int j = 0; j < arr2.length; j++) {
				//获取每一个数
				box.add(arr[i] + arr2[j]);
			}
			
		}
		box.add("大王");
		box.add("小王");
		//System.out.println(box.size());
		
	 	//洗牌
		Collections.shuffle(box);
		//System.out.println(box);
		
	 	//发牌
		ArrayList<String> 林志玲 = new ArrayList<String>();
		ArrayList<String> 林心如 = new ArrayList<String>();
		ArrayList<String> 舒淇 = new ArrayList<String>();
		
		//留三张底牌给地主
		for (int i = 0; i < box.size() - 3; i++) {
			/*
			 *  i = 0;i % 3 = 0;
			 *  i = 1;i % 3 = 1;
			 *  i = 2;i % 3 = 2;
			 *  i = 3;i % 3 = 0;
			 *  i = 4;i % 4 = 1;
			 *  i = 5;i % 5 = 2;
			 */
			
			if(i % 3 == 0) {
				林志玲.add(box.get(i));
			}
			else if(i % 3 == 1) {
				林心如.add(box.get(i));
			}
			else if(i % 3 == 2) {
				舒淇.add(box.get(i));
			}
		}
		
		System.out.println("林志玲：" + 林志玲);
		System.out.println("林心如：" + 林心如);
		System.out.println("舒淇：" + 舒淇);
	 
	
		System.out.println("底牌：");
	/*	System.out.println(box.get(box.size() - 1));
		System.out.println(box.get(box.size() - 2));
		System.out.println(box.get(box.size() - 3));*/
		
		for (int i = box.size() - 3; i < box.size(); i++) {
			System.out.println(box.get(i));
		}
	}
	
}
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class DouDiZhuPaiXu {
	
	//鍒嗘瀽 鎴戜滑鐭ラ亾鐗岀殑椤哄簭1-13杩欐牱鎺掑垪濂界殑, 
	//鎵�浠ユ垜浠鍏�,蹇呴』鏈変竴涓帓鍒楄鍒�,鎴戜滑搴旇鎸夌収瑙勫垯鍘绘帓鍒楀氨琛屼簡,杩欎釜瑙勫垯鏄笉鑳芥敼鍙樼殑;
	//鎴戜滑鑳芥敼鍙樼殑鏄�,姣忎綅鐜╁鎷垮埌鐨勮鍒欑殑瑙掓爣鍊�;
	//灏嗙墝鐨勮鏍囨墦涔�;
	//姣忎竴涓敤鎴峰彂鐨勫叾瀹炲氨鏄鍒欏搴旂殑瑙掓爣,涔熷氨鏄竴涓猧nt鍊�
	//閫氳繃collections鐨剆ort鏂规硶瀵规瘡涓�浣嶇帺瀹剁殑瑙掓爣鍊艰繘琛屾帓搴�,鐒跺悗鏍规嵁鎺掑ソ搴忕殑瑙掓爣鍊�,鍘昏鍒欐壘鐗屽氨浼氬畬鎴愭帓搴忔晥鏋�

	public static void main(String[] args) {
		String[] arr = { "鈾�", "鈾�", "鈾�", "鈾�" };
		String[] arr1 = { "A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K" };
		int m = 0;
		ArrayList<Integer> indexs = new ArrayList<>();//鎵�鏈夌墝鐨勮鏍�
		ArrayList<String> cards = new ArrayList<>();//鎵�鏈夌殑鐗�,涔熷氨鏄鍒�,瑙勫垯鐨勬帓鍒楅『搴忚鍒欎笉鍙�
		for (int i = 0; i < arr1.length; i++) {
			String string1 = arr1[i];

			for (int j = 0; j < arr.length; j++) {
				String string2 = arr[j];
				cards.add(string1 + string2);//灏嗙墝鐨勮鍒欏畾涔夊ソ

				indexs.add(m);//灏嗚鏍囨坊鍔犲埌 瑙掓爣鐨勯泦鍚堝綋涓�
				m++;

			}
		}

		cards.add("澶х帇");//娣诲姞鏈坊鍔犵殑鐗�
		cards.add("灏忕帇");
		indexs.add(52);//娣诲姞鏈坊鍔犵殑瑙掓爣
		indexs.add(53);
		//娲楃殑瑙掓爣
		Collections.shuffle(indexs);//娉ㄦ剰鎵撲贡鐨勬槸瑙掓爣

		ArrayList<Integer> list1 = new ArrayList<>();
		ArrayList<Integer> list2 = new ArrayList<>();
		ArrayList<Integer> list3 = new ArrayList<>();
		ArrayList<Integer> list4 = new ArrayList<>();

		for (int i = 0; i < indexs.size() - 3; i++) {//缁欐瘡涓帺瀹跺垎鍙戣鏍�

			if (i % 3 == 0) {
				list1.add(indexs.get(i));

			} else if (i % 3 == 1) {
				list2.add(indexs.get(i));

			} else if (i % 3 == 2) {
				list3.add(indexs.get(i));

			}

		}
		//灏嗗簳鐗岀殑瑙掓爣娣诲姞杩涘幓
		list4.add(indexs.get(arr.length-1));
		list4.add(indexs.get(arr.length-2));
		list4.add(indexs.get(arr.length-3));
		
		
		
		//缁欐墍鏈夌帺瀹剁殑鎷垮埌鐨勮鏍囪繘琛屾帓搴�
		Collections.sort(list1);
		Collections.sort(list2);
		Collections.sort(list3);
		Collections.sort(list4);
		//鍒涘缓鍑烘瘡涓帺瀹剁墝鐨勯泦鍚�
		ArrayList<String> qing = new ArrayList<>();
		ArrayList<String> zhi = new ArrayList<>();
		ArrayList<String> ru = new ArrayList<>();
		ArrayList<String> dipai = new ArrayList<>();
		//閫氳繃鎺掑ソ鐨勮鏍囬『搴忓幓鎷跨墝;
		findCard(list1, qing, cards);
		findCard(list2, zhi, cards);
		findCard(list3, ru, cards);
		findCard(list4, dipai, cards);
		
		//鐪嬬墝
		System.out.println(qing);
		System.out.println(zhi);
		System.out.println(ru);
		System.out.println(dipai);

	}
	//閫氳繃鎺掑ソ搴忕殑瑙掓爣鎵剧墝
	/**
	 * 
	 * @param indexs  姣忎綅鐜╁鎺掑ソ瑙掓爣椤哄簭鐨勯泦鍚�
	 * @param player  姣忎綅鐜╁瀹為檯鐗岀殑闆嗗悎
	 * @param sort    瑙勫垯闆嗗悎(闇�瑕侀�氳繃鎺掑ソ搴忕殑瑙掓爣鏌ュ疄闄呯墝,娣诲姞鍒扮帺瀹跺疄闄呯墝鐨勯泦鍚堝綋涓�)
	 */
	public static void findCard(ArrayList<Integer> sortIndex,ArrayList<String> player,ArrayList<String> sort){
		for (int i = 0; i < sortIndex.size(); i++) {
			player.add(sort.get(sortIndex.get(i)));
		}
	}
	
	

}
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Random;

public class Test1 {

	// 分析以下需求，并用代码实现
	// (1)生成10个1至100之间的随机整数(不能重复)，存入一个List集合
	// (2)然后利用迭代器和增强for循环分别遍历集合元素并输出
	// (3)如：15 18 20 40 46 60 65 70 75 91

	public static void main(String[] args) {
		// 1.创建随机数对象
		Random random = new Random();
		// 创建集合对象
		List<Integer> list = new ArrayList<>();

		// 为什么用while循环,因为不知道循环次数;
		while (list.size() != 10) {

			int num = random.nextInt(100) + 1;
			// 如果集合中不存在才添加到集合中
			if (!list.contains(num)) {
				list.add(num);
			}

		}

		// 用迭代器遍历
		// 1.获取迭代器对象
		Iterator<Integer> iterator = list.iterator();

		while (iterator.hasNext()) {// 判断副本中下一个是否存在
			// 走到这里说明存在
			System.out.println(iterator.next());

		}
		
		sort(list);
		
		for (Integer integer : list) {
			System.out.print(integer+" ");
		}

	}

	public static void sort(List<Integer> list) {

		for (int i = 0; i < list.size() - 1; i++) {

			for (int j = 0; j < list.size() - 1 - i; j++) {
				// 取出左边
				Integer left = list.get(j);
				// 取出右边
				Integer right = list.get(j + 1);
				// 如果左边比右边大,就交换位置
				if (left > right) {
//					int temp = left;
//					left = right;
//					right = temp;
					list.set(j, right);
					list.set(j+1, left);
				}
			}

		}

	}

	public static void sort(int[] arr) {

		for (int i = 0; i < arr.length - 1; i++) {// 为什么-1;

			for (int j = 0; j < arr.length - 1 - i; j++) {// 为什么-i ,
				int k = arr[j];// 取出左边的
				int l = arr[j + 1];

				if (k > l) {
					int temp = arr[j + 1];
					arr[j + 1] = arr[j];
					arr[j] = temp;
				}

			}

		}

	}

}
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

//分析以下需求，并用代码实现
//(1)定义List集合，存入多个字符串
//(2)删除集合元素字符串中包含0-9数字的字符串(只要字符串中包含0-9中的任意一个数字就需要删除此整个字符串)
//(3)然后利用迭代器遍历集合元素并输出
public class Test2 {

	public static void main(String[] args) {
		List<String> list = new ArrayList<>();

		list.add("419开心玩");
		list.add("51去哪玩");
		list.add("61吃什么棒棒糖");
		list.add("都成年了还矫情");
		list.add("还是好好敲代码吧");
		list.add("324543");
		list.add("324543");

		/*for (int i = 0; i < list.size(); i++) {// 遍历集合, 拿到每一个字符串
			String s = list.get(i);

			char[] charArray = s.toCharArray();
			for (int j = 0; j < charArray.length; j++) {
				char c = charArray[j];
				if (c >= '0' && c <= '9') {// 有数字,就删除
					list.remove(i);
					i--;
					break;

				}
			}
		}
		
		System.out.println(list);*/
		
		Iterator<String> iterator = list.iterator();
		while(iterator.hasNext()){
			String next = iterator.next();
			for (int i = 0; i < next.length(); i++) {
				char c = next.charAt(i);
				if (c >= '0' && c <= '9') {// 有数字,就删除
					iterator.remove();
					break;

				}
				
			}
		}
		

	}

}
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public class Test3 {

	public static void main(String[] args) {
//		Set<String> set = new HashSet<>();
//
//		set.add("419好玩吗");
//		set.add("你猜");
//		set.add("猜你妹");
//		set.add("猜你妹");
//		
//		
//		String[] array = set.toArray(new String[set.size()] );
//		
//		for (int i = 0; i < array.length; i++) {
//			System.out.println(array[i]);
//		}
//		
//		Iterator<String> iterator = set.iterator();
//		
//		while(iterator.hasNext()){
//			String next = iterator.next();
//			
//		}
		
		Set<Demo> set = new HashSet<>();
		
		
		Demo demo = new Demo(24, 12);
		Demo demo2 = new Demo(24, 12);
		
		set.add(demo);
		
		boolean contains = set.contains(demo2);//如果只走Equls 应该返回true , 如果走了HashCode就应该返回false,
		System.out.println(contains);
		
		
		
		
		
		
		
		
	}

}

class Demo{
	int age ;
	int number;
	public Demo(int age, int number) {
		super();
		this.age = age;
		this.number = number;
	}
	
	

//	@Override
//	public int hashCode() {
//		final int prime = 31;
//		int result = 1;
//		result = prime * result + age;
//		result = prime * result + number;
//		return result;
//	}



	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Demo other = (Demo) obj;
		if (age != other.age)
			return false;
		if (number != other.number)
			return false;
		return true;
	}
	
	
	
	
}
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class Test5 {
	
	public static void main(String[] args) {
		Map<String, String> map = new HashMap<>();
		
		//添加元素,修改值的功能
		map.put("姓名", "林青霞");
		map.put("年龄", "25岁");
		map.put("身高", "160");
		String put = map.put("姓名", "盘长江");
		System.out.println(put);
		
		
		//删除功能
		String remove = map.remove("年龄");//删除指定的键对应的关系, 并且将此对应的值返回, 
		System.out.println(map);
		//查询功能
		String string = map.get("姓名");
		System.out.println(string);
		System.out.println("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
		//拿到所有的屬性
		Set<String> keySet = map.keySet();
		for (String string2 : keySet) {
			System.out.println(string2);
		}
		//拿到所有的值
		Collection<String> values = map.values();
		for (String string2 : values) {
			System.out.println(string2);
		}
		
		
		//第一种遍历Map的方法
		//拿到丈夫
		Set<String> keySet2 = map.keySet();
		
		//通过遍历丈夫,拿到每一个丈夫,让每一个丈夫找媳妇
		for (String husband : keySet2) {
			
			String wife = map.get(husband);
			System.out.println("丈夫:"+husband +",老婆:"+wife);
		}
		
		
		
		
		
		
	}

}
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

public class Test6 {

	public static void main(String[] args) {
		Map<String, String> map = new HashMap<>();

		map.put("小狼狗", "白拜何");
		map.put("没老师", "有老师");
		map.put("张老师", "苍老师");

		Set<Entry<String, String>> entrySet = map.entrySet();

		for (Entry<String, String> entry : entrySet) {
			String husband = entry.getKey();// 获取到丈夫
			String wife = entry.getValue();
			System.out.println("丈夫:" + husband + ",妻子:" + wife);
		}
	}

}
import java.util.HashMap;
import java.util.Map;

public class Test7 {
	
	public static void main(String[] args) {
		int[] arr = {12,34,45,7512,12,34,23,45};//统计出,每个数出现的次数
		//准备Map集合,来存储键值对关系
		Map<Integer, Integer> map = new HashMap<>();
		//1.遍历数组
		for (int i = 0; i < arr.length; i++) {
			//取出每一个元素
			int j = arr[i];
			
			//首先判断我有没有存储过这个键
			boolean containsKey = map.containsKey(j );
			
			if(!containsKey){//不包含,说明是第一次出现, 应该存 这个键, 后面值1
				map.put(j, 1);
			}else{//包含, 说明已经出现过了,应该取出原来的键对应的值,然后对值+1操作后,在存储回去
				Integer integer = map.get(j)+1;
				map.put(j, integer);
			}
			
		}
		
		System.out.println(map);
		
	}

}
1.Set的特点
	1.无序
	2.元素不能重复
	3.没有索引
2.HashSet 的去重的标准
	1. 当hashCode 和equls方法同时相同的时候就是重复元素;

	HashSet的contains()方法和我们List的contains方法不太一样, 他首先比较的是hashcode,然后在比较equals
	而List中contains方法只比较Equals;
3.Map 是专门处理对应关系的数据
	Map 夫妻俩集合,键值对数据;
	Collection 这个是单身汉集合;
	HashMap中键其实就是一个HashSet集合;右边就是一个Collection集合;

	也就是键是唯一的(键的唯一性和HashSet判断唯一性的规则一样)
4.Map遍历方法
	map本身没有遍历方法,只能通过转成单列集合,
	有两种:
		1.找到所有的丈夫, 通过丈夫去找妻子;
		2.找到所有的孩子,通过孩子去找老爸,老妈;

 


package com.itheima_01;

import java.io.FileWriter;

/*
 * Exception in thread "main" java.lang.ArithmeticException: / by zero
	at com.itheima_01.ExceptionDemo.main(ExceptionDemo.java:5)
	我们在写代码的时候，经常的出现一些小问题，那么为了方便我们处理这些问题，java为我们提供了异常机制
	
	异常包含了错误的类型、原因以及位置
	
	异常：不正常，我们在代码的时候出现的编译或者运行时的错误
	
	异常的体系结构：
			Throwable（最顶层）
					Error:出现的不能够处理的严重问题
					Exception:可以处理的问题
					
	电脑坏了：
		系统中毒：重装系统就可以了
		主板坏了：买一台新的
 * 
 */
public class ExceptionDemo {
	public static void main(String[] args) {
		//int a = 10 / 0;
		//System.out.println(a);
		
		//FileWriter fw = new FileWriter("a.txt");
	}
}
package com.itheima_01;

import java.io.FileWriter;
import java.io.IOException;

/*
 * 	异常的处理方式：
 * 			捕获处理
 * 				try...catch语句
 * 
 * 				try {
 * 					有可能出现问题的代码;
 * 				} catch(ArithmeticException ae) {
 * 					处理异常;
 * 				}
 * 
 * 				try...catch的执行顺序：
 * 					首先执行try语句
 * 						如果发现异常，异常下面的代码不在执行，直接跳入catch语句中，catch语句结束后，整个try...catch结束
 * 						如果没有发现异常，try语句执行结束后，try...catch直接结束， 不在执行catch语句
 * 
 * 
 * 			抛出去
 * 				当我们不想处理异常，或者没有能力处理的时候，我们可以选择抛出异常，谁调用方法谁处理异常
 * 				使用关键字throws在方法的声明出抛出异常

 * 		
 * 
 *  jvm处理异常的方式：
 *  	如果出现异常我们没有处理，jvm会帮我们进行处理，他会把异常的类型，原因还有位置显示在命令行
 *  	并且还终止了程序，异常后面的代码将不在执行
 */
public class ExceptionDemo2 {
	public static void main(String[] args) throws Exception {
		//method();
		
		function();
		
	}
	
	public static void function() throws Exception {
		FileWriter fw = new FileWriter("a.txt");
	}

	private static void method() {
		try {
			System.out.println(1);
			//System.out.println(2 / 0);
			System.out.println(2);
		} catch(ArithmeticException ae) {
			System.out.println("除数不能为0");
		}
		
		System.out.println(3);
	}

}
package com.itheima_01;
/*
 * 	如何处理多个异常：
 * 		可以使用多个try...catch语句
 * 		使用一个try和多个catch
 * 
 * 多个catch之间的顺序：
 * 			多个catch之间可以有子父类
 * 			平级之间没有顺序关系
 * 			如果有子父类，父类异常必须放在后面
 * 			
 * 	
 */
public class ExceptionDemo3 {
	public static void main(String[] args) {
		try {
			String s = null;
			System.out.println(s.length());
			
			//int[] arr = new int[5];
			//System.out.println(arr[8]);
			
			//System.out.println(2 / 0);
			
		} 
		
		catch(ArrayIndexOutOfBoundsException e) {
			System.out.println("出现数组越界了");
		} 
		catch(NullPointerException e) {
			System.out.println("出现空指针了");
		}
		catch(Exception e) {
			System.out.println("出现异常了");
		}
		
		
		
		
		/*try {

			
		} catch(ArrayIndexOutOfBoundsException e) {
			System.out.println("出现数组越界了");
		}*/
		

	}

	private static void method() {
		try {
			String s = null;
			System.out.println(s.length());
		} catch(NullPointerException e) {
			System.out.println("出现空指针了");
		}
		
		try {

			int[] arr = new int[5];
			System.out.println(arr[8]);
		} catch(ArrayIndexOutOfBoundsException e) {
			System.out.println("出现数组越界了");
		}
	}

}
package com.itheima_01;
/*
 * Throwable的常用方法：
		String getMessage()  
		String toString()  
		void printStackTrace()  
 	
 * 	
 */
public class ExceptionDemo4 {
	public static void main(String[] args) {
	
		
		try {
			System.out.println(2 / 0);
		} catch (ArithmeticException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	private static void method() {
		try {
			System.out.println(2 / 0);
		} catch(ArithmeticException e) {
			//String getMessage() : 原因
			//System.out.println(e.getMessage());
			
			//String toString()  类型和原因
			//System.out.println(e.toString());

			//void printStackTrace():类型原因和位置
			e.printStackTrace();
		}
		
		//System.out.println("hello");
	}



}
package com.itheima_01;

import java.io.FileWriter;
import java.io.IOException;

/*
 *  finally:组合try...catch使用，用于释放资源等收尾工作，无论try...catch语句如何执行，finally的代码一定会执行
 *  
 *  try {
 *  	有可能出现问题的代码;
 *  
 *  } catch(异常对象) {
 *  	处理异常;
 *  } finally {
 *  	释放资源;
 *  	清理垃圾;
 *  }
 *  
 */
public class ExceptionDemo5 {
	public static void main(String[] args) {
		//method();
		
		FileWriter fw = null;
		try {
			System.out.println(2 / 0);
			fw = new FileWriter("a.txt");
			fw.write("hello");
			fw.write("world");
			//System.out.println(2 / 0);
			fw.write("java");
			
			//fw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} finally {
			//释放资源
			try {
				if(fw != null) {
					fw.close();
				}
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		
	}

	private static void method() {
		try {
			System.out.println(2 / 1);
			
		} catch(ArithmeticException e) {
			System.out.println("除数不能为0");
		} finally {
			
			System.out.println("清理垃圾");
		}
	}

	

}
package com.itheima_01;

import java.io.FileWriter;
import java.io.IOException;

/*
 * 异常的分类：
		运行时期异常:RuntimeException的子类就是运行时期异常，在编译时期可以自由选择处理或者不处理
		编译时期异常:是Exception的子类，非RuntimeExcpetion的子类，在编译时期必须处理
 
 */
public class ExceptionDemo6 {
	public static void main(String[] args) {
		//System.out.println(2 / 0);
		
		//String s = null;
		//System.out.println(s.length());
		
		try {
			FileWriter fw = new FileWriter("a.txt");
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
		
	}
}
package com.itheima_01;
/*
 * 需求：写一个方法，接受考试成绩，如果考试成绩的范围在0-100之间则属于正常，否则属于异常
 * 
 * throws:处理异常的一种方式，把异常抛出，由调用者来处理
 * throw:制造异常的方式,并且结束方法
 * 
 * 注意：如果抛出（throw）的是编译时期异常，必须在方法声明处抛出（throws）
 * 
 * 如何自定义一个异常类呢？
 * 		非常简单，写一个类去继承Exception或者RuntimeException，然后实现多个构造即可
 * 
 *  */
public class ExceptionDemo7 {
	public static void main(String[] args) {
		/*boolean flag = checkScore(-10);
		System.out.println(flag);*/
		
		
		
		try {
			checkScore(110);
		} catch (Exception e) {
			//System.out.println(e.getMessage());
			e.printStackTrace();
		}
		
		
		//checkScore(110);
	}
	
/*	public static boolean checkScore(int score) {
		//判断考试成绩是否符合范围，如果不符合则返回false
		if(score < 0 || score > 100) {
			return false;
		}
		
		//符合
		return true;
		
	}*/
	
	public static void checkScore(int score) throws Exception {
		if(score < 0 || score > 100) {
			//throw new RuntimeException("考试成绩不符合要求");
			//throw new Exception("考试成绩不符合要求");
			throw new MyException("考试成绩不符合要求");
		} 
		
		System.out.println("考试成绩符合要求");
	}
	
	
}
package com.itheima_01;

public class MyException extends /*RuntimeException*/ Exception{

	public MyException() {
		super();
		// TODO Auto-generated constructor stub
	}

	public MyException(String message) {
		super(message);
		// TODO Auto-generated constructor stub
	}
	/*public MyException() {
		super();
	}
	
	public MyException(String s) {
		super(s);
	}*/
	
	
}
package com.itheima_01;
/*
 * 需求：求5的阶乘
 * 5! = 5 * 4 * 3 * 2 * 1;  //120
 * 5! = 5 * 4!;					//120
 * 		4! = 4 * 3!;			//24
 * 			3! = 3 * 2!;		//6
 * 				2! = 2 * 1!;	//2
 * 					1! = 1;     //1
	n! = n * (n - 1)!
	
	递归：把大问题拆成很多小问题，然后再把小问题拆成更多的小问题，
			当我们把更多小问题解决了，小问题也解决了
				随着小问题的解决，大问题也随之解决了
	在方法本身不断的调用方法自己
	
	递归注意事项：
			递归一定要有出口，内存溢出
			递归次数不宜过多，内存溢出
			
	public void show(int n) {//5
		//出口
		if(n == 0) {
			return;
		}
		
		show(n - 1);
	}
	
	从前有座山，山里有个庙，庙里有个老和尚，老和尚在给小和尚讲故事
 * 		从前有座山，山里有个庙，庙里有个老和尚，老和尚在给小和尚讲故事
 * 			从前有座山，山里有个庙，庙里有个老和尚，老和尚在给小和尚讲故事
 * 				从前有座山，山里有个庙，庙里有个老和尚，老和尚在给小和尚讲故事
 * 					从前有座山，山里有个庙，庙里有个老和尚，老和尚在给小和尚讲故事
 * 					...
 * 
 * 	学习编程...找工作...赚钱...娶媳妇...生娃娃
		学习编程...找工作...赚钱...娶媳妇...生娃娃
			学习编程...找工作...赚钱...娶媳妇...生娃娃
				学习编程...找工作...赚钱...娶媳妇...生娃娃
					学习编程...找工作...赚钱...娶媳妇...生娃娃
					...
 * 
 */
public class RecurrenceDemo {
	public static void main(String[] args) {
		int result = jC(5);
		System.out.println(result);//120
	}
	
	
	//求一个数的阶乘
	public static int jC(int n) {
		//必须要有出口
		if(n == 1) {
			return 1;
		}
		else {
			return n * jC(n - 1);
		}
	}
	
}
package com.itheima_01;
/*
 * 古典问题：有一对兔子，从出生后第3个月起每个月都生一对兔子，
 * 		     小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，
 *  	     问第二十个月的兔子对数为多少？
 *  
 *  
 *  1
 *  1
 *  2
 *  3
 *  5
 *  8
 *  13
 *  
 *  规律：除了第一个月和第二月以外，其余每个月都是前两个月之和
 *  斐波那契列数
 *  
 */
public class RecurrenceDemo2 {
	public static void main(String[] args) {
		int result = method(20);//6765
		System.out.println(result);
	}
	
	public static int method(int n) {
		//如果是第一个月，只有一对兔子
		if(n == 1) {
			return 1;
		}
		//如果是第二个月，也只有一对兔子
		else if(n == 2) {
			return 1;
		}
		else {
			//如果不是第一个月和第二个月，则兔子的数量是前两个月之和
			return method(n - 1) + method(n - 2);
		}
	}
	
	
	
	
}

public class SelectTitle {
	
	public static void main(String[] args) {
		
		try {
			select('E');
		} catch (NiYouBingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			System.out.println("挖掉虫子给老王");
		}
		
	}
	
	
	public static void select(char item) throws NiYouBingException {//A
		if(item == 'A'){
			System.out.println("你回答正确");
		}else if(item =='B' || item == 'C'|| item =='D'){
			System.out.println("恭喜你答错了");
		}else{
				
				throw new NiYouBingException("我有药");
		}
		
		
		
	}
	
	public static void get(){
		get();
	}

}

class NiYouBingException  extends Exception{
	
	public NiYouBingException(String name){
		super(name);
		
	}
	
}
import java.util.HashMap;
import java.util.Map.Entry;
import java.util.Set;

public class Test1 {
	//5.String s = "sdfkhew24353dsvifsougfouu";计算每个字符出现的次数,通过两种方式遍历Map
	public static void main(String[] args) {
		String s = "sdfkhew24353dsvifsougfouu";
		HashMap<Character,Integer> map =new HashMap<Character,Integer>();
		
		for (int i = 0; i < s.length(); i++) {
			char charAt = s.charAt(i);
			if(!map.containsKey(charAt)){
				map.put(charAt, 1);			
			}else{
				Integer integer = map.get(charAt)+1;
				map.put(charAt, integer);
			}
		}
		
		Set<Entry<Character, Integer>> entrySet = map.entrySet();
		for (Entry<Character, Integer> entry : entrySet) {
			Character key = entry.getKey();
			Integer value = entry.getValue();
			System.out.println(key+"出现"+value);
			
			
		}
		
		
		
	}
}
import java.text.SimpleDateFormat;

public class Test2 {

	public static void main(String[] args) {
		String s = "2017年02月02日";
		SimpleDateFormat format = new SimpleDateFormat("yyyy年MM月dd日");

		
			try {
				int[] arr= new int[2];
				
				 int i = arr[2];
			} catch (Exception e) {
				//在这里弹出一个提示框
				e.printStackTrace();
			}finally{
				
			}
			
			try{
				
			}finally{
				
			}
		
		 
		 

		// format.parse(s);

	}

}
import java.io.FileWriter;
import java.io.IOException;

public class Test3 {

	public static void main(String[] args) {
		//demo();
		
		//get();
		demo();

	}


	private static void demo() {
		FileWriter writer = null ;
		try {
			writer = new FileWriter("d://a.txt");// 如果不存在,帮我创建,如果存在,先清空,才去写;
			writer.write("才艺林");
			writer.write("周婕纶");
			writer.write("拜拜和");
			writer.write("小狼狗");
		} catch (Exception e) {
			System.out.println("出异常");
			e.printStackTrace();
		} finally {//只要系统不退出,我们finally就一定会走,只放释放资源,和收尾;
			try {
				if(writer !=null){
					writer.close();
				}
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}

		}
	}
	
	
	public static int get(){
		try{
			return 520;
		}finally{
			
			System.out.println("我是天王老子, 谁都阻挡不了我运行,除了我妈虚拟机和try");
		}
		
	}

}
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

public class Test4 {
	
	public static void main(String[] args) throws IOException {
		//FileWriter fileWriter = new FileWriter("d://sfd//a.txt");
		
		//Exception1 exception1 = new Exception1();
		
		Exception1 exception2 = new Exception1("niwandanle");
		
		System.out.println(exception2.getDetailMessage());
	}

}

class Exception1 extends Throwable1{
	
	public Exception1 (String detailMessage){
		super(detailMessage);
		//setDetailMessage(detailMessage);
	}

	public Exception1() {
		super();
		// TODO Auto-generated constructor stub
	}
	
	
}

class Throwable1 {
	private String detailMessage;

	public String getDetailMessage() {
		return detailMessage;
	}


	public void setDetailMessage(String detailMessage) {
		this.detailMessage = detailMessage;
	}


	public Throwable1(String detailMessage) {
		super();
		this.detailMessage = detailMessage;
	}


	public Throwable1() {
		super();
		// TODO Auto-generated constructor stub
	}


}

public class Test5 {

	public static void main(String[] args) {
		// 1.一对兔子
		// 2.一个月后;
		// 3.生一 对兔子
		// 4 生一对 大兔子

		int littleRubbits = 1;// 第一个月的情况
		int bigRubbits = 0;
		int oldRubbits = 0;

		for (int i = 0; i <19; i++) {
			oldRubbits += bigRubbits;
			bigRubbits = littleRubbits;
			littleRubbits = oldRubbits;

		}
		
		System.out.println(littleRubbits+bigRubbits+oldRubbits);
		
		
		int[] arr =new int[20];
		arr[0] = 1;
		arr[1] =1;
		for (int i = 2; i < arr.length; i++) {
			arr[i] =  arr[i-1] +arr[i-2];
		}
		
		System.out.println(arr[arr.length-1]);
		
	}

}
1.异常体系
		Throwable(可抛的)
			Error
				一般系统级别错误,我们程序员没办法处理(不可以用代码处理的)
			Exception
				我们能用代码处理的问题;

1.jvm处理异常
	1.首先将异常的信息打印控制台
	2.将程序终止;

	我们的第一种手动处理的方式
	int a
	try{
		可能出现问题的代码--->//一旦出现异常,就会创建对应的异常对象,然后抛给catch模块里面
		如果出现异常就不要执行的执行的代码;
	}catch(异常类型  变量名){
		处理方式;
	}



	自己手动处理的好处是:虚拟机不会结束;

2.第二种方式
	throws关键字;声明在方法小括号后面;将异常抛给调用者;谁调用谁处理


3.二种异常的区别
 编译时异常:
	非运行时异常都是编译时异常;
	必须自己手动处理,要不try要不抛;
 运行时异常:
    Runtime的子体系都是运行时异常;
	可以自己手动处理,也可以不处理;
4.方法调用自己本身的这种现象就是递归;
 递归需要注意的是:
	1.一定要有出口
	2.调用次数不要过多
 递归的优点: 
    效率非常高;









 


package com.itheima_01;

import java.io.File;

/*
 * File:文件和目录路径名的抽象表示形式，File 类的实例是不可变的
 * 
 * 构造方法：
 * 		File(File parent, String child) 
 * 		File(String pathname) 
 * 		File(String parent, String child) 
 * 
 * File的常用功能：
 * 		创建功能
 * 			boolean createNewFile()  
 * 			boolean mkdir()  
 * 			boolean mkdirs()  
 * 		删除功能
 * 			boolean delete() 

 * 		获取功能
 * 			File getAbsoluteFile()  
 * 			String getAbsolutePath() 
 * 			String getName()  
 * 			String getParent()  
 * 			File getParentFile() 
 * 			String getPath()  
  			long lastModified() 
  			long length()  
 * 		判断功能
 * 			 boolean exists()  
 * 			 boolean isAbsolute()  
 * 			 boolean isDirectory() 
 			 boolean isFile()  
 			 boolean isHidden()  
 		修改文件名：
 			boolean renameTo(File dest)  
 			 
 * 
 * 
 */
public class FileDemo {
	public static void main(String[] args) {
		//File(String pathname) ：将指定的路径名转换成一个File对象
		//File f = new File("D:\\a\\b.txt");
		
		//File(String parent, String child) : 根据指定的父路径和文件路径创建File对象
		//File f2 = new File("D:\\a","b.txt");
		
		//File(File parent, String child) :根据指定的父路径对象和文件路径创建File对象
		//File parent = new File("D:\\a");
		//File f3 = new File(parent,"b.txt");
		
		File f4 = new File(new File("D:\\a"),"b.txt");
		
	}
}
package com.itheima_01;

import java.io.File;
import java.io.IOException;

/*
 * 	创建功能
 * 		boolean createNewFile()  
 * 		boolean mkdir()  
 * 		boolean mkdirs()  
 * 	删除功能
 * 		boolean delete() 
 * 
 *  绝对路径：固定不可改变的路径，以盘符开头
 *  相对路径：相对某个参照物，不能以盘符开头
 *  		在eclipse中相对路径相对应当前项目的根目录
 *  
 *  
 *  注意：删除一个文件夹，这个文件夹下面不能有其他的文件和文件夹

 */
public class FileDemo2 {
	public static void main(String[] args) throws IOException {
		 //File f = new File("d:\\a\\b.txt");//绝对路径
		 //File f2 = new File("a.txt");//相对路径
		
		//boolean createNewFile() : 当指定文件不存在时创建文件并返回true，否则返回false
		//System.out.println(f2.createNewFile());
		
		//boolean mkdir()   : 当指定文件夹不存在时创建文件夹并返回true，否则返回false
		
		//File f3 = new File("b");
		//System.out.println(f3.mkdir());
		
		//boolean mkdirs() : 创建指定文件夹，当文件夹所在的目录不存在，则顺道一块创建了
		//File f4 = new File("c\\d\\e");
		//System.out.println(f4.mkdir());
		//System.out.println(f4.mkdirs());
		
		//File f5 = new File("c.txt");
		//System.out.println(f5.mkdir());
		
		//boolean delete() :当指定的文件或文件夹存在时删除文件或者文件夹 并返回true，否则返回false
		//System.out.println(f2.delete());
		//System.out.println(f3.delete());

		//File f6 = new File("c");
		//System.out.println(f6.delete());
		
		
		
	}
}
package com.itheima_01;

import java.io.File;
import java.io.IOException;

/*
 *	判断功能
 * 		boolean exists()  
 * 		boolean isAbsolute()  
 * 		boolean isDirectory() 
 		boolean isFile()  
 		boolean isHidden() 
 */
public class FileDemo3 {
	public static void main(String[] args) throws IOException {
		//method();
		//method2();
		//method3();
		
		method4();
		
		
		
	}

	private static void method4() {
		File f = new File("d:\\a\\b.txt");
		//boolean isHidden() :判断File对象指向的路径是否有隐藏属性，如果隐藏了则返回true，否则返回false
		
		System.out.println(f.isHidden());
	}

	private static void method3() {
		File f = new File("a.txt");
		File f2 = new File("b");
		//boolean isDirectory() ：判断File对象指向的路径是否是文件夹，如果是则返回true，否则返回false
		//boolean isFile()  : 判断File对象指向的路径是否是文件，如果是则返回true，否则返回false
		
		//System.out.println(f.isDirectory());
		//System.out.println(f2.isDirectory());
		
		System.out.println(f.isFile());
		System.out.println(f2.isFile());
	}

	private static void method2() {
		//File f = new File("a.txt");
		File f2 = new File("d:\\a\b.txt");
		
		//boolean isAbsolute() :判断File对象指向的路径是否是绝对路径，如果是绝对路径则返回true，否则返回false
		System.out.println(f2.isAbsolute());
	}

	private static void method() {
		File f = new File("a.txt");
		//f.createNewFile();
		
		//boolean exists() : 判断文件或者文件夹是否存在，如果存在则返回true，否则返回false
		System.out.println(f.exists());
	}
}
package com.itheima_01;

import java.io.File;
import java.io.IOException;

/*
 *	获取功能
 		File getAbsoluteFile()  
 * 		String getAbsolutePath() 
 * 		String getParent()  
 * 		File getParentFile() 
 * 		String getName() 
 * 		String getPath()  
  		long lastModified() 
  		long length() 
  	修改功能：
 		boolean renameTo(File dest)
 */
public class FileDemo4 {
	public static void main(String[] args) throws IOException  {
		//method();
		//method2();
		//method3();
		
		File f = new File("d.txt");
		File f2 = new File("e.txt");
		
		//boolean renameTo(File dest) : 将当前File对象所指向的路径 修改为 指定File所指向的路径
		//注意：修改的文件路径不能存在，如果存在则修改失败
		System.out.println(f.renameTo(f2));
	}

	private static void method3() {
		File f = new File("a.txt");
		File f2 = new File("d:\\a\\b.txt");
		File f3 = new File("b");
		
		//String getName() : 获取文件和文件夹的名称
		//System.out.println(f.getName());
		//System.out.println(f2.getName());
		//System.out.println(f3.getName());
		
		//String getPath() : 返回创建File对象时给的路径
		//System.out.println(f.getPath());
		//System.out.println(f2.getPath());
		//System.out.println(f3.getPath());
		
		//long lastModified() : 以毫秒值的形式返回最后修改时间
		//System.out.println(f.lastModified());
		//2514023311294
		//Date d = new Date(2514023311294L);
		//System.out.println(d.toLocaleString());
		
		//long length() : 返回文件的字节数
		System.out.println(f.length());
		System.out.println(f3.length());
	}

	private static void method2() throws IOException {
		//File f = new File("a.txt");
		
		//File f2 = new File("b","c.txt");
		//System.out.println(f2.createNewFile());
		
		File parent = new File("b");
		File f3 = new File(parent,"c.txt");
		if(!parent.exists()) {
			parent.mkdirs();
		}
		System.out.println(f3.createNewFile());
		
		//String getParent() 
		System.out.println(f3.getParent());
		//File getParentFile() 
		System.out.println(f3.getParentFile());
	}

	private static void method() {
		File f = new File("d:\\a\\b.txt");
		File f2 = new File("a.txt");
		
		//File getAbsoluteFile()  ：以File对象的形式返回当前File对象所有指向的绝对路径
		System.out.println(f2.getAbsoluteFile());
		//String getAbsolutePath() : 返回File对象所指向的绝对路径
		System.out.println(f2.getAbsolutePath());
	}

}
package com.itheima_01;

import java.io.File;

/*
 * 	String[] list() 
 	File[] listFiles() 
 	static File[] listRoots() 
 */
public class FileDemo5 {
	public static void main(String[] args)  {
		//method();
		//method2();
		
		//static File[] listRoots() :  返回的是所有盘符
		File[] files = File.listRoots();
		for (File file : files) {
			System.out.println(file);
		}
		
		
	}

	private static void method2() {
		File f = new File("b");
		File f2 = new File("D:\\workspace\\myFile");
		File f3 = new File("c.txt");
		
		//File[] listFiles()
		File[] files = f3.listFiles();
		for (File file : files) {
			System.out.println(file.getName());
		}
	}

	private static void method() {
		File f = new File("b");
		File f2 = new File("D:\\workspace\\myFile");
		File f3 = new File("c.txt");
		
		//String[] list() : 返回当前路径下所有的文件和文件夹名称
		//注意：只有指向文件夹的File对象才可以调用该方法
		String[] files = f3.list();
		for (int i = 0; i < files.length; i++) {
			System.out.println(files[i]);
		}
	}


}
package com.itheima_01;
/*
 * IO流分类：
 * 			流向
 * 					输入流	读取数据	FileReader	Reader
 * 					输出流	写出数据	FileWriter	Writer
 * 			数据类型
 * 					字节流	
 * 							字节输入流		读取数据	InputStream
 * 							字节输出流		写出数据	OutputStream
 * 					字符流
 * 							字符输入流		读取数据	Reader
 * 							字符输出流		写出数据	Writer
 */
public class IODemo {

}
package com.itheima_01;
/*
 * IO流分类：
 * 			流向
 * 					输入流	读取数据	FileReader	Reader
 * 					输出流	写出数据	FileWriter	Writer
 * 			数据类型
 * 					字节流	
 * 							字节输入流		读取数据	InputStream
 * 							字节输出流		写出数据	OutputStream
 * 					字符流
 * 							字符输入流		读取数据	Reader
 * 							字符输出流		写出数据	Writer
 */
public class IODemo {

}
package com.itheima_02;

import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

/*
 * 使用字符流复制文本文件
 * 
 * 数据源		IODemo.java
 * 目的地		d:\\IODemo.java

 * 	
 */
public class FileCopyDemo {
	public static void main(String[] args) throws IOException  {
		//创建字符输入流对象
		FileReader fr = new FileReader("IODemo.java");
		//创建字符输出流对象
		FileWriter fw = new FileWriter("d:\\IODemo.java");
		
		//一次读写一个字符
		
		/*int ch;
		while((ch = fr.read()) != -1) {
			fw.write(ch);
			fw.flush();
		}*/
		
		//一次读写一个字符数组
		int len;//用于存储读到的字符个数
		char[] chs = new char[1024];
		while((len = fr.read(chs)) != -1) {
			fw.write(chs,0,len);
			fw.flush();
		}
		
		//释放资源
		fw.close();
		fr.close();
	}
}
package com.itheima_03;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

/*
 * 使用字节流复制文本文件
 * 
 * 数据源		IODemo.java
 * 目的地		d:\\a\\IODemo.java
 * 

 */
public class FileCopyDemo {
	public static void main(String[] args) throws IOException  {
		//创建字节输入流对象
		FileInputStream fis = new FileInputStream("IODemo.java");
		//创建字节输出流对象
		FileOutputStream fos = new FileOutputStream("d:\\a\\IODemo.java");
		
		//一次读写一个字节
		/*int by;
		while((by = fis.read()) != -1) {
			fos.write(by);
		}*/
		//一次读写一个字节数组
		int len;//存储读到的字节个数
		byte[] bys = new byte[1024];
		while((len = fis.read(bys)) != -1) {
			fos.write(bys,0,len);
		}
		
		
		//释放资源
		fos.close();
		fis.close();
	}
}
package com.itheima_04;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

/*
 * 分别使用字符流和字节流复制图片
 * 
 * 二进制文件只能使用字节流进行复制（使用windows自带记事本打开读不懂的）
 * 文本文件的复制即可使用字符流，也可以使用字节流
 * 
 */
public class CopyImage {
	public static void main(String[] args) throws IOException  {
		//method();
		
		//创建字节输入流对象
		FileInputStream fis = new FileInputStream("传智学院.jpg");
		//创建字节输出流对象
		FileOutputStream fos = new FileOutputStream("d:\\传智学院.jpg");
		
		//一次读写一个字节数组
		int len;//用于存储读到的字节个数
		byte[] bys = new byte[1024];
		while((len = fis.read(bys)) != -1) {
			fos.write(bys,0,len);
		}
		
		//释放资源
		fos.close();
		fis.close();
	}

	private static void method() throws FileNotFoundException, IOException {
		//创建字符输入流对象
		FileReader fr = new FileReader("传智学院.jpg");
		//创建字符输出流对象
		FileWriter fw = new FileWriter("d:\\传智学院.jpg");
		
		//一次读写一个字符数组
		int len;//用于存储读到的字符个数
		char[] chs = new char[1024];
		while((len = fr.read(chs)) != -1) {
			fw.write(chs,0,len);
			fw.flush();
		}
		
		//释放资源
		fw.close();
		fr.close();
	}


}
package com.itheima_01;
/*
 * 需求：求5的阶乘
 * 5! = 5 * 4 * 3 * 2 * 1;  //120
 * 5! = 5 * 4!;					//120
 * 		4! = 4 * 3!;			//24
 * 			3! = 3 * 2!;		//6
 * 				2! = 2 * 1!;	//2
 * 					1! = 1;     //1
	n! = n * (n - 1)!
	
	递归：把大问题拆成很多小问题，然后再把小问题拆成更多的小问题，
			当我们把更多小问题解决了，小问题也解决了
				随着小问题的解决，大问题也随之解决了
	在方法本身不断的调用方法自己
	
	递归注意事项：
			递归一定要有出口，内存溢出
			递归次数不宜过多，内存溢出
			
	public void show(int n) {//5
		//出口
		if(n == 0) {
			return;
		}
		
		show(n - 1);
	}
	
	从前有座山，山里有个庙，庙里有个老和尚，老和尚在给小和尚讲故事
 * 		从前有座山，山里有个庙，庙里有个老和尚，老和尚在给小和尚讲故事
 * 			从前有座山，山里有个庙，庙里有个老和尚，老和尚在给小和尚讲故事
 * 				从前有座山，山里有个庙，庙里有个老和尚，老和尚在给小和尚讲故事
 * 					从前有座山，山里有个庙，庙里有个老和尚，老和尚在给小和尚讲故事
 * 					...
 * 
 * 	学习编程...找工作...赚钱...娶媳妇...生娃娃
		学习编程...找工作...赚钱...娶媳妇...生娃娃
			学习编程...找工作...赚钱...娶媳妇...生娃娃
				学习编程...找工作...赚钱...娶媳妇...生娃娃
					学习编程...找工作...赚钱...娶媳妇...生娃娃
					...
 * 
 */
public class RecurrenceDemo {
	public static void main(String[] args) {
		int result = jC(5);
		System.out.println(result);//120
	}
	
	
	//求一个数的阶乘
	public static int jC(int n) {
		//必须要有出口
		if(n == 1) {
			return 1;
		}
		else {
			return n * jC(n - 1);
		}
	}
	
}
package com.itheima_01;
/*
 * 古典问题：有一对兔子，从出生后第3个月起每个月都生一对兔子，
 * 		     小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，
 *  	     问第二十个月的兔子对数为多少？
 *  
 *  
 *  1
 *  1
 *  2
 *  3
 *  5
 *  8
 *  13
 *  
 *  规律：除了第一个月和第二月以外，其余每个月都是前两个月之和
 *  斐波那契列数
 *  
 */
public class RecurrenceDemo2 {
	public static void main(String[] args) {
		int result = method(20);//6765
		System.out.println(result);
	}
	
	public static int method(int n) {
		//如果是第一个月，只有一对兔子
		if(n == 1) {
			return 1;
		}
		//如果是第二个月，也只有一对兔子
		else if(n == 2) {
			return 1;
		}
		else {
			//如果不是第一个月和第二个月，则兔子的数量是前两个月之和
			return method(n - 1) + method(n - 2);
		}
	}
	
	
	
	
}
package com.itheima_02;

import java.io.File;

/*
 * 需求：输出指定目录下所有的java文件名（包含子目录）
 */
public class RecurrenceTest {
	public static void main(String[] args) {
		File f = new File("src");
		//File f = new File("src\\com\\itheima_01\\RecurrenceDemo.java");
		method(f);
	}
	
	public static void method(File file) {
		if(file.isDirectory()) {
			File[] files = file.listFiles();
			for (File f : files) {
				//判断是否是文件对象
				if(f.isFile()) {
					if(f.getName().endsWith(".java")) {
						System.out.println(f.getName());
					}
				}
				else if(f.isDirectory()){
					//是一个目录对象
					method(f);
				}
			}
		}
	}
	
	
	//输出指定目录下的所有java文件名（不包含子目录）
	public static void method2(File file) {
		if(file.isDirectory()) {
			File[] files = file.listFiles();
			for (File f : files) {
				//判断是否是文件对象
				if(f.isFile()) {
					if(f.getName().endsWith(".java")) {
						System.out.println(f.getName());
					}
				}
			}
		}
	}
	
}
package com.itheima_02;

import java.io.File;

/*
 * 需求：删除指定的目录（包含子目录）
 * 
 * 注意：如果要删除一个目录，则需要先删除这个目录下的所有子文件和子目录
 * 
 */
public class RecurrenceTest2 {
	public static void main(String[] args) {
		File f = new File("d:\\a");
		method(f);
	}
	
	//删除指定目录下所有文件和目录
	public static void method(File file) {
		if(file.isDirectory()) {
			//干掉自己所有的子文件和子目录
			//获取所有的子文件和子目录
			File[] files = file.listFiles();
			for (File f : files) {
				if(f.isFile()) {
					//直接干掉他
					System.out.println(f.getName());
					f.delete();
				}
				else if(f.isDirectory()) {
					//继续查看是否还有文件和子目录
					method(f);
				}
			}
			
			//干掉自己
			System.out.println(file.getName());
			file.delete();
		}
	}
	
	

	
	
}
package com.itcast.cn;

import java.io.File;

public class Test1 {
	
	public static void main(String[] args) {
		/*//通过第一个构造关联D盘下的a.txt;
		File file = new File("d://a/b.txt");//创建File只是作为关联文件作用,并不会创建文件;
		
		
		File file2 = new File("D://" , "a/a.txt" );
		File file3 = new File(new File("d://") , "a/a.txt" );
		
		boolean exists = file.exists();
		
		System.out.println(exists);*/
		
		
		
	}

}
package com.itcast.cn;

import java.io.File;
import java.io.IOException;

public class Test2 {

	// 1.有File
	public static void main(String[] args) throws IOException {
		// demo1();
		//创建File对象关联需要删除的文件
//		File file = new File("a.txt");
//		file.delete();
//		
//		File file1 = new File("a");
//		file1.delete();
		
		File file = new File("c//d//e");//相对路径
		//File file2 = new File("c://d//e");//绝对路径
		boolean mkdirs = file.mkdirs();
		
		//首先关联 c
		File file2 = new File("c");
		
		boolean delete = file2.delete();
		

	}

	private static void demo1() throws IOException {
		File file = new File("a.txt");
		// 需要调用创建文件的方法
		boolean createNewFile = file.createNewFile();
		System.out.println(createNewFile);
		// 还需要创键一个File对象关联a文件夹
		File file2 = new File("a");
		boolean mkdirs = file2.mkdirs();
		System.out.println(mkdirs);
	}

}
package com.itcast.cn;

import java.io.File;
import java.io.IOException;

public class Test3 {
	
	public static void main(String[] args) throws IOException {
		File file = new File("s/fd/dfg/gf/hghj/hg/j/a.txt");
		
		
		File parentFile = file.getParentFile();
		System.out.println(parentFile);
		
	}

}
package com.itcast.cn;

import java.io.File;

public class Test4 {
	
	public static void main(String[] args) {
		//首先需要创建File对象关联想要获取的文件夹
		File file = new File("D://");
		
		String[] list = file.list();
		for (String string : list) {
			System.out.println(string);
		}
		
		File[] listFiles = file.listFiles();
		System.out.println("---------------------------");
		
		for (File file2 : listFiles) {
			
			System.out.println(file2.getAbsolutePath());
			
		}
		
		
		
		
	}

}
package com.itcast.cn;

import java.io.File;

public class Test5 {
	
	public static void main(String[] args) {
		
		File file = new File("D:\\a");
		
		//getAllJavaFile(file);
		
		//deleteDirectory(file);
		

		char c = '你';
		char c1 = '好';
		
		System.out.println(c+0);
		System.out.println(c1+0);
		
		
	}
	/**
	 * 只是删除文件夹;
	 * @param src
	 */
	public static void deleteDirectory(File src){
		File[] files = src.listFiles();//获取一级目录小所有的子文件和文件夹
		Demo1(src, files);
		
		
		
	}
	private static void Demo1(File src, File[] files) {
		if(files!=null){//防止用户传进来一个文件路径;
			
			for (File file : files) {
				
				if(file.isFile()){
					file.delete();
				}else{
					deleteDirectory(file);
					
					
				}
				
			}
			src.delete();
			
			
			
		}
	}
	
	public static void getAllJavaFile(File src){
		File[] files = src.listFiles();
		
		if(files!=null){//证明传进来的是一个文件夹
			
			for (File file : files) {
				
				if(file.isFile()){
					if(file.getName().endsWith(".txt")){
						System.out.println(file.getName());
					}
				}else{
					getAllJavaFile(file);
				}
				
			}
			
		}
		
		
	}

}
package com.itcast.cn;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class Test6 {

	@SuppressWarnings("resource")
	public static void main(String[] args) throws IOException {
		//demo1();
		
		FileReader fileReader = new FileReader("c");//io流只能操作文件,不能操作文件夹;
		
		int read = fileReader.read();
		System.out.println(read);

	}

	private static void demo1() {
		// 使用字符流拷贝Test1
		BufferedReader reader = null;
		BufferedWriter writer = null;

		// 首先需要一个输入流关联 源文件
		try {
			reader = new BufferedReader(new FileReader(
					new File("D:\\worksapce\\javaw" + "orkspace\\javaee8\\Day09\\src\\com\\itcast\\cn\\Test1.java")));
			// 创建输入流关联目标文件
			writer = new BufferedWriter(new FileWriter(new File("copy")));

			// 用输入流读
			String line = null;
			while ((line = reader.readLine()) != null) {
				// 用输入流写
				writer.write(line);
				// 换行
				writer.newLine();
			}

		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} finally {

			try {
				if (reader != null) {
					reader.close();
				}
				if (writer != null) {
					writer.close();
				}
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

		}
	}

}
package com.itcast.cn;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class Test7 {

	public static void main(String[] args) {
		// demo1();
		//demo2();
	}

	private static void demo2() {
		FileInputStream inputStream = null;
		FileOutputStream outputStream = null;
		try {
			// 字节输入流
			inputStream = new FileInputStream(new File("aa.txt"));
			// 字节输出流
			outputStream = new FileOutputStream(new File("poem1.txt"));
			// 定义一个字节数组,
			byte[] arr = new byte[1024 * 8];

			// 定义变量来记录读取的长度, 这个长度专门用来怕最后一次读不满情况发生;
			int len;
			while ((len = inputStream.read(arr)) != -1) {
				outputStream.write(arr, 0, len);
			}

		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} finally {

			try {
				if (inputStream != null) {
					inputStream.close();
				}
				if (outputStream != null) {
					outputStream.close();
				}
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

		}
	}

	private static void demo1() {
		// 用字符流拷贝
		BufferedReader reader = null;
		BufferedWriter writer = null;
		try {
			// 输入流
			reader = new BufferedReader(new FileReader(new File("aa.txt")));
			// 输出流
			writer = new BufferedWriter(new FileWriter(new File("poem.txt")));

			// 边读边写,需要定义一个临时变量不断的记录读出的内容
			String line = null;
			while ((line = reader.readLine()) != null) {
				writer.write(line);
				writer.newLine();
			}

		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} finally {

			try {
				if (reader != null) {
					reader.close();
				}
				if (writer != null) {
					writer.close();
				}
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

		}
	}

}
package com.itcast.cn;

import java.io.File;
import java.io.IOException;

public class Test8 {

	public static void main(String[] args) throws IOException {
		// File file = new File("c/aa.txt");// 创建File对象关联aa.txt
		// File f1 = new File("c", "aa.txt");// 给定父路径的字符串表现形式,给定子路径的字符串表现形式
		//
		// File f2 = new File(new File("c"), "aa.txt");//
		// 给定父路径的字符串表现形式,给定子路径的字符串表现形式
		//
		// // 创建和删除
		// // 1.创建File对象,关联当前项目d文件夹
		// File f3 = new File("sdfdsf/fdsgfdg/a");
		// f3.mkdirs();
		// f3.createNewFile();
		// f3.delete();
		//
		// // get方法
		//
		// // getAbsolutePath //获取绝对路径
		// // getName()//获取关联的文件或者文件的名字(也就是最后一级的名字)
		// // length()//
		// String absolutePath = f3.getAbsolutePath();
		// System.out.println(absolutePath);
		// String name = f3.getName();
		// System.out.println(name);
		//
		// long length = f3.length();
		// System.out.println(length);

		File file = new File("aa.txt");

		System.out.println(file.length());

		// 判断方法
		System.out.println(file.exists());
		System.out.println(file.isFile());
		System.out.println(file.isDirectory());

		// 高级获取(只有文件夹能够使用高级获取)
		
		File file2 = new File("d://aa");
		
		long length = getLength(file2);
		System.out.println(length);

	}

	public static long getLength(File src) {
		// 需要定义第三方变量记录和
		long sum = 0;

		File[] files = src.listFiles();

		if (files != null) {

			for (File file : files) {
				if (file.isFile()) {
					sum += file.length();

				} else {
					sum += getLength(file);
				}
			}
		}
		return sum;

	}

}
1. File常用的构造
 File file = new File("字符串路径");
  File file = new File("父路径的字符串表现形式","子路径的字符串表现形式");
   File file = new File(父路径的File对象,"子路径的字符串表现形式")

2. File创建功能
	  createNewFile(); //这个创建文件
	  mkdir()//创建一级目录
	  mkdirs()//创建多级目录; 
	  注意事项:
		不要以扩展名去区分文件或者文件夹;

3. File的删除功能
     delete();//删除功能
	 注意事项:
		1.如果文件夹里面还有内容,不能删除成功;
		2.不走回收站;
4.判断方法
	isFile()//判断是否是文件
	isDirectory()//判断是否是文件夹
	exist()//判断关联的文件是否存在

4.相对路径和绝对路径的区别
   绝对路径是带盘符的;
   相对路径在java中相对于项目跟目录下
5.普通获取方法
getAbsolutePath //获取绝对路径
  getName()//获取关联的文件或者文件的名字(也就是最后一级的名字)
  length()//获取文件的长度,以字节单位,需要注意的是 文件夹是没有长度的;
6.高级获取方法
		list();//获取指定文件下,一级目录下所有的文件和文件夹的名字;将这些名字放置在String数组中
				//调用这必须是文件夹;
		
		listFiles()//获取指定文件下,一级目录下所有的文件和文件夹的File对象;将这些对象放置在File数组中
				//调用这必须是文件夹;
8. io流分类
	字符流
		Reader//抽象父类
			FileReader
		Writer//抽象父类
			FileWriter
	字节流
		InputStream  //字节输入流也是抽象
			FileInputStream
		OutputStream  字节输出流
			FileOutputStream

9.字符字节的读写




package com.itcast.cn;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintStream;

public class Test1 {
	
	public static void main(String[] args) throws Exception {
		
		copyToControlPanal(new File("Test1.java"));
		
	}
	
	public static void copyToControlPanal(File src ) throws Exception{
		//需要定义输入流关流源
		BufferedReader reader = new BufferedReader(new FileReader(src));
		
		OutputStream out = System.out;//字节输出流
		//我想将字节输出流变成字符输出流 , OutputStreamWriter
		OutputStreamWriter writer = new OutputStreamWriter(out);
		//我想将OutputStreamWriter封装成BufferedWriter
		BufferedWriter bufferedWriter = new BufferedWriter(writer);
		
		String line =  null;
		
		while((line = reader.readLine())!=null){
			bufferedWriter.write(line);
			bufferedWriter.newLine();//因为读的时候并没有将换行符读取进来,所有写的时候要换行
			//bufferedWriter.flush();
			
		}
		reader.close();
		bufferedWriter.close();
		
		
		
		
		
	}

}
package com.itcast.cn;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;

public class Test2 {

	public static void main(String[] args) throws Exception {
		// demo();

		// InputStream in = ;
		// 将他转成BufferedReader

		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

		BufferedWriter writer = new BufferedWriter(new FileWriter("aa.txt"));

		while (true) {
			String readLine = reader.readLine();

			if (readLine.equals("quit")) {
				break;

			}

			writer.write(readLine);
			writer.newLine();

		}
		reader.close();
		writer.close();
		

	}

	private static void demo() throws IOException {
		// OutPutStreamWriter | InputStreamReader

		InputStream in = System.in;// 标准输入流,是一个字节流,我们想把它转成字符流

		// 1.由于我们的标准输入流只能一次读一个字节,很不方便操作字符串数据,我们想要的一次一行数据, 只有BuferedRead有这个功能
		// 想办法 将字节输入转成字符输入流就ok;

		InputStreamReader reader = new InputStreamReader(in);

		BufferedReader bufferedReader = new BufferedReader(reader);

		String readLine = bufferedReader.readLine();
		System.out.println(readLine);
	}
}
package com.itcast.cn;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintStream;

public class Test3 {
	
	@SuppressWarnings("resource")
	public static void main(String[] args) throws IOException {
		//System.out.println("你好");
		
		//PrintStream out = ;//字节打印流(目的地是控制台)
		
		System.out.write("你好".getBytes());
	}

}
package com.itcast.cn;

import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.PrintWriter;

public class Test4 {
	
	@SuppressWarnings("resource")
	public static void main(String[] args) throws Exception {
		PrintWriter printWriter = new PrintWriter("bb.txt");
		printWriter.println("窗前明月光");
		printWriter.println("汗滴禾下土");
		printWriter.println("举头望明月");
		printWriter.println("粒粒皆辛苦");
		
		printWriter.close();
	}

}
package com.itcast.cn;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.InputStreamReader;
import java.io.PrintStream;

public class Test5 {
	public static void main(String[] args) throws Exception {
		//源是键盘,所有要用标准输入流,但是标准输入流太不方法,所有包装了一下
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
		//只能打印流去写到cc.txt中
		PrintStream stream = new PrintStream("cc.txt");
		
		//读写的过程
		while(true){
			String readLine = reader.readLine();
			if(readLine.equals("quit")){
				break;
			}
			stream.println(readLine);
			
		}
		reader.close();
		stream.close();
		
		
	}
	

}
package com.itcast.cn;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Test6 {

	public static void main(String[] args) throws Exception {

		login();

	}

	public static void login() throws Exception {
		Scanner scanner = new Scanner(System.in);

		System.out.println("请输入1进行登录");
		System.out.println("请输入2进行注册");

		int nextInt = scanner.nextInt();
		switch (nextInt) {
		case 1:
			
			
			// 读档
			readDang();

			break;
		case 2:

			cunDang();

			break;

		default:
			break;
		}
	}

	private static void cunDang() throws Exception {

		ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("dd.txt"));
		out.writeObject(new Game(new ArrayList<>(), "张飞"));
		out.close();

	}

	private static void readDang() throws Exception {

		ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream("dd.txt"));
		Game readObject = (Game) inputStream.readObject();
		System.out.println(readObject);
		
		
		readObject.play();
		readObject.store();
		
		
	
		//play(readObject);

	}

	

}

class Game implements Serializable {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private List<String> list;

	private String name;

	public Game(List<String> list, String name) {
		super();
		this.list = list;
		this.name = name;
	}

	public List<String> getList() {
		return list;
	}

	public void setList(List<String> list) {
		this.list = list;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public void play() {
		list.add("买了一把倚天贱");
	}

	/**
	 * 存档,需要用到对象流
	 * 
	 * @throws IOException
	 * @throws FileNotFoundException
	 */
	public void store() throws Exception {

		ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream("dd.txt"));
		stream.writeObject(this);
	}

	public Game(List<String> list) {
		super();
		this.list = list;
	}

	@Override
	public String toString() {
		return "Game [list=" + list + ", name=" + name + "]";
	}

}
package com.itcast.cn;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.Properties;

public class Test7 {

	public static void main(String[] args) throws Exception {
		// methed1();

		// write();

		Properties properties = new Properties();

		properties.load(new FileInputStream("tt.txt"));

		if (properties.getProperty("username").equals("zhangsan")
				&& properties.getProperty("password").equals("123456")) {
			
			System.out.println("自动登录成功");
		}else{
			System.out.println("自动登录失败,请重新输入密码");
		}

	}

	private static void write() throws IOException, FileNotFoundException {
		// 创建properties
		Properties properties = new Properties();

		properties.setProperty("username", "zhangsan");
		properties.setProperty("password", "123456");

		// 想通过properties的方法将集合中所有的键值对存到tt.txt,需要用到store方法

		properties.store(new FileOutputStream("tt.txt"), "三国真乱");
	}

	private static void methed1() throws FileNotFoundException, IOException {
		// 用之前所学的姿势来解决问题
		HashMap<String, String> map = new HashMap<>();

		// 创建输入流读取键值对
		BufferedReader reader = new BufferedReader(new FileReader("gg.txt"));
		String line = null;
		while ((line = reader.readLine()) != null) {
			String[] split = line.split("=");
			map.put(split[0], split[1]);
		}

		reader.close();
		System.out.println(map);
	}

}
package com.itcast.cn;

public class Test8 {
	
	public static void main(String[] args) {
		int a = (int) (Math.pow(2, 24)-1);
		
		System.out.println(a);
	}

}
package com.itcast.cn;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;

public class Test9 {
	
	@SuppressWarnings("resource")
	public static void main(String[] args) throws IOException {
		InputStreamReader inputStreamReader = new InputStreamReader(new FileInputStream("MM"));
		BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
		
		String readLine = bufferedReader.readLine();
		System.out.println(readLine);
	}

}
1.标准输入输出流
  其实标准输入输出是针对操作源跟目的区分的
	源: 键盘;
	目的: 控制台;
	它是字节流;
2.OutputStreamWriter 和 InputStreamReader
	以writer,Reader结尾是字符输出输入流;
	作用:将字节流转成字符流;
3. 打印流只针对输出流
    PrintStream(字节打印流)
	PrintWriter(字符打印流)
    特殊方法: 自动换行和自动刷新的方法
	println()//实现自动换行
	自动刷新需要通过构造方法传入 boolean的开关, 如果打开所有的println方法printf, format方法不用关流,也不用flush就可以实现刷下

4.ObjectInputStream 和 ObjectOutputStream 
	readObject()       writeObject();
	new ObjectInputStream(需要一个字节输入流)
	new ObjectOutputStream(需要一个字节输出流)

	注意:
		要写的对象必须实现序列化接口;

	对象流在使用的时候有一个国际规定, 只能存储一个对象,如果说想要存储多个对象,需要将多个对象存储到
	集合中,然后将集合对象存到文件;


	序列化和反序列化
	序列化是将对象存储到文本文件中的过程;
	反序列化从文本文件中将对象读到内存中;

	序列化ID 是对象一旦实现seralizeble接口的就会根据自身的成员和构造生成一个id,序列化的时候也会
	将这个id序列化到文件中, 如果一旦成员改变,就会导致文件中id和我们类中的id不一致, 
	解决方案:
		将这个id固定写好;

5. Properties 它是Map的一个孙子类,他的父亲是 Hashtable, 那么properties就具有我们map的所有方法;
	但是在使用Properties的使用都是往里面存储字符串键值对, 所以说我们以后用到它的方法也只有4个

	setProperties(String key , String value)// 这个相对mao于是put(K  key, V value)方法
	getProperties(String key); // 相对map中的get(K key)


	load("字符流和字节流都可以") // 可以将文件中的键值对读到Properties集合中, 
	store("字符流和字节流都可以", String conmment);//  这个是将properties中的键值对存储到io流关联的文件中
6.解决字符串编码乱码问题
	只要前有编码编码保持一致;

	转化流是可以指定编码表去读和写的,用的是它的构造函数




package com.itheima_01;

public class MyThread extends Thread {
	@Override
	public void run() {
		for (int i = 0; i < 100; i++) {
			System.out.println(getName() + ":" + i);
		}
	}
}
package com.itheima_01;
/*
 * 多线程：
 * 
 * 进程：当前正在运行的程序，一个应用程序在内存中的执行区域
 * 线程：进程中的一个执行控制单元，执行路径
 * 
 * 一个进程可以有一个线程，也可以有多个线程
 * 
 * 单线程：安全性高，但是效率低
 * 多线程：安全性低，效率高
 * 
 * 多线程案例：360,迅雷等
 * 
 */
public class ThreadDemo {

}
package com.itheima_01;
/*
 * 多线程的实现方式：
 * 		方式1：一种方法是将类声明为 Thread 的子类。该子类应重写 Thread 类的 run 方法。接下来可以分配并启动该子类的实例
 * 
 * Thread
 * 		String getName()      返回该线程的名称。 
 * 		void   setName(String name) 改变线程名称，使之与参数 name 相同。
 * 
 * 
 * CPU执行程序的随机性
 */
public class ThreadDemo2 {
	public static void main(String[] args) {
		//创建线程实例
		MyThread mt = new MyThread();
		//修改线程名字
		mt.setName("张三");
		
		//启动线程
		mt.start();
		
		//创建线程实例
		MyThread mt2 = new MyThread();
		mt2.setName("老王");
		
		//启动线程
		mt2.start();
	}
}
package com.itheima_01;
/*
 * 主方法是多线程吗？
 * 		主方法是单线程的
 * 
 */
public class ThreadDemo3 {
	public static void main(String[] args) {
		method();
		function();
	}
	
	
	public static void method() {}
	
	public static void function() {}
	
	

}
package com.itheima_02;

public class MyThread2 implements Runnable {
	int num;
	
	public MyThread2(int num) {
		this.num = num;
	}
	
	@Override
	public void run() {
		for (int i = 0; i < 100; i++) {
			//Thread t = Thread.currentThread();
			//System.out.println(t.getName() + ":" + i);
			
			//链式编程
			System.out.println(Thread.currentThread().getName() + ":" + i + num);
		}
	}

}
package com.itheima_02;
/*
 * 多线程实现方式2：创建线程的另一种方法是声明实现 Runnable 接口的类。该类然后实现 run 方法。然后可以分配该类的实例，在创建 Thread 时作为一个参数来传递并启动
 *
 *	Thread(Runnable target) 
 *	static Thread currentThread() :返回当前线程对象
 *
 *
 *	既然有了继承Thread为何还要整出来实现Runnable?
 */
public class ThreadDemo4 {
	public static void main(String[] args) {
		//创建线程实例
		MyThread2 mt = new MyThread2(100);
		Thread t = new Thread(mt);
		t.setName("李四");
		//启动线程
		t.start();
		
		//创建线程实例
		Thread t2 = new Thread(mt);
		t2.setName("老王");
		//启动线程
		t2.start();
	}

	private static void method() {
		//创建线程实例
		MyThread2 mt = new MyThread2(100);
		Thread t = new Thread(mt);
		t.setName("李四");
		//启动线程
		t.start();
		
		//创建线程实例
		MyThread2 mt2 = new MyThread2(200);
		Thread t2 = new Thread(mt2);
		t2.setName("老王");
		//启动线程
		t2.start();
	}

}
package com.itheima_03;

public class TicketThread implements Runnable {
	int tickets = 100;//火车票数量
	
	@Override
	public void run() {
		//出售火车票
		while(true) {
			//当火车票小于0张，则停止售票
			if(tickets > 0) {
				/*
				 * t1,t2,t3
				 * 假设只剩一张票
				 * t1过来了，他一看有票，他就进来了，但是他突然肚子不舒服，然后他就去上卫生间了
				 * t2也过来了，他一看也有票，他也进来了，但是他的肚子也不舒服，他也去上卫生间了
				 * 
				 * t1上完了卫生间回来了，开始售票
				 * 	tickets = 0;
				 * t2也上完卫生间回来了，他也进行售票
				 *  tickets = -1;
				 * 
				 * 
				 */
				try {
					Thread.sleep(100);
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				
				System.out.println(Thread.currentThread().getName() + ":" +tickets--);
			}
		}
	}

}
package com.itheima_03;
/*
 * 模拟火车站售票
 *		
 *		分析：
 *				首相需要有火车票的总数量，每售出一张则数量减一
 *				当火车票的数量小于1的时候，停止售票
 *				使用多线程模拟多个窗口进行售票
 *				当火车票全部售完，火车站也一样敞开大门欢迎我们
 *
 *		static void sleep(long millis) : 让当前线程睡一会
 */
public class TicktetTest {
	public static void main(String[] args) {
		//创建线程对象
		TicketThread tt = new TicketThread();
		
		Thread t = new Thread(tt);
		t.setName("窗口1");
		Thread t2 = new Thread(tt);
		t2.setName("窗口2");
		Thread t3 = new Thread(tt);
		t3.setName("窗口3");
		
		//启动线程对象
		t.start();
		t2.start();
		t3.start();
	}
}
package com.itheima_04;
/*
 * 问题出现的原因：
 * 		要有多个线程
 * 		要有被多个线程所共享的数据
 * 		多个线程并发的访问共享的数据
 * 
 * 在火车上上厕所
 * 张三来了，一看门是绿的，他就进去了，把门锁上了，门就变红了
 * 李四来了，一看门市红色的，他就只能憋着
 * 张三用完了厕所，把锁打开了，门就变成了绿色
 * 李四一看门变绿了，他就进去了，把门锁上，门就变红了
 * 王五来了，一看们是红色的，他也只能憋着
 * 李四用完测试了，把锁打开了，肚子又不舒服了，扭头回去了，又把门锁上了，
 * 
 * synchronized:同步（锁），可以修饰代码块和方法，被修饰的代码块和方法一旦被某个线程访问，则直接锁住，其他的线程将无法访问
 * 
 * 同步代码块：
 * 			synchronized(锁对象){
 * 
 * 			}
 * 
 * 注意：锁对象需要被所有的线程所共享
 * 
 * 
 * 同步：安全性高，效率低
 * 非同步：效率高，但是安全性低
 * 
 */
public class TicketThread implements Runnable {
	int tickets = 100;//火车票数量
	Object obj = new Object();
	
	@Override
	public void run() {
		//出售火车票
		while(true) {
			synchronized (obj) {

				if(tickets > 0) {
					
					try {
						Thread.sleep(100);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					
					System.out.println(Thread.currentThread().getName() + ":" +tickets--);
				}
			}
			
		}
	}

}
package com.itheima_04;

public class TicktetTest {
	public static void main(String[] args) {
		//创建线程对象
		TicketThread tt = new TicketThread();
		
		Thread t = new Thread(tt);
		t.setName("窗口1");
		Thread t2 = new Thread(tt);
		t2.setName("窗口2");
		Thread t3 = new Thread(tt);
		t3.setName("窗口3");
		
		//启动线程对象
		t.start();
		t2.start();
		t3.start();
	}
}
package com.itheima_05;
/*
 * 同步方法:使用关键字synchronized修饰的方法，一旦被一个线程访问，则整个方法全部锁住，其他线程则无法访问
 * 
 * synchronized
 * 注意：
 * 		非静态同步方法的锁对象是this
 * 		静态的同步方法的锁对象是当前类的字节码对象
 */
public class TicketThread implements Runnable {
	static int tickets = 100;// 火车票数量
	Object obj = new Object();

	@Override
	public void run() {
		// 出售火车票
		while (true) {
			/*synchronized (obj) {
				method();
			}*/
			
			//method();
			method2();

		}
	}

	private synchronized void method() {
		if (tickets > 0) {

			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			System.out.println(Thread.currentThread().getName() + ":" + tickets--);
		}
	}
	
	
	private static synchronized void method2() {
	
		if (tickets > 0) {

			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			System.out.println(Thread.currentThread().getName() + ":" + tickets--);
		}
	}

	

}
package com.itheima_05;

public class TicktetTest {
	public static void main(String[] args) {
		//创建线程对象
		TicketThread tt = new TicketThread();
		
		Thread t = new Thread(tt);
		t.setName("窗口1");
		Thread t2 = new Thread(tt);
		t2.setName("窗口2");
		Thread t3 = new Thread(tt);
		t3.setName("窗口3");
		
		//启动线程对象
		t.start();
		t2.start();
		t3.start();
	}
}
package com.itcast.cn;

public class Test12 {

	public static void main(String[] args) {
		Printer2 printer2 = new Printer2();
		new Thread() {
			public void run() {

				for (int i = 0; i < 100; i++) {

					printer2.print1();
				}

			};
		}.start();
		new Thread() {
			public void run() {
				for (int i = 0; i < 100; i++) {

					printer2.print2();
				}

			};
		}.start();
	}

}

class Printer2 {// 锁的wait()方法 ,锁的notify()方法

	int a = 1;

	public void print1() {
		synchronized (Printer2.class) {

			if (a == 1) {// -- > 线程1 
				try {
					Printer2.class.wait();// 是在    ---- >线程1躺再这里
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			// --->

			System.out.println("好好学习");
			a= 1;
			Printer2.class.notify();// 唤醒这个锁上除本线程以外的任意一条线程

		}
		//
	}

	public void print2() {//
		synchronized (Printer2.class) {//
			
			

			if (a == 0) {// -- >
				try {
					Printer2.class.wait();// 2躺再这里 
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}

			System.out.println("天天向上");

			a = 0;
			Printer2.class.notify();
		}
	}
}
package com.itcast.cn;

public class Test4 {

	public static void main(String[] args) {

		System.out.println(Thread.currentThread().getName());
		// 第一种继承Thread的方式
		Thread thread = new Thread() {// 定义一个类继承了Thread    //多态的体现
			@Override
			public void run() {//重写run方法
				for (int i = 0; i < 100; i++) {
					System.out.println(getName() + "说:好好学习,天天向上");
				}
			}
		};
		thread.setName("青霞姐");
		thread.start();
		// 第二种方式,实现Runnale方式
		

		Thread thread2 = new Thread(new Runnable() {// 定义一个类,实现了runnable接口

			@Override
			public void run() {

				for (int i = 0; i < 100; i++) {
					System.out.println(Thread.currentThread().getName() + "说:好好运动,争取运动出个结果");
				}

			}
		});
		thread2.setName("慈世平");
		thread2.start();
		
		
		
	}

}
package com.itcast.cn;

public class Sport1Say implements Runnable{

	@Override
	public void run() {
		for (int i = 0; i < 100; i++) {
			
			System.out.println(Thread.currentThread().getName()+"说:好好运动,争取运动出个结果");
			
		}
		
	}

}
package com.itcast.cn;

public class SporterSay  extends  Thread{

	@Override
	public void run() {
		
		for (int i = 0; i < 100; i++) {
			
			System.out.println(getName() +"说:好好运动,争取运动出个结果");
		}
	}
}
package com.itcast.cn;

public class Star1Say implements Runnable{

	@Override
	public void run() {
		
		for (int i = 0; i < 100; i++) {
			System.out.println(Thread.currentThread().getName()+"说:好好学习,天天向上");
			
		}
		
	}
	
	

}
package com.itcast.cn;

public class StarSay  extends Thread{
	@Override
	public void run() {
		
		for (int i = 0; i < 100; i++) {
			System.out.println(getName() +"说:要好好学习,天天向上");
		}
	}
	
	

}
package com.itcast.cn;

public class Test10 {
	
	public static void main(String[] args) {
		//Printer printer = new Printer();
		
		new Thread(){
			@Override
			public void run() {
				for (int i = 0; i < 100; i++) {
					
					Printer.print1();
				}
			}
		}.start();
		new Thread(){
			@Override
			public void run() {
				for (int i = 0; i < 100; i++) {
					
					Printer.print2();
				}
			}
		}.start();
	}

}


class Printer {
	
	
	public static synchronized void print1(){//普通方法加的锁this
		System.out.println("阿斗是");
		try {
			Thread.sleep(100);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		System.out.println("刘备的儿子---------------------------");
	}
	
	
	public static void print2(){
		
		synchronized (Printer.class) {
			System.out.println("曹丕");
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			System.out.println("是曹操的儿子**************************");
		}
		
	}
}
package com.itcast.cn;

public class Test2 {
	public static void main(String[] args) {
		StarSay say = new StarSay();
		say.setName("青霞姐");
		say.start();
		//---->开启线程  --- run()
		
		SporterSay say2 = new SporterSay();
		say2.setName("慈世平");
		say2.start();//---->开启线程,---> run()
		
		
	}
	
	public static void get(){
		
	}

}
package com.itcast.cn;

public class Test3 {
	
	public static void main(String[] args) {
		Star1Say say = new Star1Say();
		Thread thread = new Thread(say);
		thread.setName("青霞姐");
		thread.start();
		
		Sport1Say say2 = new Sport1Say();
		Thread thread2 = new Thread(say2);
		thread2.setName("女兆日月");
		thread2.start();
		
		
	}

}
package com.itcast.cn;

public class Test4 {

	public static void main(String[] args) {

		System.out.println(Thread.currentThread().getName());
		// 第一种继承Thread的方式
		Thread thread = new Thread() {// 定义一个类继承了Thread    //多态的体现
			@Override
			public void run() {//重写run方法
				for (int i = 0; i < 100; i++) {
					System.out.println(getName() + "说:好好学习,天天向上");
				}
			}
		};
		thread.setName("青霞姐");
		thread.start();
		// 第二种方式,实现Runnale方式
		

		Thread thread2 = new Thread(new Runnable() {// 定义一个类,实现了runnable接口

			@Override
			public void run() {

				for (int i = 0; i < 100; i++) {
					System.out.println(Thread.currentThread().getName() + "说:好好运动,争取运动出个结果");
				}

			}
		});
		thread2.setName("慈世平");
		thread2.start();
		
		
		
	}

}
package com.itcast.cn;

public class Test5 {

	public static void main(String[] args) {

		HeroSay heroSay = new HeroSay();

		Thread thread = new Thread() {// 这个线程专门负责盖伦的言辞
			@Override
			public void run() {
				for (int i = 0; i < 100; i++) {

					heroSay.gaiLunSay(getName());
				}

			}
		};
		thread.setName("盖伦");
		thread.start();

		Thread thread1 = new Thread() {// 这个线程专门负责盖伦的言辞
			@Override
			public void run() {

				for (int i = 0; i < 100; i++) {

					heroSay.timoSay(getName());
					;
				}
			}
		};
		thread1.setName("提莫");
		thread1.start();

		/*
		 * Thread thread2 = new Thread(){//这个线程专门负责盖伦的言辞
		 * 
		 * @Override public void run() { heroSay.xiaoPaoSay(getName());; } };
		 * thread2.setName("小炮"); thread2.start();
		 */

	}

}

class HeroSay {
	
	Object object = new Object();

	public void gaiLunSay(String name) {

		synchronized (object) {//---->左大括号执行玩,我们的锁就会被锁上(进厕所关门)

			System.out.println("张飞");// ---->锁被锁住了
			System.out.println("是男的");
		}//遇到右大括号就开锁;
	}

	public void timoSay(String name) {
		synchronized (object) {//(如果厕所关着门,就得忍着);
			System.out.println("貂蝉");// ---->
			System.out.println("是女的");// --->
		}
	}
	/*
	 * public void xiaoPaoSay(String name){ System.out.println(name
	 * +"说:一日为班德尔,终生为班德尔炮手"); System.out.println(name +"说:好像射点什么"); }
	 */

}
package com.itcast.cn;

public class Test6 {
	
	public static void main(String[] args) {
		String s = "name";
		String s1 = "name";
		System.out.println(s==s1);
	}

}
package com.itcast.cn;

import java.io.IOException;

public class Test7 {
	public static void main(String[] args) {
		Thread thread = new Thread();
		thread.run();
				
	}


}

class MyDemo extends Demo{
	@Override
	public void getname()throws Exception {//子类不能比父类更坏,这个是错误演示
		// TODO Auto-generated method stub
		super.getname();
	}
}
class Demo{
	
	public void getname()throws IOException {
		
	}
}
package com.itcast.cn;

public class Test8 {

	public static void main(String[] args) {
		Window window = new Window();

		Thread thread1 = new Thread(window);
		thread1.setName("窗口1");
		Thread thread2 = new Thread(window);
		thread2.setName("窗口2");
		Thread thread3 = new Thread(window);
		thread3.setName("窗口3");
		thread1.start();
		thread2.start();
		thread3.start();

	}

}

class Window implements Runnable {
	int ticket = 200;

	@Override
	public void run() {// 都在做卖票的这个任务
		while (true) {
			synchronized (Window.class) {

				if (ticket < 1) {// 1
					// --->1,2,3
					break;
				}
				
				System.out.println(Thread.currentThread().getName() + ":卖出了" + ticket-- + "票");
			}
		}

	}

}
package com.itcast.cn;

public class Test9 {

	public static void main(String[] args) {
		//demo1();
		Window1 window1 = new Window1();
		window1.setName("林青霞");
		Window1 window2 = new Window1();
		window2.setName("张曼玉");
		Window1 window3 = new Window1();
		window3.setName("王祖贤");
		Window1 window4 = new Window1();
		window4.setName("朱茵");
		
		window1.start();
		window2.start();
		window3.start();
		window4.start();
		
		
		
		

	}

	private static void demo1() {
		RailwayStation railwayStation = new RailwayStation();// 首先由火车站

		// 开始创建窗口
		Thread thread1 = new Thread(railwayStation);
		thread1.setName("林青霞");
		Thread thread2 = new Thread(railwayStation);
		thread2.setName("张曼玉");
		Thread thread3 = new Thread(railwayStation);
		thread3.setName("王祖贤");
		Thread thread4 = new Thread(railwayStation);
		thread4.setName("朱茵");
		thread1.start();
		thread2.start();
		thread3.start();
		thread4.start();
	}

}

class Window1 extends Thread {
	private static int ticket = 100;
	//private Object object = new Object();

	@Override
	public void run() {// 写卖票的动作

		while (true) {
			synchronized (Window1.class) {
				
				if (ticket <= 0) {
					break;
				}
				
				try {
					Thread.sleep(100);
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				System.out.println(getName() + ":卖出第" + ticket-- + "张票");
			}
		}

	}

}

class RailwayStation implements Runnable {
	private int ticket = 100;

	@Override
	public void run() {// run方法里放置卖票的功能
		while (true) {
			// 当如果票<1的时候,就将窗口关掉
			if (ticket <= 0) {
				break;
			}

			System.out.println(Thread.currentThread().getName() + ":卖出去第" + ticket-- + "张票");

		}
	}

}
package com.itcast.cn.beans;
import com.itcast.cn.interfaces.Payment;

public class Alipay implements Payment {

	private int money;

	public Alipay(int money) {
		super();
		this.money = money;
	}

	public int getMoney() {
		return money;
	}

	public void setMoney(int money) {
		this.money = money;
	}

	@Override
	public boolean pay(int money) {

		if (this.money < money) {
			System.out.println("账号余额不足");
			return false;
		}
		System.out.println("支付成功");
		this.money += money;
		return true;
	}

}
package com.itcast.cn.beans;
import java.io.Serializable;

public class Commodity implements Serializable{

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private String name;
	private int price;
	
	

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((address == null) ? 0 : address.hashCode());
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		result = prime * result + price;
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Commodity other = (Commodity) obj;
		if (address == null) {
			if (other.address != null)
				return false;
		} else if (!address.equals(other.address))
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		if (price != other.price)
			return false;
		return true;
	}

	private String address;

	public String getAddress() {
		return address;
	}

	public void setAddress(String address) {
		this.address = address;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getPrice() {
		return price;
	}

	@Override
	public String toString() {
		return "Commodity [name=" + name + ", price=" + price + "]";
	}

	public void setPrice(int price) {
		this.price = price;
	}

	public Commodity(String name, int price) {
		super();
		this.name = name;
		this.price = price;
	}
	
	

}
package com.itcast.cn.beans;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;

import com.itcast.cn.interfaces.Payment;
import com.itcast.cn.utils.DBUtil;

public class User implements Serializable {

	public User(String username, String password) {
		super();
		this.username = username;
		this.password = password;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((username == null) ? 0 : username.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		User other = (User) obj;
		if (username == null) {
			if (other.username != null)
				return false;
		} else if (!username.equals(other.username))
			return false;
		return true;
	}

	public User(String username, String password, List<String> addresses) {
		super();
		this.username = username;
		this.password = password;
		this.addresses = addresses;

	}

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private String username;
	private String password;

	private List<String> addresses = new ArrayList<>();
	private Map<Commodity, Integer> cart = new HashMap<>();
	private Map<Commodity, Integer> bought = new HashMap<>();

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getPassword() {
		return password;
	}

	public void setPassword(String password) {
		this.password = password;
	}

	public List<String> getAddresses() {
		return addresses;
	}

	public void setAddresses(List<String> addresses) {
		this.addresses = addresses;
	}

	public Map<Commodity, Integer> getCart() {
		return cart;
	}

	public Map<Commodity, Integer> getBought() {
		return bought;
	}

	// 用户有结账方法
	public boolean payList(Payment payment) throws Exception {

		if (cart == null) {
			System.out.println("购物车为空");
			return false;
		}
		// 剩下将购物车里面的所有的商品的价格相加
		int sum = 0;
		Set<Commodity> set = cart.keySet();
		for (Commodity commodity : set) {
			int price = commodity.getPrice();
			Integer integer = cart.get(commodity);
			sum += price * integer;
		}
		// 价格计算出来后,去字符
		boolean pay = payment.pay(sum);
		// 如果支付成功了,购物车就要清空;代收货物的就增多了
		if (pay) {

			putCartIntoBought();

		}

		return pay;

	}

	/**
	 * 将购物车车的东西放置到待收货物车中
	 * 
	 * @throws Exception
	 */
	private void putCartIntoBought() throws Exception {

		Set<Commodity> keySet = cart.keySet();

		for (Commodity commodity : keySet) {
			if (bought.containsKey(commodity)) {
				bought.put(commodity, bought.get(commodity) + cart.get(commodity));
			} else {
				bought.put(commodity, cart.get(commodity));
			}
		}

		cart.clear();

		// 需要将信息存储起来
		DBUtil.restoreUser(this);

	}
	//用来记录最近一次购买的货物
	private Commodity lastCommodity;

	// 用户有购物的方法
	public void addCart(Commodity commodity) throws Exception {
		this.lastCommodity = commodity;
		// 在添加商品的时候需要给定商品地址
		showAddress();
		Scanner scanner = new Scanner(System.in);
		System.out.println("请选择地址");
		int number = scanner.nextInt();
		commodity.setAddress(addresses.get(number));

		if (cart.containsKey(commodity)) {

			cart.put(commodity, cart.get(commodity) + 1);
		} else {
			cart.put(commodity, 1);
		}
	}

	private void showAddress() throws Exception {
		System.out.println("请输入序号选择地址");
		if (addresses.size() == 0) {
			// 说明没有地址,提示用户添加地址
			addAddress();
		} else {
			for (int i = 0; i < addresses.size(); i++) {
				System.out.println(i + "." + addresses.get(i));
			}
		}
	}

	private void addAddress() throws Exception {
		System.out.println("请输入需要添加的收货地址,可以多条添加,输入ok结束添加地址");
		Scanner scanner = new Scanner(System.in);
		while (true) {
			System.out.println("请输入地址");
			String nextLine = scanner.nextLine();

			if ("ok".equals(nextLine)) {
				
				DBUtil.restoreUser(this);
				
				addCart(lastCommodity);
				break;
			}
			addresses.add(nextLine);
		}
	}
}
package com.itcast.cn.beans;
import com.itcast.cn.interfaces.Payment;

public class WeChartPay implements Payment {
	private int money;

	public WeChartPay(int money) {
		super();
		this.money = money;
	}

	public int getMoney() {
		return money;
	}

	public void setMoney(int money) {
		this.money = money;
	}

	@Override
	public boolean pay(int money) {
		if (this.money < money) {
			System.out.println("对不起余额不足,支付失败");
			return false;
		}
		System.out.println("支付成功");
		this.money -= money;
		return true;
	}

}
package com.itcast.cn.interfaces;
import java.util.List;

import com.itcast.cn.beans.User;

public interface Mall {

	boolean login(User user);

	void logout()throws Exception;

	void showCommodities() throws Exception;

}
package com.itcast.cn.interfaces;

public interface Payment {
	
	boolean pay(int money);

}
package com.itcast.cn.interfaces;

public class UserAlreadyExistException extends Exception{

	public UserAlreadyExistException() {
		super();
		// TODO Auto-generated constructor stub
	}

	public UserAlreadyExistException(String message, Throwable cause, boolean enableSuppression,
			boolean writableStackTrace) {
		super(message, cause, enableSuppression, writableStackTrace);
		// TODO Auto-generated constructor stub
	}

	public UserAlreadyExistException(String message, Throwable cause) {
		super(message, cause);
		// TODO Auto-generated constructor stub
	}

	public UserAlreadyExistException(String message) {
		super(message);
		// TODO Auto-generated constructor stub
	}

	public UserAlreadyExistException(Throwable cause) {
		super(cause);
		// TODO Auto-generated constructor stub
	}
	
	

}
package com.itcast.cn;
import java.util.Scanner;

import com.itcast.cn.beans.Alipay;
import com.itcast.cn.beans.Commodity;
import com.itcast.cn.beans.User;
import com.itcast.cn.interfaces.UserAlreadyExistException;
import com.itcast.cn.server.JingDong;
import com.itcast.cn.utils.Constants;
import com.itcast.cn.utils.DBUtil;

public class MainEntry {

	public static void main(String[] args) {
		// 首先进入京东页面(也就是创建出京东客户端)
		JingDong dong = new JingDong();
		try {
			inputInfor(dong);
		} catch (Exception e) {
			System.out.println("服务器错误,错误码:"+ Constants.SERVER_OTHER_ERROR);
			e.printStackTrace();
		}

	}

	/**
	 * 登录的输入信息的处理逻辑
	 * 
	 * @param dong
	 *            京东客户端
	 * @throws Exception
	 */
	private static void inputInfor(JingDong dong) throws Exception {
		// 1.提示用户输入
		Scanner scanner = new Scanner(System.in);
		System.out.println("请输入登录账号");
		String username = scanner.nextLine();
		System.out.println("请输入登录密码");
		String password = scanner.nextLine();
		// 调用京东登录的方法
		User user = new User(username, password);
		boolean login = dong.login(user);

		if (login) {// 说明登录成功
			// 登录成功的话,将商品列表展示出来;
			showCommodities(dong);
		} else {
			// 登录失败的时候,弹出三个选择1.重新登录2.注册,3.退出

			again(dong);

		}

	}

	/**
	 * 用于登录失败的处理逻辑
	 * 
	 * @param dong
	 * @throws Exception
	 */
	private static void again(JingDong dong) throws Exception {
		Scanner scanner = new Scanner(System.in);

		System.out.println("请输入想要操作的序号");
		System.out.println("1.重新登录");
		System.out.println("2.注册");

		int nextInt = scanner.nextInt();

		switch (nextInt) {
		case 1:// 重新登录
			inputInfor(dong);

			break;
		case 2:
			regester();

			break;

		default:
			break;
		}

	}

	/**
	 * 注册用户
	 * 
	 * @throws Exception
	 */
	private static void regester() throws Exception {

		Scanner scanner = new Scanner(System.in);
		System.out.println("请输入注册账号");
		String username = scanner.nextLine();
		System.out.println("请输入注册密码");
		String password = scanner.nextLine();
		User user = new User(username, password);

		try {
			DBUtil.registerUser(user);
		} catch (UserAlreadyExistException e) {
			System.out.println("对不起用户已经存在,请重新注册");
			regester();
		}

	}

	/**
	 * 列出清单的方法
	 * 
	 * @param dong
	 */
	private static void showCommodities(JingDong dong) {

		try {
			dong.showCommodities();
			// 如果走到这里,说明服务器数据是没有问题;
			// 提示用户购买东西
			buyCommodity(dong);
		} catch (Exception e) {
			System.out.println("服务器错误,错误码是" + Constants.SERVER_COMMODITYDB_ERROR);
			e.printStackTrace();
		}

	}

	/**
	 * 购买商品的逻辑
	 * @param dong
	 * @throws Exception
	 */
	private static void buyCommodity(JingDong dong) throws Exception {
		System.out.println();//方便用户查看操作
		System.out.println("请输入商品编号进行购买, 输入0退出京东, 输入1结账");
		
		Scanner scanner = new Scanner(System.in);
		
		int nextInt = scanner.nextInt();

		switch (nextInt) {
		case 0:
			dong.logout();
			
			//退出系统
			System.exit(0);
			
			break;
		case 1:
			boolean payList = dong.getUser().payList(new Alipay(20000));
			if(payList){
				System.out.println("购买成功,你的待收货物有以下列表,欢迎下次光临");
				System.out.println(dong.getUser().getBought());
				System.exit(0);//退出系统
				
			}
			break;

		default://其他是商品的编号
			//说明是需要购买的的商品
			Commodity commodity = DBUtil.getCommodities().get(nextInt-2);
			
			dong.getUser().addCart(commodity);
			buyCommodity(dong);
			
			break;
		}

	}

}
package com.itcast.cn.server;
import java.util.ArrayList;

import com.itcast.cn.beans.Commodity;
import com.itcast.cn.beans.User;
import com.itcast.cn.interfaces.Mall;
import com.itcast.cn.utils.Constants;
import com.itcast.cn.utils.DBUtil;


public class JingDong implements Mall {

	private User user;

	public User getUser() {
		return user;
	}

	@Override
	public boolean login(User user) {
		// 通过查用户列表,看下我们输入的正确与否

		// 模拟查找数据库
		try {
			ArrayList<User> users = DBUtil.getUsers();

			boolean isSuccess = false;

			for (User user2 : users) {
				if (user2.getUsername().equals(user.getUsername()) && user2.getPassword().equals(user.getPassword())) {
					this.user = user2;
					isSuccess = true;
				}
			}
			return isSuccess;

		} catch (Exception e) {
			e.printStackTrace();
			// 提示用户
			System.out.println("对不起,服务端错误" + Constants.SERVER_USERDB_ERROR);

			return false;
		}

	}

	@Override
	public void logout() throws Exception {
		// 购物结束, 也就是京东的User要置为空
		// 为了简便起见这里就在退出的时候保存,声明:这里只是模拟京东数据保存,真正的京东用户保存数据用的json字符串保存的
		// 这里json大家没有 学习过,这里用对象流在保存
		DBUtil.restoreUser(user);
		user = null;

	}

	@Override
	public void showCommodities() throws Exception {
		System.out.println("请根据商品序号进行选择");

		ArrayList<Commodity> list = DBUtil.getCommodities();

		for (int i = 0; i < list.size(); i++) {
			System.out.print((i+1+1) + "." + list.get(i) + "  ");
		}
		
		

	}

}
package com.itcast.cn;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.ArrayList;

import com.itcast.cn.beans.Commodity;
import com.itcast.cn.beans.User;
/**
 * 整个是测试
 * @author King
 *
 */
public class Test1 {

	public static void main(String[] args) throws Exception {
		 //demo2();
		//
		// demo1();

		 demo();
		
		

	}

	private static void demo() throws IOException, FileNotFoundException {
		ArrayList<Commodity> list = new ArrayList<>();

		list.add(new Commodity("奶粉", 235));
		list.add(new Commodity("尿不湿", 10));
		list.add(new Commodity("幼儿车", 435));
		list.add(new Commodity("奶瓶", 80));
		list.add(new Commodity("婴儿浴盘", 200));

		ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("Commodities.db"));
		objectOutputStream.writeObject(list);
		objectOutputStream.close();
	}

	private static void demo2() throws IOException, FileNotFoundException {
		// 存储用户列表
		ArrayList<User> list = new ArrayList<>();
		list.add(new User("zhangsan", "123123"));
		list.add(new User("lisi", "123123"));
		list.add(new User("zhaoliu", "123123"));

		ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("users.db"));
		objectOutputStream.writeObject(list);

		objectOutputStream.close();
	}

	private static void demo1() throws IOException, FileNotFoundException, ClassNotFoundException {
		ObjectInputStream stream = new ObjectInputStream(new FileInputStream("users.db"));
		Object readObject = stream.readObject();

		ArrayList<User> l = (ArrayList<User>) readObject;

		System.out.println(l.size());

		for (User user : l) {

			System.out.println(user.getUsername() + "::" + user.getPassword());

		}
	}

}
package com.itcast.cn.utils;

public interface Constants {
	
	int  SERVER_USERDB_ERROR = 0;//服务器用户数据库有问题
	int  SERVER_COMMODITYDB_ERROR = 1;//服务器商品数据库有问题
	int  SERVER_OTHER_ERROR = 2;//服务器商品数据库有问题

}
package com.itcast.cn.utils;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.ArrayList;
import java.util.Iterator;

import com.itcast.cn.beans.Commodity;
import com.itcast.cn.beans.User;
import com.itcast.cn.interfaces.UserAlreadyExistException;

public class DBUtil {

	private DBUtil() {
	}

	public static ArrayList<User> getUsers() throws Exception {
		ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream("users.db"));
		return (ArrayList<User>) inputStream.readObject();
	}

	public static void registerUser(User user) throws Exception {
		ArrayList<User> users = getUsers();
		if(users.contains(user)){
			throw new UserAlreadyExistException();
		}
		users.add(user);
		ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream("users.db"));
		stream.writeObject(users);
	}

	public static ArrayList<Commodity> getCommodities() throws Exception {
		ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream("Commodities.db"));
		return (ArrayList<Commodity>) inputStream.readObject();
	}

	public static void storeUser(ArrayList<User> users) throws Exception {

		ObjectOutputStream stream = new ObjectOutputStream(new FileOutputStream("users.db"));
		stream.writeObject(users);

	}

	public static void restoreUser(User user) throws Exception {

		ArrayList<User> users = getUsers();
		Iterator<User> iterator = users.iterator();
		while (iterator.hasNext()) {
			User next = iterator.next();
			if (next.getUsername().equals(user.getUsername())) {
				iterator.remove();
			}
		}
		users.add(user);

		storeUser(users);

	}

}
1. 多线程
多 -->多个
线---> 执行线路
程--->程序
多个执行线路的程序;


一个程序开启就会对应一个进程

一个进程中可以有多个执行线程

进程: 正在执行的程序;
线程: 执行线程

并行:
	同时执行;
并发:
	轮流执行;

2.创建线程第一种的步骤
	1.定义一个类继承Thread
	2. 重写run方法
	3.将要执行的代码放入到run方法中
	4.创建子类实例
	5.调用start();

	调用run()和start()方法的区别:
		run()方法只是一个普通的方法
		start()虚拟机会帮我们开启一条执行线路
	线程的特点:
		从哪里跌倒就从哪里爬起来;
3.创建线程的第二种的步骤
	1.定义一个类去实现runnable接口
	2.实现run方法
	3. 将要执行的写到run方法中,
	4.创建实现类A的实例
	5.创建Thread的实例,将A作为构造参数传递过来
	6.通过hread的实例的实例开启线程;

5.两种方式的匿名内部类的方式实现
	
	new Thread(){//定义一个类继承Thread

		public void run(){//重写Thread的run方法
			需要执行的代码;//将需要执行的代码放入run方法中
		}
	}.start();//开启线程


	new Thread(new Runnable(){//定义一个类实现Runable

		public void run(){//重写Thread的run方法
			需要执行的代码;//将需要执行的代码放入run方法中
		}
	}).start();//通过Thread开启线程

4. synchronized (添加锁对象){
	需要被锁住的内容;
}

用途: 
	我们需要一条线程执行完,其他线程才有机会进来的代码我们需要用同步锁框起来;



5.关于异常的注意事项
	如果父类方法有异常,子类在重写这个方法的时候,不能比父类的这个方法抛出的异常大
	如果父类的方法没有异常,子类在重写这个方法的时候,就不能有异常;
6.同步方法
	如果是非静态的话,同步锁是this
	如果是静态方法的话,是该类的字节码对象;
7.线程的生命周期
	创建 ----> 就绪 -----> 运行-----> 死亡
	             |           |
				 |			 |
					等待(调用sleep方法)



	


1. 多线程
多 -->多个
线---> 执行线路
程--->程序
多个执行线路的程序;


一个程序开启就会对应一个进程

一个进程中可以有多个执行线程

进程: 正在执行的程序;
线程: 执行线程

并行:
	同时执行;
并发:
	轮流执行;

2.创建线程第一种的步骤
	1.定义一个类继承Thread
	2. 重写run方法
	3.将要执行的代码放入到run方法中
	4.创建子类实例
	5.调用start();

	调用run()和start()方法的区别:
		run()方法只是一个普通的方法
		start()虚拟机会帮我们开启一条执行线路
	线程的特点:
		从哪里跌倒就从哪里爬起来;
3.创建线程的第二种的步骤
	1.定义一个类去实现runnable接口
	2.实现run方法
	3. 将要执行的写到run方法中,
	4.创建实现类A的实例
	5.创建Thread的实例,将A作为构造参数传递过来
	6.通过hread的实例的实例开启线程;

5.两种方式的匿名内部类的方式实现
	
	new Thread(){//定义一个类继承Thread

		public void run(){//重写Thread的run方法
			需要执行的代码;//将需要执行的代码放入run方法中
		}
	}.start();//开启线程


	new Thread(new Runnable(){//定义一个类实现Runable

		public void run(){//重写Thread的run方法
			需要执行的代码;//将需要执行的代码放入run方法中
		}
	}).start();//通过Thread开启线程

4. synchronized (添加锁对象){
	需要被锁住的内容;
}

用途: 
	我们需要一条线程执行完,其他线程才有机会进来的代码我们需要用同步锁框起来;



5.关于异常的注意事项
	如果父类方法有异常,子类在重写这个方法的时候,不能比父类的这个方法抛出的异常大
	如果父类的方法没有异常,子类在重写这个方法的时候,就不能有异常;
6.同步方法
	如果是非静态的话,同步锁是this
	如果是静态方法的话,是该类的字节码对象;
7.线程的生命周期
	创建 ----> 就绪 -----> 运行-----> 死亡
	             |           |
				 |			 |
					等待(调用sleep方法)
8.线程间的通信
	注意重点: 线程间的通信是通过同步锁来通信,注意需要通信的线程的锁必须一样吧
		wait();//使当前线程处于等待状态, 这个只能被notify()或者notifyAll()唤醒

		notify();//唤醒这把锁上除本线程以外的其他任意一条线程;
9 . final的最后一个作用:延长数据的生命周期,把数据存储到常量池中,JDK1.8后,自动加final
	内部类访问局部变量的时候,局部变量需要被final修饰,延长变量的生命周期.





	


package com.itcast.cn;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.net.UnknownHostException;

public class Client {

	public static void main(String[] args) throws Exception {
		Socket socket = new Socket("127.0.0.1", 9527);// 这个要连接的服务器的地址和端口;

		// 我们需要拿到听筒和话筒
		OutputStream outputStream = socket.getOutputStream();
		InputStream inputStream = socket.getInputStream();
		byte[] arr = new byte[1024];
		int len = inputStream.read(arr);
		System.out.println(new String(arr, 0, len));
		// 问百度问题
		outputStream.write("林志玲多高".getBytes());
		// 得到答案
		int len2 = inputStream.read(arr);
		System.out.println(new String(arr, 0, len2));

		socket.close();// 关闭socket,他会自动帮我们关闭流
	}

}
package com.itcast.cn;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.net.UnknownHostException;

public class Client1 {

	public static void main(String[] args) throws Exception {
		Socket socket = new Socket("127.0.0.1", 8765);

		OutputStream outputStream = socket.getOutputStream();// 话筒
		InputStream inputStream = socket.getInputStream();// 听筒
		byte[] arr = new byte[1024];
		int read = inputStream.read(arr);//等
		System.out.println(read);
		outputStream.write("我不好".getBytes());

		socket.close();

	}

}
package com.itcast.cn;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintStream;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.Scanner;

public class Client3 {

	public static void main(String[] args) throws Exception {
		Socket socket = new Socket("127.0.0.1", 9527);
		InputStream inputStream = socket.getInputStream();
		OutputStream outputStream = socket.getOutputStream();

		// 封装成我们喜欢的字符流
		BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
		// 封装我们话筒
		//BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(outputStream));

		PrintStream printStream = new PrintStream(outputStream);
		// 首先需要向服务器写一个字符串
		Scanner scanner = new Scanner(System.in);
		String context = scanner.nextLine();
		printStream.println(context);
		// 拿到服务器返回给我们的数据
		String readLine = reader.readLine();
		System.out.println(readLine);
		socket.close();

	}

}
package com.itcast.cn;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.Scanner;

public class Client4 {

	public static void main(String[] args) throws Exception {
		Socket socket = new Socket("127.0.0.1", 9527);

		BufferedReader reader = new BufferedReader(new // 包装后的听筒
				InputStreamReader(socket.getInputStream()));

		PrintStream stream = new PrintStream(socket.getOutputStream());

		Scanner scanner = new Scanner(System.in);
		System.out.println("请输入账号:");
		String username = scanner.nextLine();
		System.out.println("请输入密码");
		String password = scanner.nextLine();
		stream.println(username);
		stream.println(password);

		// 拿到登录结果
		String result = reader.readLine();
		System.out.println(result);
		socket.close();

	}

}
package com.itcast.cn;

import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;

public class Receiver {

	public static void main(String[] args) throws Exception {
		DatagramSocket datagramSocket = new DatagramSocket(8888);

		DatagramPacket p = new DatagramPacket(new byte[1024], 1024);// 创建一个空包,用来接收数据

		while (true) {
			// 字节收据
			datagramSocket.receive(p);// 是个阻塞方法, 如果没有数据过来就不会走这行代码,一直等,最后变成了化石
			// 走到这里,证明已经接收到数据了,而且数据装载在我们刚才创建的空包里面
			// 可以去包里拿数据
			byte[] data = p.getData();// 获取发送内容
			InetAddress address = p.getAddress();// 获取发送端的地址对象
			int port = p.getPort();// 获取发送端的端口
			int length = p.getLength();// 获取内容的有效长度
			// 展示数据
			System.out.println("发送端的ip为" + address.getHostAddress());
			System.out.println("发送端的端口为" + port);
			System.out.println("发送端的内容为" + new String(data, 0, length));

		}
		//datagramSocket.close();

	}

}
package com.itcast.cn;

import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;

public class Receiver2 {

	public static void main(String[] args) throws Exception {
		DatagramSocket datagramSocket = new DatagramSocket(8888);

		DatagramPacket p = new DatagramPacket(new byte[1024], 1024);// 创建一个空包,用来接收数据
		while (true) {

			// 字节收据
			datagramSocket.receive(p);// 是个阻塞方法, 如果没有数据过来就不会走这行代码,一直等,最后变成了化石
			// 走到这里,证明已经接收到数据了,而且数据装载在我们刚才创建的空包里面
			// 可以去包里拿数据
			byte[] data = p.getData();// 获取发送内容
			InetAddress address = p.getAddress();// 获取发送端的地址对象
			int port = p.getPort();// 获取发送端的端口
			int length = p.getLength();// 获取内容的有效长度
			// 展示数据
			System.out.println("发送端的ip为" + address.getHostAddress());
			System.out.println("发送端的端口为" + port);
			System.out.println("发送端的内容为" + new String(data, 0, length));

		}

		// datagramSocket.close();

	}

}
package com.itcast.cn;

import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.util.Scanner;

public class Sender {

	public static void main(String[] args) throws Exception {
		DatagramSocket socket = new DatagramSocket();// 如果不给端口,系统会随机分配一个
		// 需要打包

		// 需要用户自己定义发送内容,想发很多次,直接标识是 "byebye";
		Scanner scanner = new Scanner(System.in);

		while (true) {
			String nextLine = scanner.nextLine();

			if (nextLine.equals("byebye")) {
				break;
			}
			DatagramPacket p = new DatagramPacket(nextLine.getBytes(), nextLine.getBytes().length,
					InetAddress.getByName("127.0.0.1"), 8888);
			// 发送
			socket.send(p);

		}

		// 关闭资源
		socket.close();
	}

}
package com.itcast.cn;

import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.util.Scanner;

public class Sender2 {

	public static void main(String[] args) throws Exception {
		DatagramSocket socket = new DatagramSocket();// 如果不给端口,系统会随机分配一个
		// 需要打包

		Scanner scanner = new Scanner(System.in);

		while (true) {
			String nextLine = scanner.nextLine();
			if (nextLine.equals("ok")) {
				break;
			}
			DatagramPacket p = new DatagramPacket(nextLine.getBytes(), nextLine.getBytes().length,
					InetAddress.getByName("127.0.0.1"), 8888);
			// 发送
			socket.send(p);

		}

		// 关闭资源
		socket.close();
	}

}
package com.itcast.cn;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class Server {

	public static void main(String[] args) throws IOException {
		ServerSocket serverSocket = new ServerSocket(9527);// serverSocket只是一个可以产生Socket的一个东西,自己本身不具有收发数据的功能

		// 通过ServerSocket获取socket

		Socket accept = serverSocket.accept();// 是一个阻塞方法;
		InputStream inputStream = accept.getInputStream();
		OutputStream outputStream = accept.getOutputStream();// 服务端的话筒,可以向客户选听筒说话
		outputStream.write("百度一下, 你就知道".getBytes());
		byte[] arr = new byte[1024];
		int len = inputStream.read(arr);
		// 拿到了客户的问题
		System.out.println(new String(arr, 0, len));
		// 回馈给客户答案
		outputStream.write("178cm".getBytes());

		accept.close();

	}

}
package com.itcast.cn;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class Server1 {

	public static void main(String[] args) throws IOException {
		ServerSocket serverSocket = new ServerSocket(8765);

		Socket accept = serverSocket.accept();

		InputStream inputStream = accept.getInputStream();
		OutputStream outputStream = accept.getOutputStream();
		byte[] arr = new byte[1024];
		int read = inputStream.read(arr);

		outputStream.write("你好".getBytes());

	}

}
package com.itcast.cn;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintStream;
import java.net.ServerSocket;
import java.net.Socket;

public class Server3 {

	public static void main(String[] args) throws IOException {
		ServerSocket socket = new ServerSocket(9527);// 这个可以产生socket的东西

		Socket accept = socket.accept();// 等待用户接入

		InputStream inputStream = accept.getInputStream();
		OutputStream outputStream = accept.getOutputStream();

		// 封装成我们喜欢的字符流
		BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
		// 封装我们话筒
		// BufferedWriter writer = new BufferedWriter(new
		// OutputStreamWriter(outputStream));
		PrintStream printStream = new PrintStream(outputStream);

		String readLine = reader.readLine();// 读入客户端传给服务端的数据;
		printStream.println(readLine.toUpperCase());

		accept.close();

	}

}
package com.itcast.cn;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.net.ServerSocket;
import java.net.Socket;

public class Server4 {

	public static void main(String[] args) throws Exception {
		ServerSocket socket = new ServerSocket(9527);

		Socket accept = socket.accept();// 等待用户接入

		BufferedReader reader = new BufferedReader(new // 包装后的听筒
				InputStreamReader(accept.getInputStream()));

		PrintStream stream = new PrintStream(accept.getOutputStream());

		String username = reader.readLine();
		String password = reader.readLine();

		if ("zhangsan".equals(username) && "123123".equals(password)) {
			stream.println("登录成功");
		} else {
			stream.println("登录失败");
		}
		accept.close();

	}

}
package com.itcast.cn;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.Scanner;

public class Together {
	
	public static void main(String[] args) {
		
		Receiver1 receiver1 = new Receiver1();
		receiver1.start();
		Sender1 sender1 = new Sender1();
		sender1.start();
		
	}

}

class Sender1 extends Thread {
	@Override
	public void run() {
		try {
			DatagramSocket socket = new DatagramSocket();// 如果不给端口,系统会随机分配一个
			// 需要打包
			// 需要用户自己定义发送内容,想发很多次,直接标识是 "byebye";
			Scanner scanner = new Scanner(System.in);

			while (true) {
				String nextLine = scanner.nextLine();

				if (nextLine.equals("byebye")) {
					break;
				}
				DatagramPacket p = new DatagramPacket(nextLine.getBytes(), nextLine.getBytes().length,
						InetAddress.getByName("127.0.0.1"), 8888);
				// 发送
				socket.send(p);

			}
			// 关闭资源
			socket.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

class Receiver1 extends Thread {
	@Override
	public void run() {

		try {
			DatagramSocket datagramSocket = new DatagramSocket(8888);

			DatagramPacket p = new DatagramPacket(new byte[1024], 1024);// 创建一个空包,用来接收数据

			while (true) {
				// 字节收据
				datagramSocket.receive(p);// 是个阻塞方法,
											// 如果没有数据过来就不会走这行代码,一直等,最后变成了化石
				// 走到这里,证明已经接收到数据了,而且数据装载在我们刚才创建的空包里面
				// 可以去包里拿数据
				byte[] data = p.getData();// 获取发送内容
				InetAddress address = p.getAddress();// 获取发送端的地址对象
				int port = p.getPort();// 获取发送端的端口
				int length = p.getLength();// 获取内容的有效长度
				// 展示数据
				System.out.println("发送端的ip为" + address.getHostAddress());
				System.out.println("发送端的端口为" + port);
				System.out.println("发送端的内容为" + new String(data, 0, length));

			}
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		// datagramSocket.close();
	}
}
package com.itcast.cn;

import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.util.Scanner;

public class Together1 {

	public static void main(String[] args) {

		new Receiver3().start();

		new Sender3().start();

	}

}

class Receiver3 extends Thread {
	@Override
	public void run() {
		DatagramSocket datagramSocket = null;

		try {
			datagramSocket = new DatagramSocket(9999);

			while (true) {
				DatagramPacket p = new DatagramPacket(new byte[1024], 1024);
				datagramSocket.receive(p);

				byte[] data = p.getData();
				int length = p.getLength();
				InetAddress address = p.getAddress();

				if (new String(data, 0, length).equals("再见")) {
					break;
				}

				System.out.println("收到IP为" + address.getHostAddress());
				System.out.println("收到内容为" + new String(data, 0, length));

			}
			datagramSocket.close();

		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} finally {
			if (datagramSocket != null) {
				datagramSocket.close();
			}
		}

	}
}

class Sender3 extends Thread {// 发送端
	@Override
	public void run() {
		// 创建发送端的socket对象, 然后进行后续的操作
		DatagramSocket socket = null;
		try {
			socket = new DatagramSocket(12345);
			Scanner scanner = new Scanner(System.in);

			while (true) {// 如果内容等于"再见"我们就结束

				String content = scanner.nextLine();

				DatagramPacket packet = new DatagramPacket(content.getBytes(), content.getBytes().length,
						InetAddress.getByName("192.168.26.35"), 8888);
				socket.send(packet);

				if (content.equals("再见")) {
					break;
				}
			}

			socket.close();

		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} finally {

			if (socket != null) {
				socket.close();
			}

		}
	}
}
1.网络编程:
	编程程序实现不同设备之间的信息的交互;
2.网络通信三要素
	1.ip设备的编号(为了方便找到这台设备)
		ipv4 在2011年就宣告没有了, 从此出现ipv6
	2.端口:程序的编号(为了方便找到这个程序)(0 - 65535) (0-1024) (1024 -- 65535)
		腾讯的QQ 4000:
	3.协议:程序交流的规范(UDP TCP)
		udp: 面向无连接,数据不可靠, 传输效率高
		Tcp: 面向连接, 数据可靠,传输效率低 , (需要三次握手: 为什么? 要确保双方信道都是畅通的)

	我们没办法直接使用,只能通过一个介质来使用,那个介质就是Socket()
Socket


3.InetAddress 是专门用来封装我们的ip;

    127.0.0.1 代表本地ip地址

4.编写程序的时候常见的两个错误
 1.端口号被绑定
 2.找不到主机;
5.今天遇到的阻塞方法
	1.receive(DatagramSocket p)//UDP接收端等待发送端的数据的时候,如果没有数据就一直处于等待
	2. accept();//服务端等待客户端介入,如果没有客户端介入,一直等待
	3.read()//TCP 两端等待对方的数据的时候,如果没有数据过来就处于等待状态;

6.TCP协议需要注意事项
	客户端:
		创建Socket连接服务端

	 


